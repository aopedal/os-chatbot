{"lecture_id": "os9time1", "chunk_id": "os9time1_0000", "start": 0.0, "end": 199.76, "token_count": 600, "text": "Ja... Så vi har kommet ganske så langt. Det er nå tre uker fram til påske. Og i operativsystemer, i den teoretiske delen, så skal vi i dag se litt mer på prosesser, som vi har drevet mye med. Og vi skal egentlig fortsette med det neste uke også, hvor vi skal se på plattformavhengighet og threads. Og tråder, eller threads, det blir liksom det siste store temaet innen prosesser. Så vi jobber veldig mye med prosesser, men det er tross alt det man... Det er en veldig viktig del av et operativsystem og en veldig viktig del av hverdagen. Utviklere og programmerere og alle som jobber med data. Så vi bruker mye tid på det. På de digitale forelesningene så skal vi fortsette noe med dokker. Vi skal også se på regulære uttrykk. Og så skal vi begynne å se på virtuelle maskiner. Men vi får se hvor langt vi kommer kanskje etter påske. Eventuelt blir det etter påske. Det er spørsmål om... eksamen. På informasjonen om faget på Oslomedisinens side står det at eksamenvurderingen er bestått, ikke bestått. Det må jeg undersøke, men jeg har søkt om at vi skal få bokstavkavle. Jeg trodde det egentlig var avgjort, men det er veldig fint dere spør. Da skal jeg sjekke ut det. Hvis dere ikke får beskjed snart, så... Så si ifra. For det er viktig å få avklart det med eksamen. I en digital eksamen, og så tilrettelegge det sånn at i hvert fall deler av eksamen blir individuell, sånn at ikke alle får samme spørsmål, sånn at det er veldig lett å samarbeide. Allerede i fjor hadde vi det med multiple choice-oppgaver, hvor man da fikk forskjellige typer oppgaver, eller veldig like oppgaver, men forskjellige tallverdier, da, f.eks., sånn at ikke... Man kunne bare kopiere fra en annen og samarbeide og levere inn sammen. Så det er planen. Derfor håper jeg også at det er mulig å få en noenlunde rettferdig bokstavkarakterfordeling. Men fint dere spør. Da skal jeg sjekke ut det.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0001", "start": 166.88, "end": 349.22, "token_count": 594, "text": "Allerede i fjor hadde vi det med multiple choice-oppgaver, hvor man da fikk forskjellige typer oppgaver, eller veldig like oppgaver, men forskjellige tallverdier, da, f.eks., sånn at ikke... Man kunne bare kopiere fra en annen og samarbeide og levere inn sammen. Så det er planen. Derfor håper jeg også at det er mulig å få en noenlunde rettferdig bokstavkarakterfordeling. Men fint dere spør. Da skal jeg sjekke ut det. Og nå ser jeg Ine er her også. Hallo, Ine. Hei. Hei, hei. Der er du, ja. Har ikke fått deg ny laptop? Nei. Prøver å redde den fremdeles. Ja, det er bra. OK. Ja, jeg tror jeg har en du kan låne hvis det er skikkelig krise. Du bytter noen deler også, men vi får se hva du kan gjøre. Jeg må få en ny etter hvert. Ja, den er grei. Det var litt om fremover... Så i dag så... Er oppgavene. Handler om dockerfiles, TIX, systemtics... Nikes og folk. Det er stort sett det vi snakker om i dag. Men det er jo noen digitale forelesninger, og det var en som lurte på... Det kom kanskje ikke helt fram. Jeg har ikke fått delt opp alle disse dockerfile... Eller det vil si... De som kom nå forrige onsdag, de er deltatt på. Det er de oppgavene handler om. Det er disse her. Og det som er fokus her, er først og fremst docker files. Og hvordan man bruker det. For det er standardmåten man bruker docker på. At man definerer at man skal ha inn i en container i en docker file. Og når man skal kjøre, så bare bygger man den, og kjører i vei. I tillegg er det litt tema med volumes. Hvordan man kan mappe inn filsystemer inn i containere. For det er også den fordelen å ha containere som uavhengige enheter, som hele tiden kan stoppes og startes, og at man ikke da må save filer. Nå bruker de containere på en litt annen måte i deres tilfelle, Men det er da også egentlig konteinere. Men det er cysbox-konteinere som er av en spesiell art, som bruker virtualiseringsteknikker for å verne om", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0002", "start": 310.02, "end": 493.88, "token_count": 597, "text": "Hvordan man kan mappe inn filsystemer inn i containere. For det er også den fordelen å ha containere som uavhengige enheter, som hele tiden kan stoppes og startes, og at man ikke da må save filer. Nå bruker de containere på en litt annen måte i deres tilfelle, Men det er da også egentlig konteinere. Men det er cysbox-konteinere som er av en spesiell art, som bruker virtualiseringsteknikker for å verne om eller for å øke sikkerheten for konteinerne. Vi kommer mer teoretisk tilbake til konteinere etter hvert. Nå i starten er det mest... Så er det mest... det praktiske. Hva med uka før? Skulle ikke de delen sin? Jo, jeg ligger et hakk etter, så jeg skal skikkelig ta en hard jobbøkt. Og så få delt inn alle videoene i mindre biter. For jeg vet at det er mye nyttigere for dere. Det er mye enklere hvis dere har en problemstilling dere ønsker å se på. Så det skal jeg få til i løpet av uka. Ok. Men det var én ting som var viktig her. Jo. Den første uklare autoriske oppgaven er spesielt viktig i år. Lagre et skip som først stopper alle kjørende dockcontainere. Og en sånn opprydding kan man... Når man har kommet i gang med dokkefiles, så er det greit å ha en sånn opprydding. For da har man ikke bygd et image som skal gjøre noe veldig spesielt. Hvis man skal ha i gang en konteiner, så bare bygger man fra den dokkefilen, og så har du konteineren. Og så setter du i gang i det. Og da blir også det meste mye ryddigere. For da kan du bare rydde bort alt, og da bruker man mindre ressurser. Og det som gjør at det er spesielt viktig i år, er at... Når vi kjøpte den serveren som vi bruker til dette her, så trodde vi at vi hadde et nettverksfilsystem som vi kunne bruke, men det visste jeg at vi ikke kunne, så derfor sitter vi igjen med en veldig liten disk på serveren, Den har faktisk ca. åtte ganger så mye ram som det er disk. Og det er ganske spesielt. Så masse ram, men lite disk.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0003", "start": 454.78, "end": 629.96, "token_count": 592, "text": "Og det som gjør at det er spesielt viktig i år, er at... Når vi kjøpte den serveren som vi bruker til dette her, så trodde vi at vi hadde et nettverksfilsystem som vi kunne bruke, men det visste jeg at vi ikke kunne, så derfor sitter vi igjen med en veldig liten disk på serveren, Den har faktisk ca. åtte ganger så mye ram som det er disk. Og det er ganske spesielt. Så masse ram, men lite disk. Og den begynte her for en uke siden og begynte å bli full. Så det er viktig å rydde bort image og containere, for de lagres sånn fortløpende. Hvis containeren deres stopper, eller blir stoppet, og vi starter den igjen, så vil dere fortsatt ha de samme filene der osv. Men dette lages på disken, og den begynner å fylles opp. Så det er viktig at dere gjør dette. Spesielt når du har begynt å komme i gang med dokkefiles. Så er det greit å bare ta en opprydding og fjerne alt. Ikke meningen vi skal gjøre det hver time, men sånn hver uke kanskje. Kjøre en opprydding. Så kan dere eventuelt spisse disse skriptene, sånn at dere ikke fjerner alpen... F.eks. ha en måte å spare noen av de imagene som dere bruker og har tenkt å bruke fremover. Ellers så er den viktigste oppgaven å gjøre det samme som i forrige ukes oppgaver igjen. Men denne gangen... Med dokkefiles, som er en mer standard måte å gjøre det på enn å først bygge en Ubunter fra scratch og gå inn på den og installere osv. Det er mer den vanlige måten å gjøre det på en fysisk maskin eller en virtuell maskin. Men med containere så er det dokkefiles som gjelder, som er standardmåten å gjøre det på. Vi kommer mer tilbake til det teoretiske rundt dokker og virtuelle maskiner og fysiske maskiner. Men så det er en... Vi er egentlig... Vi ser på alle tre delene. Når jeg bruker den desktopen på jobben som heter Rex, og laptopen min som heter Lap, så er det fysiske maskiner. StudSSO, som dere bruker mye, det er en virtuell maskin.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0004", "start": 594.76, "end": 806.72, "token_count": 593, "text": "som er standardmåten å gjøre det på. Vi kommer mer tilbake til det teoretiske rundt dokker og virtuelle maskiner og fysiske maskiner. Men så det er en... Vi er egentlig... Vi ser på alle tre delene. Når jeg bruker den desktopen på jobben som heter Rex, og laptopen min som heter Lap, så er det fysiske maskiner. StudSSO, som dere bruker mye, det er en virtuell maskin. Mens dokker, det er containere oppå toppen der. Den viktigste forskjellen på virtuelle maskiner og containere, er at virtuelle maskiner har sitt helt eget operativstem. Og dermed går det med veldig mye ressurser til det. Dokkekonteinere bruker det underliggende operativstemmet. Og dermed er det mye raskere å stoppe og starte. Og mye mer ressursbesparende. Så det er den største forskjellen. Men det kommer vi også enda mer tilbake til. OK. Da skal vi begynne å se på det vi skal gjøre i dag. Aller først skal vi se litt på systemkall og timertics. Vi kunne jo starte aller først med sist. Håper dere har fått med dere den forelesningen med vafler. Og jeg lager vaffelrøre og foreleser samtidig. Og det er langt fra bare på tull. Jeg håper at den illustrerer på en god måte hvordan et operativsystem virker. Og spesielt scheduleren som schedulerer mellom de prosessene som skal stå og kjøre. Jeg bruker en del referanser til dette, f.eks. dette med cornal mode. Med en gang en timer interrupt kommer, så setter jeg på hjelm. Og da kjører jeg i cornal mode. Og da er det kjernen som stiller. Og det er litt av det vi skal se på nå med systemkall. For som dere husker, for eksempel, når jeg skal knuse egg... Det var noe man ikke kan gjøre i UseMovds. Da må man inn og bruke hardware-ressurser, og da må man gjøre et systemcall. Så vi skal se litt i praksis på hvordan systemcall fungerer. Da skal vi se det i et terminalvindu. Her har jeg et C-program. getpid.c. Og det C-programmet... Det utfører et systemkall en rekke ganger. Så getpid... Det er faktisk et systemkall.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0005", "start": 743.76, "end": 978.04, "token_count": 590, "text": "For som dere husker, for eksempel, når jeg skal knuse egg... Det var noe man ikke kan gjøre i UseMovds. Da må man inn og bruke hardware-ressurser, og da må man gjøre et systemcall. Så vi skal se litt i praksis på hvordan systemcall fungerer. Da skal vi se det i et terminalvindu. Her har jeg et C-program. getpid.c. Og det C-programmet... Det utfører et systemkall en rekke ganger. Så getpid... Det er faktisk et systemkall. Sånn at jeg kan utføre et systemcall direkte med en metode. Jeg har inkludert dette biblioteket der. Det er det mulig å kalle get paypay. Det er da get parent ID. Så vi skal ikke bruke den i den, men vi skal bare se hva som skjer når man utfører 10 mill. systemcall på... Så jeg kan da prøve å kompulere getpid. Og så kan jeg kalle det getpid. Sånn. Da får jeg et program som heter getpid. Og så kan jeg kjøre det. Da ser jo vi at det skjer ikke så mye. Men det som skjer i bakgrunnen... At vi kjører det 10 000 ganger. Men det jeg egentlig ønsker å se på, er... Hvor mye av dette foregår nå i UseMode, og hvor mye i Kölnmode? Så da kan jeg åpne en annen fil som heter... Hva kalte jeg den? Sys. Og det de gjør, det prøver å telle opp antall tics som kjøres. Og da er det antall tics i use-involved og i curler-mode. Og vi har sett tidligere på Prock at her så ligger det informasjon dynamisk om hver prosess som kjøres. Og det dette programmet gjør, er at først så ser det på en linje som inneholder CPU3 i Proxat. Og denne linjen inneholder all informasjon om TIX som kjøres av CPU3. Og TIX, eller GIFIS, som det ofte omtales, det er... Det er den minste tidsenheten. Som typisk er et hundredels. Den kan varieres, men i praksis vil jeg si at den ofte er et hundredels sekund. Og det er akkurat det samme som den kjøkkenklokka jeg hadde i vaffelsimuleringen, som bruker ett minutt, men i det virkelige tilfellet", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0006", "start": 943.2, "end": 1134.92, "token_count": 584, "text": "som kjøres av CPU3. Og TIX, eller GIFIS, som det ofte omtales, det er... Det er den minste tidsenheten. Som typisk er et hundredels. Den kan varieres, men i praksis vil jeg si at den ofte er et hundredels sekund. Og det er akkurat det samme som den kjøkkenklokka jeg hadde i vaffelsimuleringen, som bruker ett minutt, men i det virkelige tilfellet bruker den da et hundredels sekund. Og så er det i Proxats statistikk som teller opp hvor mange tics brukes i user mode. Og hvor mange tics brukes i curl-mode av systemet. Og det telles opp for hver prosess. Det er én oppgave denne uken som går ut på det. At dere skal se på hvor mange tics en regnejobb bruker. Og en regnejobb som regner hele tiden, den bruker da vanligvis 100 tics per sekund. Ca. 100 for hvert sekund. For den kjører bare beregnet i. Men her, når vi gjør den get paid pluss noen andre instruksjoner som ikke er systemkalt, så skal vi se at det blir litt forskjellig. Så vi kan prøve å kjøre den SUS. Da ser vi... Den skriver ut linjen for CPU3. Get PPID. Og så skriver den ut linjene igjen. Og dermed så kan vi se hvordan tallene øker. Og da ser vi at det er to tall som øker. Det er den, den kolonnen, og så er det den. Og det kan være nyttig å finne ut... Å vite hvordan... Hvordan vet jeg hva disse tallene er? Det er altså nyttig i denne oppgaven. Men da kan man se på ManProk. ManProk er stor, men man kan søke på akkurat de feltene i Prok. Her kan vi søke på ProkStat. Under ProkStat så kan vi se at det står at det er linjer her. Her blir det veldig mye info. Vi kan ta med Proxtat, så skal vi se... Første delen av Proxtat er ganske OK. Her er det et totalt oppsummert all-statistikk for alle CPU-ene. Og så ser vi det for hver enkelt CPU nedover her. Så det vi ser på nå, er CPU3. Og så må man også vite hva kolonnene betyr.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0007", "start": 1096.44, "end": 1296.32, "token_count": 584, "text": "Her kan vi søke på ProkStat. Under ProkStat så kan vi se at det står at det er linjer her. Her blir det veldig mye info. Vi kan ta med Proxtat, så skal vi se... Første delen av Proxtat er ganske OK. Her er det et totalt oppsummert all-statistikk for alle CPU-ene. Og så ser vi det for hver enkelt CPU nedover her. Så det vi ser på nå, er CPU3. Og så må man også vite hva kolonnene betyr. Og vi ser første kolonne er User. Det er Time Spent in User Mode. Altså det er antall tics spent eller brukt i user-mode. Og så er det andre kolonne, And Nice. Det er det ikke så mange av. Men vi skal se på det senere i dag. Men så kommer den tredje kolonnen, som er time spent in system-mode. Fjerde kolonne, Idol, av den fjerdekolonnen er ofte veldig stor. Så denne er størst. For stort sett så ødelegger disse CPU-ene. Altså de gjør ingenting. Så summen of Idle er vanligvis størst. Men vi ser da at du kan konstruere deg som user mode og system mode. Det er da antall tics som blir brukt av get prepaidet. Vi kan kjøre det en gang til. Og så... Ja... GPP i det. Den bare står og gjør systemcall. Men vi kan jo se hva den der gjør. Så først så grepper vi på CPU3. Og da ser vi... Da får vi ut den linjen her. Og det tallet her, 2 606 714, det er antall tics som er kjørt i... Og så ser vi... Forskjellen her er at den blir 7071. Ja, det var et spørsmål hvordan jeg søkte på ManPedge. Det er et godt spørsmål, så jeg kan ta det. Sånn. Og da står det en slash nederst til venstre. Og så skriver jeg ProkStat, og så kommer jeg dit. Hvis jeg skal finne neste, så taster jeg N. Ja, nå var det ikke noe neste, men... oi. Men la oss se på Stat, da. Så taster N. Så kan jeg bla meg nedover. Så det er veldig nyttig. Jo, vi så på det tallet her. Vi kan kjøre den en gang til, vel, så... Blir det litt lettere å se.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0008", "start": 1254.92, "end": 1504.4, "token_count": 586, "text": "Sånn. Og da står det en slash nederst til venstre. Og så skriver jeg ProkStat, og så kommer jeg dit. Hvis jeg skal finne neste, så taster jeg N. Ja, nå var det ikke noe neste, men... oi. Men la oss se på Stat, da. Så taster N. Så kan jeg bla meg nedover. Så det er veldig nyttig. Jo, vi så på det tallet her. Vi kan kjøre den en gang til, vel, så... Blir det litt lettere å se. Sånn, ja. Det var bare at den hoppet over fra 7000 her. Men her kan vi se... User-tricks 280920 minus user-tricks her 574. Og det... Det burde bli 354. Usertics. Og det betyr 354 hundredelssekunder. Er det ikke det? Kyss... Nei, vent litt. Det ble 26. Det er... 44 blir det vel. Nei, det kan det ikke bli. 46... Ja, det er litt tidlig for hoderegning. Håper det ble riktig. 346 hundredeler. Det er forskjellen i user tics, og dette er antall hundredels sekunder som det programmet vi kjørte, brukte i user mode. Og så kan vi se på sys. Og det er her. Det ser vi blir litt færre. Kommet opp i 5000 der, minus dette tallet. Så det blir 136... 149, skulle det bli... 149 sånn. Det betyr 1,49 sekunder. Så kan man jo også... For å teste dette her så kunne man kjøre time. 3.56 er det en som sier det. Ja, da har du sikkert rett i det. Nei, 56. Blir det ikke for mye? Ja, det er ikke så farlig. Vi kan se på dette tilfellet i stedet. Nå kjører jeg i time på syst.so, og da kan vi se nøyaktig hva disse tallene er. For her kommer det opp noe tilsvarende. Real-time 4,9 sekunder, user 3,5-3,1 og 1,4-18. Og disse skal da tilsvare hverandre. Og da kan vi forhåpentligvis se... Hvis vi nå prøver å trekke fra, da er det 180 pluss 172... Ja, det skulle bli... Tre... Roderegning... 3.52, ja. Det var en som hadde fått med seg det. 3.52 ble det riktige.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0009", "start": 1434.92, "end": 1700.52, "token_count": 598, "text": "For her kommer det opp noe tilsvarende. Real-time 4,9 sekunder, user 3,5-3,1 og 1,4-18. Og disse skal da tilsvare hverandre. Og da kan vi forhåpentligvis se... Hvis vi nå prøver å trekke fra, da er det 180 pluss 172... Ja, det skulle bli... Tre... Roderegning... 3.52, ja. Det var en som hadde fått med seg det. 3.52 ble det riktige. Så kan vi ta antall tics i use mode minus antall tics... Nei, antall tics i kernel mode minus antall tics i kernel mode er 141. Og da ser vi... Dette stemmer med det som Time sier. Det gjør det, fordi det er den... Det er liksom den samme informasjonen som time-bruker for å få ut dette her. Så... Så her... Dette er hundredels sekunder. Så dette er 3,52. Så er det lite grann forskjell. Og så er det 1,41. Og da... 3,52 i Use-Mode og 1,41 i System-Mode. Alt i alt det dette betyr, det er at når vi kjører dette programmet... Get PPID... Så her gjør vi systemcall, og da ber vi systemkjernen gjøre dette her. Og da vil... I 1,41 sekunder så kjører vi i corner month. Oi, 3.52. Så gjør vi det. Hvis jeg hadde gjort det tilsvarende her med en reinjobb, så ville man sett at man bare kjørte i jusemot. Vi kunne jo teste det også. La meg da i stedet kjøre rein her. Da står vi og regner. Får håpe den ikke er altfor lang. Kanskje den tar litt for lang tid. Den så ut til å ta litt lang tid, så jeg prøver på nytt med en kortere utgave. Og da ser vi. Da har det ikke skjedd noe. Her er statistikken den samme. Ingen tics har blitt utført i cullen mode. Mens her borte, her er alle ticsene kjørt. Så da står den og kjører i jusemode hele tiden. Man kjører time alene. Ja, det er riktig. Det blir bitte lite grann forskjell siden du skriver ut prokk også, for det gjør også noen tics. Men det er veldig få tics som går med til dette.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0010", "start": 1639.0, "end": 1860.84, "token_count": 585, "text": "Og da ser vi. Da har det ikke skjedd noe. Her er statistikken den samme. Ingen tics har blitt utført i cullen mode. Mens her borte, her er alle ticsene kjørt. Så da står den og kjører i jusemode hele tiden. Man kjører time alene. Ja, det er riktig. Det blir bitte lite grann forskjell siden du skriver ut prokk også, for det gjør også noen tics. Men det er veldig få tics som går med til dette. Er dette fordi man må gå i curl-mode for å få gjort et suksesspall? Det er det. Så vi ser her når jeg kjører en regnejobb, sånn som dette, så kjører man i use mode hele tiden. Da sier operativstemme at 'dette her er helt ufarlige greier'. 'Du trenger ikke old disk' eller noen ting. Så du skal bare regne. Så da kjører den prosessen i use mode hele tiden. Og dermed så ser vi at det er kun... Og vi vil jo også se det samme... Det har vi sett tidligere når vi kjører rein sånn, så ser vi at det er bare user modes. System 0,000. Kun user mode som kjører. Mens når vi ser på denne get PPPID, så er dette et systemkall. Og da går man inn i kjernen. Og det er kjernen. OK. Det var nok om systemkall. Kom gjerne med andre spørsmål, så kan vi ta det etter pausen eventuelt. Da skal vi ikke hoppe rett på nice, men vi skal si litt om prioritet. Å ha mellom prosesser, dvs. det er viktig å kunne skille prosesser på prioritet. Vi så i forrige uke at Linux opererer med noe sånt som 140 prioritetsklasser. Fra lav prioritet opp til høy. Og i utgangspunktet, det Linux-scheduleren gjør, er å gi mange tics... En lang time-slice til prosesser med høy prioritet. Og så velger man alltid den med høyest prioritet når man skal kjøre. Dvs. når scheduler kommer inn og skal gjøre en vurdering av hvilken prosess som skal settes i gang. Men grovt sett så er det Rollin' Robin. Man bare bytter på de som kjører. For selv en prosess som har høy prioritet og kommer først inn,", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0011", "start": 1814.44, "end": 1982.12, "token_count": 592, "text": "Og i utgangspunktet, det Linux-scheduleren gjør, er å gi mange tics... En lang time-slice til prosesser med høy prioritet. Og så velger man alltid den med høyest prioritet når man skal kjøre. Dvs. når scheduler kommer inn og skal gjøre en vurdering av hvilken prosess som skal settes i gang. Men grovt sett så er det Rollin' Robin. Man bare bytter på de som kjører. For selv en prosess som har høy prioritet og kommer først inn, når den er ferdig med sine tics i epoken, så vil den hoppe til neste. Og det er det som er Ron-Robin. Og dynamisk så vil den Linux-scheduleren, den vil da gjøre det sånn at interaktive brukerprosesser, de får høyere prioritet, sånn at med en gang de skal gjøre noe, så... Men de bruker gjerne ikke mye SUPU, så med en gang de er ferdige, så hopper de ut igjen. Mens batchjobber som står og bruker SUPU hele tiden, de har da lav prioritet. Men de jobber da hele tiden når ingen andre vil jobbe. Og det skal vi se på etterpå med nice, og det kan vi gjøre enda mer ekstremt. Vi kan velge å være nice og være enda mer batchjobb. Så er det forskjell på systemprosesser. Spesielt er det en del kjerneprosesser som jobber De kommer rett inn i køen, og de kan ikke kjøre Roan Robin, for de må da fullføre før noen andre kan kjøres. Det er typisk veldig korte prosesser som blir raskt ferdig, men de kommer inn, og så utfører de alt de skal, og så avslutter de. Så det er en litt annen måte å prioritere på. Og tilsvarende er det for andre operativsteammer. Alle har en type prioritering sånn som dette her. Generelt så finnes det mange scheduling- eller scheduleringsalgoritmer. Og den vi har sett på med Linux, er Ron Robin. Da bytter prosesser på å kjøre. Og tar litt tid hver runde. Og det finnes jo mange andre tilfeller hvor man bruker schedulering. Og alle disse metodene her brukes også i andre sammenhenger. Det er alle sammenhenger hvor man har ressurser. Som regel er det tidsressurser, men det kan også være andre ressurser.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0012", "start": 1941.86, "end": 2112.0, "token_count": 589, "text": "Alle har en type prioritering sånn som dette her. Generelt så finnes det mange scheduling- eller scheduleringsalgoritmer. Og den vi har sett på med Linux, er Ron Robin. Da bytter prosesser på å kjøre. Og tar litt tid hver runde. Og det finnes jo mange andre tilfeller hvor man bruker schedulering. Og alle disse metodene her brukes også i andre sammenhenger. Det er alle sammenhenger hvor man har ressurser. Som regel er det tidsressurser, men det kan også være andre ressurser. First come, first served. Det som navnet sier, så er den første prosessen som kommer inn. Det er den som setter i gang uansett. FIFO er first in, first off. Det er en annen betegnelse på first come, first served. Først som kommer inn, er den første som blir ferdig, og første som sendes ut. Det er en litt annen måte å gjøre det på. Da er det den prosessen som tar kortest tid, som er den neste som kjøres. F.eks. hvis man skal printe ut ting, så kan det være en smart måte. Hvis det er fem sections som skriver ut én side, så gjør man det først. Og så kommer den som skal ha 150 sider. Den kommer til slutt. Det er ikke alltid så lett å få til det, for da må man vite lengden på... Og det vet man generelt ikke når det gjelder prosesser. Så for prosesser så er det ikke så vanlig å ha den type skeduler. Nice. Nice er som ordet sier, å være snill med andre. Det er betydningen av ordet. Og det er akkurat det vi skal se på nå. Vi skal se hvordan vi kan endre på prioritering selv. På egne prosesser. Hvis vi ikke bruker NICE og ikke gjør dette eksplisitt, så er det jo operativsystemet som dynamisk endrer på prioriteten til prosesser. Og gir de forskjellig prioritet i forhold til hvor mye CPU de bruker. Interaktive prosesser som ikke bruker CPU, de får høy prioritet. Mens det motsatte med rene jobber. Men... nice irline... En kommando som eksplisitt nedprioriterer seg selv. Så en Linux-prosess kan nedprioritere seg selv. Og da er det sånn at høyere nice-verdi gir mindre seputi. Det høres litt rart ut, men egentlig så er det logisk.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0013", "start": 2077.72, "end": 2288.28, "token_count": 588, "text": "Og gir de forskjellig prioritet i forhold til hvor mye CPU de bruker. Interaktive prosesser som ikke bruker CPU, de får høy prioritet. Mens det motsatte med rene jobber. Men... nice irline... En kommando som eksplisitt nedprioriterer seg selv. Så en Linux-prosess kan nedprioritere seg selv. Og da er det sånn at høyere nice-verdi gir mindre seputi. Det høres litt rart ut, men egentlig så er det logisk. For hvis du har en høy nice-verdi, den går opp til 19, som er maks, så er du ekstremt snill mot andre. Da er du veldig beskjeden, som lua i hånda bare tar seputix Defolt nice-verdi er null. Da ligger du på midten. Og du kan også ha negative nice-verdier. Og hvis du er negativ nice, da er du bad. Så de prosessene er slemme og tar ekstra CPU-tid fra de andre. Og det er da typisk noen sånne RUT-prosesser som har negativ nice-verdi. Det kommer noen oppgaver om dette også. Litt av clouen da er at for å sette negative nice-verdier, så må du være roots, ellers får du ikke lov til det. Men vanlige brukere kan sette vanlige nice-verdier. Så... Ja, vi kan starte og så se litt på det. Jeg starter med regn, og så kan jeg sette... Oi! Nå skal vi gå på Nice, og da må jeg ha med dere. Der var vi. Ja, vi skal nå se på Nice og... Hvordan vi kan bruke Nice til å endre på prioriteten. Den jobben står og kjører lenge, sånn at jeg kan endre på nice-verdien. Så jeg kan ta... Først kan vi vise hvordan det brukes. Vi kan f.eks. starte nice minus N9 og så regn. Den starter da... En regnejobb med nice verdi 9. Og det kan vi se her når vi kjører topp. Så se her... Her står det 9. Det er da nice verdi 9. Men det som da er litt rart, er... Oi... Nå ser jeg at jeg står litt i veien her. Sånn.  Det som er litt rart, er at her oppe så ser vi... Denne jobben bruker jo 100 % CPU. Selv om den er nice. Så det var litt rart.", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0014", "start": 2244.92, "end": 2478.08, "token_count": 597, "text": "En regnejobb med nice verdi 9. Og det kan vi se her når vi kjører topp. Så se her... Her står det 9. Det er da nice verdi 9. Men det som da er litt rart, er... Oi... Nå ser jeg at jeg står litt i veien her. Sånn.  Det som er litt rart, er at her oppe så ser vi... Denne jobben bruker jo 100 % CPU. Selv om den er nice. Så det var litt rart. La oss si jeg prøver å sette i gang en ting. Jo, den er veldig nice, men... Den bruker fortsatt så å si 100 % separatitet. Så skal vi se hvordan man også kan renice. Jeg kan renice og så si pluss 19 på den paydayen der, den som hadde 9. Og da setter vi Old Priority 9, New Priority 19... Vi kan sjekke om den er absolutt. Er det minus 3...? Nei, jeg får ikke lov til å sette minus 3. Da får jeg permission denied. That's a minus... Det betyr bare z til... Nei, pluss skal altså... Jeg får ikke lov til å være negativ. Pluss 18 betyr... Sett verdien til pluss 18... Men hvorfor fikk jeg...? Ikke la være å renisse den... Gjør jo sånn, ja. Der fikk jeg prioritert 19 på den prosessen. Men likevel... Fortsatt er problemet her... Det høres ikke ut som noe av det jeg har sagt, er riktig i det hele tatt. De er jo ikke nice. De tar alle steppene. Du kan kanskje ikke gjøre den lavere? Ja, det var et godt spørsmål... Det skulle være mulig å gjøre det lavere. Det må jeg undersøke. Men det kan jeg ta pausen å gjøre. Og så kan dere også da... I pausen kan dere tenke på... Hva er det som gjør at nice ikke ser ut til å ha noen effekt der? Hvorfor fortsetter de å kjøre i 100 % disse jobbene? Selv om de har en høy nice-verdi. Jeg ser for øvrig et par ruteprosesser. Det vil si den høyeste prioriteten du kan gitt i noen prosess med nice minus 20. Men de jobber ikke så mye, men med en gang de ønsker seg pus, så får de det. Og så blir det prioritert fremfor alle andre. Tenk litt på i pausen... Hva kan dette skyldes?", "source": "lecture"}
{"lecture_id": "os9time1", "chunk_id": "os9time1_0015", "start": 2438.12, "end": 2490.48, "token_count": 152, "text": "Hvorfor fortsetter de å kjøre i 100 % disse jobbene? Selv om de har en høy nice-verdi. Jeg ser for øvrig et par ruteprosesser. Det vil si den høyeste prioriteten du kan gitt i noen prosess med nice minus 20. Men de jobber ikke så mye, men med en gang de ønsker seg pus, så får de det. Og så blir det prioritert fremfor alle andre. Tenk litt på i pausen... Hva kan dette skyldes? Så kan vi se på om det går an å ri nese nedover. Da tar vi en liten pause der, så stopper jeg recordingen.", "source": "lecture"}
