{"lecture_id": "os3del3", "chunk_id": "os3del3_0000", "start": 0.0, "end": 165.76, "token_count": 587, "text": "Først en kort oppsummering av hva vi gjorde sist. Vi har startet ut med transistorer, som egentlig er bare veldig små brytere. Det kommer en ledning inn til bryteren som skrur den av og på. Hvis den er på, så leder transistoren strøm. Hvis den er av, så leder transistoren ikke strøm. Veldig enkelt. Og dette enkle prinsippet kan man da bruke til å lage logiske porter. Og med logiske porter så kan man implementere and or not. Og på den måten så kan man implementere alle logiske sammenhenger. Og dette brukes da i en datamaskin for å lage en maskin som gjør nøyaktig det vi ønsker den skal gjøre. Og det vi ønsker den skal gjøre, er forskjellige institusjoner. Legge sammen to tall, trekke fra hverandre tall, sammenligne to tall, osv. Og når man har klart for seg hvilken funksjon man skal gjøre... I forrige gang så vi på dette med å addere. Addere to tall. Og da så vi på algoritmen for å addere to tall. Og da fant vi ut at en bit av den algoritmen, det kan vi ta ut og lage en logisk krets av. Og det første man gjør da, er bare å skrive ned en krets. Som viser logikken systemet skal ha. Og så så vi at ut ifra en sannhetstabell, så kan man skrive rett ned en krets med and or and not-porter. Det er en veldig rett frem metode for å gjøre det. Etter at man har gjort det, så kan det bli ganske komplekse kretser. Men da kan disse forenkles med Bolskalgebra. Og når man har gjort det, Man kan sende den til en produsent, og så kan man få et kretskort som gjør nøyaktig det man ønsker. Man lager som regel ikke et kretskort av bare en liten av dere, som vi gjorde sist. Men man har en litt større krets. Men prinsippet er akkurat det samme. Vi så på én liten boks. Hemmeligheten med å lage en hel CPU er at man tar mange Og setter sammen til en stor og kompleks enhet som gjør akkurat det man ønsker. Det vi laget sist, var en krets med... en logisk krets som aderer tall.", "source": "lecture"}
{"lecture_id": "os3del3", "chunk_id": "os3del3_0001", "start": 130.12, "end": 306.94, "token_count": 590, "text": "som gjør nøyaktig det man ønsker. Man lager som regel ikke et kretskort av bare en liten av dere, som vi gjorde sist. Men man har en litt større krets. Men prinsippet er akkurat det samme. Vi så på én liten boks. Hemmeligheten med å lage en hel CPU er at man tar mange Og setter sammen til en stor og kompleks enhet som gjør akkurat det man ønsker. Det vi laget sist, var en krets med... en logisk krets som aderer tall. Avdelingskrets. Så dette var på en måte sluttresultatet fra forrige time. Det vi har oppnådd, er at vi har lagd et lite kretssystem ved hjelp av logikk og enkle brytere av og på brytere, som er sånn at hvis vi sender inn fire bit A og fire bit B inn til denne maskinen, så uansett verdien på nullerne og enerne her, så får man ut summen C av. I dette eksempelet så står det tallet seks, både A og B. Og det som kommer ut, det er en ener, toer, firer og en åtter. Så det er åtte pluss fire. Det er tolv som kommer ut. Og det er det riktige svaret i dette tilfellet. Det vi kanskje ikke sa så mye om sist, er at det er et opplagt problem her. Hva om man legger sammen et stort tall? La oss si vi har enere på alle her. Det blir 3 pluss 12, det blir 15. Hvis man legger sammen 15 pluss 15, så får man jo 30. Men det største tallet som kan lages eller vises med 4 bit, det er jo 15. Så her skjer det noe galt. Og da får man en såkalt overflow. Og det fører ofte til problemer. Sånn er det. Hvis man regner med 32-bitstall, f.eks., så kan de maks... Hvis man tar med pluss og minus, så kan de maks representere 2 mrd. Hvis man da utfører et regnsyke i et C-program, eller et annet program hvor resultatet blir høyere enn 2 mrd., så får du en feil. Da kan man plutselig risikere å få et negativt tall. Når man... Man legger sammen to store tall. Dette gjelder for alle systemer, men man må bare ha nok bitt,", "source": "lecture"}
{"lecture_id": "os3del3", "chunk_id": "os3del3_0002", "start": 270.0, "end": 350.4, "token_count": 265, "text": "Sånn er det. Hvis man regner med 32-bitstall, f.eks., så kan de maks... Hvis man tar med pluss og minus, så kan de maks representere 2 mrd. Hvis man da utfører et regnsyke i et C-program, eller et annet program hvor resultatet blir høyere enn 2 mrd., så får du en feil. Da kan man plutselig risikere å få et negativt tall. Når man... Man legger sammen to store tall. Dette gjelder for alle systemer, men man må bare ha nok bitt, sånn at man kan få representert så store tall som mulig, eller som man behøver. Så ser vi at vi egentlig bare trenger ett bitt til, så kan vi representere summen av alle firebits tall. Men nå kommer... Det vi trenger å gjøre videre, det er problemer at denne kretsen, den kan jo bare legges sammen. Og det er jo ikke alt vi skal legge sammen. Så derfor så lager man da heller en litt mer kompleks krets, som kan gjøre flere ting på en gang.", "source": "lecture"}
