{"lecture_id": "os8time2", "chunk_id": "os8time2_0000", "start": 0.0, "end": 250.32, "token_count": 587, "text": "Da har jeg satt på recording igjen, så forelesningen blir tatt opp. Multiple choice-obligatoriske oppgaver. Så... Det er forhåpentligvis et relativt enkelt spørsmål som dere kan prøve å svare på. Fra deg vi snakket om i første time. Ine, er du der? Ja. Du er der. Flott. Har det vært noen spørsmål i chatten som jeg ikke har fått med meg? Det har vært spørsmål til meg direkte, men da er jeg svart på det. Ja, flott. Er det noen som er noen viktige spørsmål som du tenker mange kan lure på? Ja, litt sånn i forhold til... Kanskje noen eksempler på hyperthreading og sånt noe. F.eks. om det er litt eksempler på det. I forhold til det, kanskje. Og så kanskje greit... Det har vært tidligere noen spørsmål i forhold til det med når man skal sjekke at det vil være litt antall kjerner man får opp. For seg selv og for systemet er jo ikke alltid helt bestemt. Nei. Ja, det er et godt spørsmål. Og det kan jo være litt forvirrende. Ja, jeg kan... Etterpå... Jeg tenkte å få litt tid til å se på dokkekonteinere. Så jeg kunne si litt om de VM-ene og den... For det er en oppgave med hypertrening hvor du skal se på din egen VM. Jeg har fått spørsmål om det tidligere, men det er sikkert greit å... ja, kanskje vise litt om det, eller noe sånt noe. Ja, når det gjelder hypertrening... Ja, så... Jeg viste to eksempler på hypertrening sist, og det er kanskje det... de viktigste eksemplene. Og det vi så på, var regnejobber. Altså den rein eller... Eller bæsjskilt som bare heter regn. Hvis vi kjører det på to Sonyer og regnejobber på en hypertreding-tjernet, så så vi at det tar nesten dobbelt så lang tid. For de må da bytte på å bruke alum. Men samtidig kjørte vi en annen prosess. En rammeprosess som hele tiden skrev til et r-øyet ramm. Og den så vi kunne i noen tilfeller kjøre nesten dobbelt så fort.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0001", "start": 210.0, "end": 383.62, "token_count": 587, "text": "Og det vi så på, var regnejobber. Altså den rein eller... Eller bæsjskilt som bare heter regn. Hvis vi kjører det på to Sonyer og regnejobber på en hypertreding-tjernet, så så vi at det tar nesten dobbelt så lang tid. For de må da bytte på å bruke alum. Men samtidig kjørte vi en annen prosess. En rammeprosess som hele tiden skrev til et r-øyet ramm. Og den så vi kunne i noen tilfeller kjøre nesten dobbelt så fort. Altså at det gikk like fort om man hadde to sånne prosesser inne på samme kjerne. Så hvis én sånn prosess kjører alene, så klarer den ikke å utnytte alle ressursene. Og dermed så kan to sånne kjøre omtrent like fort som om de var alene på den kjernen. For mer normale programmer så ligger ofte svaret sånt et sted i midten der. Men det var også et... Ja, jeg kan ta det. Og et annet spørsmål kan vi ta etterpå. Men nå kan vi stoppe pollingene. Og se de fleste har svart. Og det ser veldig bra ut. Ser du den nå, Ine? 70... Ser du Poll...? Nei, det ser du ikke. Share results. Sånn. Nå ser jeg, ja. Flott. Sharing Poll Results. Ja. Det er et svar som skilte seg veldig ut der, og det er kjempebra, for det er det riktige svaret. 82 % av svarte. Veldig bra. til å gi begrensede tidsintervall til brukerprosessene. Det er en hardware-timer i CPU-en som slår inn hvert hundredels sekund. Når det skjer, så switcher... Modusbit for CPU-en switcher over til kernel mode, kernel modus, og operativsystemet tar over. Så velger operativsystemet hvilken prosess som skal kjøre videre. Switcher til brukermodus og... Setter i gang den prosessen. Så kan en stå og eksklusivt bruke CPU-en i use mode, så den kan gjøre omtrent alle instruksjoner, som move og add osv. Men der noen få den ikke får lov til å gjøre, sånn som f.eks. holdt. Den får ikke lov til å stoppe maskinen. Og dermed så har CPU-en kontroll.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0002", "start": 352.66, "end": 554.9, "token_count": 597, "text": "Så velger operativsystemet hvilken prosess som skal kjøre videre. Switcher til brukermodus og... Setter i gang den prosessen. Så kan en stå og eksklusivt bruke CPU-en i use mode, så den kan gjøre omtrent alle instruksjoner, som move og add osv. Men der noen få den ikke får lov til å gjøre, sånn som f.eks. holdt. Den får ikke lov til å stoppe maskinen. Og dermed så har CPU-en kontroll. Jeg kan se på de andre som overlater timesharingen til hardware og alle rytmer.... Det er litt sannhet i det også, siden hardware er med ved modus bit osv. Og en hardware-timer som sender signaler, får et intervju... Men selve algoritmene er det operativsystemet som styrer. Den hardware-timeren gir kontrollen til operativsystemet, og derfra tar operativsystemet kontroll. Det andre svaret virker også ganske riktig. Og så venter de prosessen til at prosessen skal gjøre gi opp, og gir da cpd-en til neste prosess i readylist. Ja, det er ikke sånn... Det er ikke helt feil. Hvis en prosess skal gjøre input-output-operasjoner og ikke trenger cpd-en lenger, så vil operativsystemet gi over. Men det er ikke det som er hovedmekanismen. Og hovedmekanismen er at den deler inn tiden i likeintervaller, og på den måten gir hver prosess en liten bit av tid, når den måtte trenge det. Det er en mulig løsning, og det var noe lignende som det som Windows 95 hadde opprinnelig som multitasking. Altså at den bare hadde en sånn liste, og så sa den... OK, nå skal Prosess A få 100 sekunder. Kjør det 100 sekunder, og så gi tilbake kontrollen til meg. Men da var det fortsatt i cornal mode. Sånn at da kunne prosessen gjøre holdt eller ødelegge for systemet. Så dette her ville... Hvis du bare gir hver prosess lov til å stå i kjøre og starte, så ville det fungere helt greit helt til det var en bug i et program. Eller et program som var ondsidet med hensikt, og som prøvde å ta over og få mest mulig CPU til seg. Men hvis alle prosesser oppførte seg OK, og ikke krasjet systemet, så ville et sånt opplegg ha fungert.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0003", "start": 508.2, "end": 722.28, "token_count": 587, "text": "Sånn at da kunne prosessen gjøre holdt eller ødelegge for systemet. Så dette her ville... Hvis du bare gir hver prosess lov til å stå i kjøre og starte, så ville det fungere helt greit helt til det var en bug i et program. Eller et program som var ondsidet med hensikt, og som prøvde å ta over og få mest mulig CPU til seg. Men hvis alle prosesser oppførte seg OK, og ikke krasjet systemet, så ville et sånt opplegg ha fungert. Men det er nettopp det med bug. Vil aldri systemet gå ned. Men hvis du hadde et opplegg som dette her, som gjorde at alle prosesser kunne kjøre kurlemode og gjøre hva du ville, da kunne man risikere at hver gang det var et bug i et brukerprogram, så kunne systemet gå ned. Og sånn var det tidligere. Som på Windows på slutten av 80-tallet. Og da gikk systemet ned. Med denne måten gjør at operativstemaet har full kontroll, og systemet blir mye sikrere. Ok. Da skal vi fortsette med systemkall. Og det var et godt spørsmål i pausen om at man kan switche fra... Da kan man gjøre en institusjon som switcher. For i kernel-mode så har man allmakt. Men fra user-mode så kan man ikke switche til kernel-mode. Men det switcher jo til kernel-mode. Men den switchen foregår i det øyeblikket at... ... at timeren går på, sender et signal, og så switches det til kernel-mode. Operativsystemet inn og tar over. Men det som jeg mente med at man ikke kan switche fra use-to-mode til curner-mode, det er... Det finnes ingen instruksjon, sånn som det står her... Det finnes ingen instruksjon switch-to-cerner-mode som en vanlig brukerprosess kan utføre. For hvis den fantes, så kunne den bare i prosessen gjøre searche curner-mode, og så vips, så var den i curner-mode og kunne gjøre hva den ville. Så hva da når et brukerprogram skal gjøre noe som... Som skal gjøre instruksjoner som ikke kan utføres fra use mode? Hvordan kan da brukerprogrammet få til det?  Og det kan f.eks. være sånn som å lese noe fra disk. Sånn generelt så har jo operativsystemet full kontroll på disken.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0004", "start": 672.84, "end": 877.04, "token_count": 588, "text": "For hvis den fantes, så kunne den bare i prosessen gjøre searche curner-mode, og så vips, så var den i curner-mode og kunne gjøre hva den ville. Så hva da når et brukerprogram skal gjøre noe som... Som skal gjøre instruksjoner som ikke kan utføres fra use mode? Hvordan kan da brukerprogrammet få til det?  Og det kan f.eks. være sånn som å lese noe fra disk. Sånn generelt så har jo operativsystemet full kontroll på disken. Men hvordan kan da et brukerprogram lese noe fra disken når den må da utføre operasjoner som bare kan gjøres i kernel mode? Jo, der da systemcall kommer inn. Og det er rett og slett... Et brukerkode som ber kjernen om hjelp ved hjelp av SystemColl. SystemColl er egentlig bare et API mot operativsystemkjernen. Det er et sett med operasjoner som en vanlig brukerprogram fra YSIMOD kan be operativsystemkjernen om å gjøre. På samme måte som du har et API... Et Application Programming Interface mot moduler og programmer av alle mulige typer. Da er det liksom alle de operasjonene som det er mulig å få utført med dette programmet eller denne metoden. Ja, så... Men vi har et dilemma her hvis vi skal... Hvis vi skal gjøre noe som krever current mode. Det kunne jo være sånn at man... At brukerprogrammet kunne sette modusbytt til kernel mode, og så... Og så utføre det man trengte, og så skulle det switches tilbake. Men da får du igjen problemet. Hvis du kan gjøre switch til kernel mode, så kan brukerprosessen ta over og stoppe systemet. Så igjen må vi ha hjelp fra Harvey, og da er det en spesiell intensjon som heter Trap. At den switcher til curl-mode og hopper til kode for et systemkall i én og samme operasjon. Og det betyr at fra use-mode så kan du ikke da først hoppe til curl-mode, og så love å si... Ja, etterpå... Jeg lover. Jeg skal gjøre systemkall etterpå. Men dette må gjøres i én og samme operasjon. Og da, for å få til noe i én og samme operasjon, så må man ha én Så igjen så får man hjelp fra Hardware for å få til systemkall. Her er en oversikt over hvordan et systemkall foregår.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0005", "start": 834.64, "end": 1022.48, "token_count": 590, "text": "i én og samme operasjon. Og det betyr at fra use-mode så kan du ikke da først hoppe til curl-mode, og så love å si... Ja, etterpå... Jeg lover. Jeg skal gjøre systemkall etterpå. Men dette må gjøres i én og samme operasjon. Og da, for å få til noe i én og samme operasjon, så må man ha én Så igjen så får man hjelp fra Hardware for å få til systemkall. Her er en oversikt over hvordan et systemkall foregår. Og da ser vi på venstre side her, så er vi i brukerminnet.  Og på høyre så har vi privilegert-minnet. Og her er det vanlig brukerkode som kjører YSEMOD, Institusjon 1, 2, 3 osv., og så skal det gjøres et systemcall. Og det er systemcall nummer tre i API-et. Og sånn ser det ut i Lynix-API-et. Så er det systemcall nummerert når det var her. Det finnes mange hundre systemkall. Men det er noen få som gjøres veldig ofte. Og tredje systemkall, Sister Read, det er akkurat det jeg også leser fra disk. Og det kan man ikke gjøre i Use and Mold. Og det som skjer da, er at her kommer det et systemkall Trap 3. Da... En viktig del av systemkallet er den institusjonen trap. For den switcher da til... Den switcher modus bit til curl mode samtidig som den hopper inn i en branching-tabell her og hopper til første kodelinje i det systemkallet. Så da, i én institusjon, så switchers modus bit, og... Den første institusjonen for dette systemkallet legges inn i... ... inn i institusjonsregisteret. Det er den neste institusjonen som skal gjøres. Det må vi hele tiden tenke på. Vi har i utgangspunktet bare én CPU som vi ser på, og det er bare én av gangen som kan gjøre institusjoner. Så dermed må man ha en sånn hardwarehjelp fra Trap for å kunne både hoppe inn, Og på denne måten så får man full kontroll. Wymbranching-tabell, det er rett og slett bare en tabell som peker på de forskjellige systemkallene. Du ser det går en pil fra systemkall 3. Her ligger da adressen til", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0006", "start": 981.84, "end": 1179.36, "token_count": 598, "text": "Det må vi hele tiden tenke på. Vi har i utgangspunktet bare én CPU som vi ser på, og det er bare én av gangen som kan gjøre institusjoner. Så dermed må man ha en sånn hardwarehjelp fra Trap for å kunne både hoppe inn, Og på denne måten så får man full kontroll. Wymbranching-tabell, det er rett og slett bare en tabell som peker på de forskjellige systemkallene. Du ser det går en pil fra systemkall 3. Her ligger da adressen til der de rammet som første institusjon i dette systemkallet ligger. Ja, dette er en illustrasjon fra Tanbaum på systemcall. Her er det litt mer... Litt flere detaljer, men ideen er den samme. Vi har vanlige instruksjoner her. Én, to, tre. Og så kaller man rid. Med å få riktige verdier inn i forskjellige registre osv. Men så er det da the trap to cornal. Da hopper man inn i kjernekodet, utfører systemkallet, og så hopper man tilbake igjen. Men det er klart, det er masse som må holdes orden på her. At man må hoppe tilbake til riktig sted i use mode osv. Så det er en ganske kompleks operasjon. Men det viktige prinsippet, det er... Og at man da både switcher i modusbytt og hopper til systemkallkoden. I én og samme institusjon. Her er noen eksempler på systemkall. Vi så et av de tidligere, var Fork. Og det er typisk noe som er systemkall. Altså at man... Fork brukes i Linux til å... Og sette i gang en ny prosess. Det kan ikke et vanlig brukerprogram gjøre. Der må operativsystemet inn og styre. Ja... Vi skal bruke det litt senere når vi skal forke og snakke med Child. Men dette er igjen sånn prosessmanagement. Så har vi sånn som File Management, som vi har sett på med Open, Close, Read... Det er greit å skrive til og fra filer. Disken og filsystemet, det er det operativsystemet som kontrollerer. Og her er det klart, det her må vi bruke systemcall for å oppnå det. Igjen så kunne vi hatt vanlige brukerprosesser som styrte dette fra jus imot. Men da kunne man risikere å krasje hele disken.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0007", "start": 1141.8, "end": 1356.2, "token_count": 593, "text": "Men dette er igjen sånn prosessmanagement. Så har vi sånn som File Management, som vi har sett på med Open, Close, Read... Det er greit å skrive til og fra filer. Disken og filsystemet, det er det operativsystemet som kontrollerer. Og her er det klart, det her må vi bruke systemcall for å oppnå det. Igjen så kunne vi hatt vanlige brukerprosesser som styrte dette fra jus imot. Men da kunne man risikere å krasje hele disken. For andre brukere osv. Så er det sånn som Directory og System Management, med MKDIR og LinkMount... Vi ser sånn som MKDIR. Det er en del av de Shell-kommandoene som faktisk heter det samme som systemkall. Og i C så er alle disse systemkallene implementert. Skrive- se-programmer som direkte utfører systemcall mot Linux-kjernen. Ja, her er en del sånn diverse, sånn som Kill, for eksempel, som opplagt trengs et systemcall for å gjøre. Det kan heller ikke en brukerprosess gjøre mot f.eks. andre brukere. Ja, her er noen Windows-systemcall. Jeg har satt opp en masse systemcall for Unix og Windows. Og da... Dette er bare for å illustrere at alle moderne operativsystemer har en tilsvarende mekanisme med systemcall. Men ofte er ting ganske forskjellig, sånn som Windows 32. De har rett og slett en create-prosess. Det er da et systemkall som lager en ny prosess. Men akkurat som Linux har read, så har Windows' operativstemme read file for å lese data fra en fil. Men i prinsippet så virker Windows og andre operativstemmer på nøyaktig samme måte, at det må gjøre systemkall for å... Vanlige brukerprosesser må gjøre systemcall når de skal gjøre kjerneoperasjoner. Altså alt som har med å snakke med hardware, og alt som har med å styre prosesser. Det er typisk kjernevirksomhet som man er nødt til å gjøre systemcall for å få utført. Da skal vi se litt spesifikt på Linux-sheduling. Og i den simuleringen av å lage vaffelrør og forelese så er det denne scheduling-algoritmen som jeg tar utgangspunkt i. Men det finnes mange andre scheduling-algoritmer. Windows har en annen.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0008", "start": 1310.7, "end": 1514.96, "token_count": 593, "text": "Altså alt som har med å snakke med hardware, og alt som har med å styre prosesser. Det er typisk kjernevirksomhet som man er nødt til å gjøre systemcall for å få utført. Da skal vi se litt spesifikt på Linux-sheduling. Og i den simuleringen av å lage vaffelrør og forelese så er det denne scheduling-algoritmen som jeg tar utgangspunkt i. Men det finnes mange andre scheduling-algoritmer. Windows har en annen. Den som er i nyere Linux-kjerner... Er en litt annen kjerne... En litt annen scheduler. Skedulerer, eller tidsfordeler. Og den heter Completely Fair Scheduler, CFS. Den tok over for den som var i Linnis 2.6-kjernen, som var i mange 10-15 år. Og det var fordi at den ikke alltid var helt fair. Det var noen da i... En Linux-kjerneutviklergruppe som kom opp med et forslag til en ny scheduler. Så etter mye testing og feiling og prøving, erstattet den den gamle scheduleren. Det er en O1-scheduler, som betyr at den skalerer sånn at det går like raskt om det er 200 prosesser, eller om det er 10 prosesser som skal scheduleres. Det er det jernmannen forbinder med ordet scheduling. Det er å fordele ressurser blant en rekke enheter som trenger disse ressursene. Så scheduling kan brukes i mange tilfeller, men dette er da CPU-scheduling som operativsystemet utfører, som vi ser på nå. I Linux 2.6-scheduling så deles tiden inn i epoker. Og da... Hver prosess som skal kjøre, tildeles et time-countum. Og dette time-countumet er da målt i jiffis, eller tics. Og det er disse hundredelssekundene, eller ti millisekunder, som vi snakker om. Det er liksom det minste tidsintervallet. Hver gang timeren slår, så går det ett tics. Vi har vel sett på det så vidt... I Proxtat så er det en sånn liste over tics. Da kan man f.eks. se at siste sekund så har man kjørt 80 tics i user mode og 2 tics i curl mode med denne prosessen. Da betyr det at denne prosessen har hatt CPU-en omtrent hele tiden. Det er den viktige minste tidsenheten.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0009", "start": 1469.08, "end": 1650.08, "token_count": 593, "text": "som vi snakker om. Det er liksom det minste tidsintervallet. Hver gang timeren slår, så går det ett tics. Vi har vel sett på det så vidt... I Proxtat så er det en sånn liste over tics. Da kan man f.eks. se at siste sekund så har man kjørt 80 tics i user mode og 2 tics i curl mode med denne prosessen. Da betyr det at denne prosessen har hatt CPU-en omtrent hele tiden. Det er den viktige minste tidsenheten. Men så kommer det en epoke... Det er da en annen og større tidsenhet. Man gir da hver prosess et time-kantum. F.eks. så kan en prosess få 20 enheter med tid i form av tics. Så da gir man en prosess 20 tics. Så kan da operativstemme prioritere, altså gi en annen enhet... Nei, gi en annen prosess - 40-tics. Og da betyr det at da vil den som får 40-tics, kjøre i snitt dobbelt så lenge som den andre. Og det skal vi se på senere, hvordan vi kan gjøre med nice-kommandoen i Linux. Etter at alle prosessene har fått tildelt sitt time-kontum, altså sin tids... Én liten bit med tid, så kjører operativstemme Rown-Robin scheduling. Det betyr at... Rown-Robin, det betyr at man sitter rundt et bord, og så får alle litt tid. Men da er det ikke sånn at bare hver prosess får etikk. Man avbryter det ikke hele tiden. Dette er fordi det kan være effektivt og ikke... Ikke ha for mange avbrudd. For det er litt overhead med en context switch, altså å switche over til en annen prosess. Så dette systemet sørger for at da, hvis det ikke skjer noe spesielt, altså hvis det ikke kommer noen interrupter, så vil den prosessen som er tildelt 20-tics, den vil fullføre de 20-ticsene i denne epoken. ... litt fred og ro til å kjøre ferdig. Det blir jo noen sånn 0,2 sekunder... 20 hundredeler, så kjører den. Og så etterpå kommer kanskje den prosessen som har fått ti tics. Så kanskje ikke er flere som har lyst til å kjøre i den epoken.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0010", "start": 1617.24, "end": 1799.36, "token_count": 586, "text": "altså hvis det ikke kommer noen interrupter, så vil den prosessen som er tildelt 20-tics, den vil fullføre de 20-ticsene i denne epoken. ... litt fred og ro til å kjøre ferdig. Det blir jo noen sånn 0,2 sekunder... 20 hundredeler, så kjører den. Og så etterpå kommer kanskje den prosessen som har fått ti tics. Så kanskje ikke er flere som har lyst til å kjøre i den epoken. Og da starter en ny epoke. Og så fortsetter det sånn. Dermed kan operativsteamet avgjøre prioritering av de forskjellige prosessene. Så dette er en måte å dele inn tiden på på en litt mer dynamisk måte enn å bare gi annenhver tics til hver eneste prosess. Den måten ville ha gitt litt mye overhet. Så må vi også huske på at timeticsene er definert av operativsystemet. Man har testet ut i noen skeduer... Eller i 26-kjernen... Kan man sette 1 ms eller 100 ms? Men da oppfører systemet seg litt forskjellig. Etter hvert timertick, så sjekkes det om den prosessen som kjører, har flere tics igjen. Altså om telleren til prosessen er større enn null. Da kaller man ikke skeduleren. Da bare fortsetter den å kjøre til den er ferdig med sin epoke. Altså da typisk med sine 20 tics. Og så er epoken over når alle prosesser har brukt opp sin tid. Og da kommer tida null for alle prosesser. Og da starter man på nytt, og så deler scheduleren ut tics til alle prosesser som ønsker å... Og det er da en variabel som kalles priority, eller prioritet. Og den bestemmer da hvor mye seputid prosessene skal få. Og en prosess kan faktisk senke sin egen prioritet. Den kan be om lavere prioritet. I Linux gjør man det med commando nice. Og da får den prosessen mindre prioritet. Være så fair som bare mulig. Alle som ønsker CPU, tildeles omtrent like mye mange TIX. Og det er dette vi ser som vi så på i forrige uke, da vi kjørte fire og åtte prosesser på samme CPU. Det operativsystemet gjør, er å tildele TIX.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0011", "start": 1764.2, "end": 1943.2, "token_count": 597, "text": "Og en prosess kan faktisk senke sin egen prioritet. Den kan be om lavere prioritet. I Linux gjør man det med commando nice. Og da får den prosessen mindre prioritet. Være så fair som bare mulig. Alle som ønsker CPU, tildeles omtrent like mye mange TIX. Og det er dette vi ser som vi så på i forrige uke, da vi kjørte fire og åtte prosesser på samme CPU. Det operativsystemet gjør, er å tildele TIX. Og den tildeler da i utgangspunktet like mange TIX til hver av prosessene. Time-kontum vil da kunne variere, sånn statistisk. For dette er en dynamisk skedulering. For hver epoke så deles det ut nye tics. Og her er en sånn statistikk på... I Linux-kjerne 2.4 så var gjennomsnittlig time-kontum på 210 millisekunder. Altså så man måler og ser hvor langt det er time-kontum når du kjører en masse prosesser på... Og i 2006 var det omtrent 100 millisekunder. Hva var en epoke igjen? Jo, en epoke, det er liksom... Det er ikke en fast tid, men det er... Ved starten av en epoke, så har operativsystemet, så sjekker den en ready-liste. En liste over alle prosesser som har lyst til å brukes i pund. Det kan jo være noen som ligger i vektstilling eller venter på input og upput eller av en eller annen grunn ikke ønsker å kjøre. Men alle prosesser som ønsker å kjøre, de blir da tildelt et time-kontum. Da kan det være at Prosess A får 30 tics, Prosess B får 20 tics, Prosess C får 10 tics. Og så setter man i gang med å kjøre. Den defineres av det tidsrommet 30 pluss 20 pluss 10. Og hvis ikke noe spesielt skjer, så kjøres de 60 ticsene, og så starter man på nytt igjen. Men da kan det være litt avhengig av om prosessen faktisk har brukt opp sine tics. Så kan operativstyret dynamisk tildele tics etter hvor mange man har brukt. Hvis man ikke bruker noe særlig med tics, så får man flere neste gang, sånn at man får høyere prioritet. Det er en del oppgaver denne uken.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0012", "start": 1899.68, "end": 2068.28, "token_count": 586, "text": "Den defineres av det tidsrommet 30 pluss 20 pluss 10. Og hvis ikke noe spesielt skjer, så kjøres de 60 ticsene, og så starter man på nytt igjen. Men da kan det være litt avhengig av om prosessen faktisk har brukt opp sine tics. Så kan operativstyret dynamisk tildele tics etter hvor mange man har brukt. Hvis man ikke bruker noe særlig med tics, så får man flere neste gang, sånn at man får høyere prioritet. Det er en del oppgaver denne uken. Og så kan man også se på den vaffelrøreskreduleringen. Der bruker jeg akkurat dette her. At vi har en counter for hver prosess. Og så prioriterer de forskjellige. Vaffelprosessen og forelesningsprosessen har litt forskjellig prioritet. Hvis det kommer et time-it-itch, så kan det være den samme prosessen fortsetter litt til. Og det er for å gjøre det mer effektivt. For at det ikke skal gå bort for mye tid til context-switching. Alle operativsystemer har en eller annen form for prioritet på prosesser. Og i 2.6-hjernen så er det 140 forskjellige prioritetsklasser. Og hver sånn klasse tilsvarer et antall tillegg til tics i starten av en epoke. Og det scheduleren gjør, er at når den kommer inn, så velger den prosessen som har høyest prioritet. Og så kjører den til den har brukt opp alle sine tillegg til tics, eller gir fra seg CPU-en. Og deretter kalles scheduleren på nytt. Og det er et viktig poeng, det der med at en eller gir fra seg CPU-en. Fordi... Det gjør at en prosess er veldig høyt prioritert. Og det kan typisk være sånne interaktive prosesser, sånn som en teksteditor. Den bruker veldig lite CPU, men akkurat når det kommer inn tasten F fra brukeren, så er det veldig viktig at den prosessen svarer kjapt. Og en teksteditor bruker vanligvis veldig lite CPU. Så den vil hele tiden få dynamisk høyere prioritet. Den vil komme veldig høyt opp. Men det som skjer da... Hvis en teksteditor får utdelt 120 tics, kommer veldig høyt opp...", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0013", "start": 2026.0, "end": 2183.62, "token_count": 588, "text": "Og det kan typisk være sånne interaktive prosesser, sånn som en teksteditor. Den bruker veldig lite CPU, men akkurat når det kommer inn tasten F fra brukeren, så er det veldig viktig at den prosessen svarer kjapt. Og en teksteditor bruker vanligvis veldig lite CPU. Så den vil hele tiden få dynamisk høyere prioritet. Den vil komme veldig høyt opp. Men det som skjer da... Hvis en teksteditor får utdelt 120 tics, kommer veldig høyt opp... Så med en gang den har prosessert den ene bokstaven sin, så vil den overgis. Den vil stoppe og si at den ikke trenger CPU lenger. Dermed vil den beholde den høye prioriteten. Kanskje få enda et tics som kommer opp i 121. Sånn at neste gang når den kommer inn, så vil den alltid komme inn med en gang. Med en gang det kommer et interrupt, for når brukeren tasser F, så sendes et interrupt. Og da vil scheduleren... Den vil merke det, med et spesielt bit, som vi skal se på neste slide. Men scheduleren vil merke det, og teksteditorprosessen vil hoppe inn. Derimot, en regneprosess, sånn som den dot-regn, som... Den vil da hver gang i epoken bruke opp absolutt alle ticsene sine. Så den kommer kanskje ned til slutt til ti tics. Hver gang er det bare den som kjører. Da er det ti tics i epoken. Og den kjører da om og om igjen. Men den vil da... Hvis du hele tiden bruker opp ticsene, så vil du gå ned i prioritet. Men så lenge det ikke er noen andre som ønsker å kjøre, så er det helt greit å være nede i prioritet. For da får du likevel kjøre hele tiden. Men da vil interaktive prosesser bygges opp en høy prioritet og vil alltid komme raskt inn. Men de bruker likevel ikke mye CPU. Alle typer prosesser, både de som bruker mye CPU og ønsker å bruke mye CPU, og de som er interaktive og ikke bruker mye, de vil da kunne samkjøre innenfor samme system, uten at taxidirektoren vil oppleves som ekstremt treig, bare fordi det er en reinejobb som står og kjører.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0014", "start": 2157.04, "end": 2344.84, "token_count": 599, "text": "Men da vil interaktive prosesser bygges opp en høy prioritet og vil alltid komme raskt inn. Men de bruker likevel ikke mye CPU. Alle typer prosesser, både de som bruker mye CPU og ønsker å bruke mye CPU, og de som er interaktive og ikke bruker mye, de vil da kunne samkjøre innenfor samme system, uten at taxidirektoren vil oppleves som ekstremt treig, bare fordi det er en reinejobb som står og kjører. Og det er denne need reshed. Det står altså trenger reschedulering. Og det skjer hvis det i løpet av epoken kommer inn et interrupt, Det er en sånn 01-bit i CPU-en. Og hvis dette bitet blir satt, så vil scheduleren kjøres etter neste time-tick. Hvis det var en prosess som hadde la oss si 20 tic, så ville bare scheduleren gå inn og kontrollere om det har skjedd noen interrupts. Nei, det har ikke det. Ok, da bare kjører samme prosess videre. Og da kjøres scheduleren på nytt. Og da kan en gå inn og say... Ok, da gir jeg den prosessen som har høyest prioritet, den får nå kjøre. Og typisk er det da interaktive prosesser som har bygd seg opp høy prioritet ved å ikke bruke CPU-en. Du får liksom goodwill. Når jeg kommer inn, så bruker jeg omtrent ikke CPU. Og det er akkurat sånn scheduleren bygger opp systemet. Noe tilsvarende må alle andre schedulere gjøre også. Dette er en veldig viktig mekanisme når du skal kjøre både interaktive prosesser og regneprosesser samtidig på det samme systemet. Hvis vi ikke hadde sånn, så måtte man vente helt til den CPU-intensive prosessen var ferdig med sin del. Og hvis jeg tok flere tidels sekunder, så ville det oppleves som veldig tregt for en interaktiv prosess. Ok. Dette var de viktige prinsippene bak schedulering. For de to viktigste prinsippene var user mode og curl mode, og i tillegg systemkall og trap. Disse begrepene må dere ha greie på. Det er det viktigste når det gjelder operativsystemskedulering. Så tenkte jeg å kunne si litt om denne simuleringen som jeg snakket om. Skal vi se... Her. Skedulering av...", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0015", "start": 2288.4, "end": 2484.2, "token_count": 589, "text": "så ville det oppleves som veldig tregt for en interaktiv prosess. Ok. Dette var de viktige prinsippene bak schedulering. For de to viktigste prinsippene var user mode og curl mode, og i tillegg systemkall og trap. Disse begrepene må dere ha greie på. Det er det viktigste når det gjelder operativsystemskedulering. Så tenkte jeg å kunne si litt om denne simuleringen som jeg snakket om. Skal vi se... Her. Skedulering av... Samtidig forelesning og vaffelrørlaging. Ja, dere kan jo i fred og ro kose dere med denne videoen. Litt popkorn og cola og så videre. Så kan dere se da hvordan et operativsystem virker i praksis. Det jeg har prøvd å gjøre her, er altså å lage et operativsystem som bruker dette med poker fra Linux26-kjernen. Stort sett opererer på samme måte. Og da vil dere se i videoen at jeg har på en bandyhjelm. Eller en sykkelhjelm. Iallfall en hjelm. Og hovedpoenget med den er at den hjelmen, det er modusbyttet. Så dere kan se... Når timeren går av, så tar jeg på meg hjelmen. Og dette skal da skje automatisk. Det er på en måte hardware som vi gjør. En gang jeg sier 'Den piper', så skal hjelmen komme på av seg selv. Det er vanskelig å være operativsystem, så det er ikke alt jeg klarer å få det helt til. Men det er utgangspunktet. Så det er da et ytre interrupt. Og så i tillegg så har vi noen... Ja, dette er da institusjoner, operativsystem... Kanskje dette er kjernen. Så jeg starter opp med å lese ReadyList over prosesser som jeg ønsker skal kjøre. Og så... Og så er det da to prosesser. Du kan hoppe til det. Vaffelprosess og Forelesningsprosess. Og disse to prosessene, det er da to programmer som jeg ønsker å kjøre. Og vaffelprosessen... Det er omtrent sånn som jeg lager vafler. Selv om jeg ikke skriver ned assembly-kode for det. Blander 100 gram sukker og mel og visper. Og så sjekker jeg om det er blandet. Det er da en typisk compare-oppgave.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0016", "start": 2449.36, "end": 2634.68, "token_count": 593, "text": "Og så er det da to prosesser. Du kan hoppe til det. Vaffelprosess og Forelesningsprosess. Og disse to prosessene, det er da to programmer som jeg ønsker å kjøre. Og vaffelprosessen... Det er omtrent sånn som jeg lager vafler. Selv om jeg ikke skriver ned assembly-kode for det. Blander 100 gram sukker og mel og visper. Og så sjekker jeg om det er blandet. Det er da en typisk compare-oppgave. JMPNB - jump not blandet. Da hopper jeg tilbake. Og så fortsetter det sånn. Men så kommer det et viktig poeng i denne sammenheng. Og det er når jeg skal hente melk... Det tilsvarer på en måte at jeg skal... Nå trenger jeg melk til røra, og det ligger på disk. Og da må jeg gjøre et systemkall. For det å hente melk, det må jeg få hjelp av operativsystemkjernen til å gjøre. Og da er jeg et vanlig program som opererer uten hjelm. Og så når jeg da gjør et systemkall... Da kommer hjelmen på, for da må jeg be Operativsteam Kjernen om hjelp. Og så ber kjernen... Den setter i gang den prosessen. Eller da hopper vi tilbake til kjernekode et eller annet sted her. Jo, her er det... Legg melk i buffer. Sett need rechard, osv. Eva, som mange av dere kjenner fra diskrematematikk, som er melkemannen i dette opplegget... Kan du si spoiler alert? At det fungerer ikke helt optimalt? For tanken er at... Dette med å hente melk skal ta veldig lang tid. Men det har jeg ikke formidlet godt nok. Og Eva står på døra med melken med en gang. Da blir det litt forviklinger. Dere får se. Men... Og hovedpoenget er da at... En vanlig brukerprosess må be om hjelp fra operativstemme, og da tar den på en måte frivillig på seg hjelmen og kommer over i køllen mot. Mens så vil det hvert minutt så skjer det et timertick. For jeg har en hardware timer. Hvert minutt så ringer den. Da kommer hjelmen automatisk rett på. Her er en time-off-call. Det er da på en måte... Det er den interrupt-rutinen som man hopper til når det kommer", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0017", "start": 2585.04, "end": 2764.94, "token_count": 588, "text": "Dere får se. Men... Og hovedpoenget er da at... En vanlig brukerprosess må be om hjelp fra operativstemme, og da tar den på en måte frivillig på seg hjelmen og kommer over i køllen mot. Mens så vil det hvert minutt så skjer det et timertick. For jeg har en hardware timer. Hvert minutt så ringer den. Da kommer hjelmen automatisk rett på. Her er en time-off-call. Det er da på en måte... Det er den interrupt-rutinen som man hopper til når det kommer en time-off-call. Da sjekkes det om kontra null. Summen av alle er null. Det startes en ny epoke. Hvis ikke, så... Hvis den ene contoen er null, så flyttes den fra readylist. Så gjør man et kall til scheduler. Så kommer scheduleren inn, og da velger den en av de to prosessene som skal kjøre. Men hvis det ikke har skjedd noe spesielt, så er det bare den prosessen som står og kjører. Som fortsetter, sånn at man unngår kontekst-switch. Hvis ikke, så må man sette i gang et kontekst-switch. Og da må jeg liksom... Enten så switcher man da til vaffellaging. Eller så switcher man til forelesningsprosessen. Og forelesningsprosessen, det er... Det er denne prosessen her, hvor jeg har dagens faktum og snakker om Linux. Og utviklingen av Linux, og Linus Thorvalds bor på en hybel i Helsinki, osv.... Det er da altså operasjoner som... Jeg som hardware ønsker å få utført disse to prosessene her samtidig. Og så ønsker jeg at de ikke skal ødelegge for hverandre. Og da har jeg da den tredje prosessen, som er operativ stemkjernen, som sørger for at disse to samkjører på en riktig måte. Og det er sånn jeg gjør det. Den ligger ganske så tett opp til Linux 26-kjernen med poker. Relativt realistisk simulering. Så... Men den ligger som sagt her. Ja, dere har også å se på OSEGG. Det er liksom høydepunktet. Her vil dere se hvorfor det er viktig å ha på seg hjelm når man skal knuse egg. For å knuse egg er opplagt noe som du må gjøre med et systemkall.", "source": "lecture"}
{"lecture_id": "os8time2", "chunk_id": "os8time2_0018", "start": 2724.9, "end": 2925.82, "token_count": 346, "text": "som sørger for at disse to samkjører på en riktig måte. Og det er sånn jeg gjør det. Den ligger ganske så tett opp til Linux 26-kjernen med poker. Relativt realistisk simulering. Så... Men den ligger som sagt her. Ja, dere har også å se på OSEGG. Det er liksom høydepunktet. Her vil dere se hvorfor det er viktig å ha på seg hjelm når man skal knuse egg. For å knuse egg er opplagt noe som du må gjøre med et systemkall. Det kan ikke en vanlig brukerprosess gjøre. Så jeg håper dere får... Det skal jeg også ha litt fornøyelse av å se på dette her. Men samtidig så er det veldig seriøst. Det er akkurat sånn... Eller det er veldig tett opptil hvordan operativsystemet utfører sin kjernevirksomhet. Bruke hjelm når man klekker egg? Nei, når man knuser egg. Det er da man må bruke hjelm. Ok. Da tenker jeg vi tar en pause der, så er det lab etterpå. Det er vanskelig å forstå hvordan det er å være gravid. Hvordan var det å jobbe på sykehuset i Storbritannia? Hvordan var det å jobbe på sykehuset i Storbritannia? ... og det er veldig vanskelig å forstå hvordan det er å leve i en slik situasjon.", "source": "lecture"}
