{"lecture_id": "os1b", "chunk_id": "os1b_0000", "start": 0.02, "end": 203.82, "token_count": 595, "text": "Det vi avslutter med, var å vise at operativsystemet forenkler. Hardware er fryktelig komplekst. Så én viktig hovedoppgave for operativsystemet er å forenkle grensesnittet fra brukerprogrammer mot Hardware. Men det er en annen oppgave også som er veldig viktig, og det er å... Mellom de forskjellige programmene og mellom de forskjellige brukerne. Det er en annen viktig hovedside. Her er et forsøk på en OUS-definisjon. Det er at et operativsystem er programvarer hvis hensikt er to ting. A. Gi applikasjonsprogrammer og brukere enhetlige, enklere og mer abstrakt adgang til maskinens ressurser. Så det er det vi så på med forrige med beautiful and ugly interface. De som skriver et applikasjonsprogram, skal ikke behøve å ta hensyn til detaljene ned i Hardware. Det fikser operativ systemet. Så det er én viktig del. Men så er det altså del B. Administrere ressurser, slik at prosesser og brukere ikke ødelegger for hverandre. Hvis en prosess gjør en eller annen jobb og får noe inn i minnet som den skal ta vare på og bruke senere, kan ikke en annen prosess komme inn og skrive over eller ødelegge noe av det den har. Den andre brukeren bruker. En prosess tar over all CPU på maskinen. Det vil også gå dårlig hvis ikke operativstemmen sørger for å fordele CPU-tip. Eller som det står i eksemplene her, et filsystem. Som brukes til å gi alle brukere og prosesser atskilt adgang til å lagre på disken. Da må opplagt ikke de kunne overskrive for hverandre. Prinsippskisse av Linux. Tidligere hadde vi et enkelt grensesnitt, og vi hadde operativsystemkjerne og hardware. Men dette er på en måte en litt mer detaljert skisse, med Linux som eksempel. Skal si at det er litt forskjellig fra Windows. I begge tilfeller så har vi en operativsystemkjerne. Og det er... Når jeg sier OS, så tenker jeg ofte på OS-kjernen. Men det er ikke noen sånn helt klare definisjoner der. Hva som hører til OS-kjernen, og hva som ikke hører til OS-kjernen.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0001", "start": 166.32, "end": 353.26, "token_count": 600, "text": "Men dette er på en måte en litt mer detaljert skisse, med Linux som eksempel. Skal si at det er litt forskjellig fra Windows. I begge tilfeller så har vi en operativsystemkjerne. Og det er... Når jeg sier OS, så tenker jeg ofte på OS-kjernen. Men det er ikke noen sånn helt klare definisjoner der. Hva som hører til OS-kjernen, og hva som ikke hører til OS-kjernen. Grovt sett så kan vi si at operativsystemkjernen er den som kjører i corner mode. Men så kan en da ha systembiblioteker og systemprogrammer som kjører på toppen. Og det er det vi ser litt her. Hvis vi starter nederst, så ser vi at vi har hardware her nede. AMD X86 osv. Hardware kan være veldig forskjellig, men operativsystemkjernen styrer da denne hardwaren. Men så ser vi... Her har vi et systemkaldt grensesnitt. Dette er virkelig da et API... Application Programming Interface. Dere er kanskje kjent med API-er fra forskjellige softwareløsninger. Men da er det typisk at du har inn mot en klasse eller en softwarepakke, så har du et gitt antall kall som du kan gjøre. Et helt klart definert grensesnitt. Og nøyaktig det samme er det når det gjelder operativstyrer. Da har man et systemkall-grensesnitt. Så det er bare et begrenset antall systemkall som vanlige programmer kan gjøre for å snakke med operativsystemkjernen. Basert på de systemkallene, og eksempel open-close, dette er om filer, eller ri, det er et annet systemkall, da kan en applikasjon her oppe be systemet om at det leser. En fil fra disken. Da vil ikke applikasjonen styre disken direkte. Den kan bare gjøre systemkall til operativstemkjernen. Dette er helt essensielt når det gjelder operativstemmer. At vi har dette grensesnittet. Men så ser vi også at vi har sånne... Her er et bibliotek, et systembibliotek. Det kan være math.ho. En nettverksoppkobling fra denne applikasjonen til en annen et annet sted. Det er typisk systembiblioteker. I noen tilfeller kan man si at det er en del av operativsystemet, men det er ikke en del av kjernen.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0002", "start": 313.48, "end": 504.8, "token_count": 588, "text": "Dette er helt essensielt når det gjelder operativstemmer. At vi har dette grensesnittet. Men så ser vi også at vi har sånne... Her er et bibliotek, et systembibliotek. Det kan være math.ho. En nettverksoppkobling fra denne applikasjonen til en annen et annet sted. Det er typisk systembiblioteker. I noen tilfeller kan man si at det er en del av operativsystemet, men det er ikke en del av kjernen. Forskjellen er hvis det er et systembibliotek. Hvis det snakker gjennom systemkall til Da er det ikke en del av kjernen. Da er det mer en system, software, som sitter på toppen. Men som mange vil betrakte som en del av operativsystemet. Det er derfor det står... Det er en 19 stiplet linje her. Her står det GNU slash Linux. Og GNU... Det er en liten stiplet linje her. Jeg ser... jeg ser... har ikke skrevet hva Gnu er, men Gnu, det er en sånn rekkurs i forkortelse. Gnus, not Unix. Vanligvis når man opptaler Linux, så sier man bare Linux. Men det egentlig riktige navnet for Linux er GnuLinux. Gnu, det er resten av systemet. Linux er egentlig bare Linux-kjernen. Men hvis du skal styre en maskin, eller ikke minst styre applikasjoner, så trenger du mer enn akkurat kjernen. Så Gnu er alle disse verktøyene sånn som det står her. Compulator f.eks., GCC, som er det aller viktigste. Alle disse verktøyene er da bygd opp på toppen av Linux. Og når du i dagligtallet snakker om et operativsystem, så tenker man ofte på at så tar man også med den biten. Hvis du f.eks. snakker om et vindusoperativsystem, så har du absolutt også med alle disse verktøyene. Også vindusgrensesnittet. Og der er det en stor forskjell. I vindus så er det Gui. Vindusgrensesnittet, grafiske brukerinterface, det er en del av vinduskjernen. Mens vi ser her på Linux, så er all grafikk... Det er brukerprogramvare som sitter på toppen av operativstømkjernen og bare snakker med kjernen gjennom grensesnitt.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0003", "start": 462.68, "end": 657.14, "token_count": 587, "text": "så har du absolutt også med alle disse verktøyene. Også vindusgrensesnittet. Og der er det en stor forskjell. I vindus så er det Gui. Vindusgrensesnittet, grafiske brukerinterface, det er en del av vinduskjernen. Mens vi ser her på Linux, så er all grafikk... Det er brukerprogramvare som sitter på toppen av operativstømkjernen og bare snakker med kjernen gjennom grensesnitt. Vi kommer tilbake til disse tingene, men dette er... Én vesentlig forskjell på Windows og Linux. Men hovedideen som dere må huske å sitte tilbake igjen med i dag, det er operativsystemet kjernen. Det er det helt essensielle av operativsystemet. Det kjører i curl-mode. Det har lov til å gjøre absolutt alt av endringer. Da kan det også gjøre feil og ødelegge systemet, få det til å gå ned osv. Mens resten av apparativsystemet, det snakker med kjernen gjennom et API. Gjennom systemkall. Og da er det opplagt mye sikrere. Det er ikke så lett for en applikasjon her oppe da å få hele systemet til å gå ned. For det får rett og slett ikke lov til å gjøre alt det vil. Da skal vi bruke litt tid på å snakke om et veldig sentralt begrep, nemlig... Hvis man leser diverse operativstemmebøker, som jeg har gjort, så finner man også diverse definisjoner på prosess. Det enkleste er bare at en prosess er et program som kjører. En annen er arbeidsoppgavene en prosessor gjør på et program. Litt mer spesifikt, men fortsatt relativt enkelt. Det som er litt mer å oppfatte, er at en prosess er delt inn i tre deler. For det første er det et kjørbart program. Men så er det også programmets data, variable filer osv. Men også den konteksten programmet er i. Den tilstanden. For eksempel om... Oi, unnskyld. Om den venter på noe, eller om... Eller om den bruker CPU-en, eller... Hva er det problemet med lynet? Hva slags prioritet den har, hvilke prosessorregistre den bruker, osv. Det er liksom selve tilstanden til prosessoren.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0004", "start": 607.42, "end": 861.74, "token_count": 592, "text": "For det første er det et kjørbart program. Men så er det også programmets data, variable filer osv. Men også den konteksten programmet er i. Den tilstanden. For eksempel om... Oi, unnskyld. Om den venter på noe, eller om... Eller om den bruker CPU-en, eller... Hva er det problemet med lynet? Hva slags prioritet den har, hvilke prosessorregistre den bruker, osv. Det er liksom selve tilstanden til prosessoren. Eller høytsvevende definisjon, nemlig et programs ånd eller sjel. Og dette er... Når jeg så den definisjonen, så prøvde jeg å trekke dette litt lenger. Så det jeg har prøvd å gjøre, er å lage en analogi til hva en prosess er. Og da skal vi se... Da skal jeg dele et annet vindu med dere. Og så skal vi prøve å se på den analogien. Skal vi se hvis jeg klarer å finne igjen det vinduet. Der, ja. Sånn. Her... Her ser vi... Forhåpentlig ser dere også dette her. Program eller kode. Hvis jeg sier at... Jo... Vi har sagt at en prosess er et program som kjører. Men hva med... Hva om programmet eller koden som vi kjører, er DNA? Altså godt å si et menneskes DNA. Hva er da prosessen? Jeg ser Marius har et spørsmål. Jeg kan ta det etterpå. Men kom gjerne med forslag i chatten. Vanligvis har vi altså vanlige programmer som kjører. Det er koden. Og så har vi da prosesser som kjører på en datamaskin. Men hva kan da en prosess være, hvis det er DNA som er koden? Forslag - enzymer, proteiner? Ja, det er godt forslag. Det er ikke nødvendigvis min analogi er helt perfekt, men det tenker jeg kanskje er litt... Det som er problemet med DNA, er at den både er hardware og prosessen i seg selv. Fordi du på en måte... DNA er kode som bestemmer hvordan alt blir. Menneske... Ja... Det kom masse forslag her. Veldig bra. Men det er med programmet. Og mennesket, da tenker jeg mer at det er kanskje... Er litt mer sånn hardware. Blod som pumpes rundt i kroppen. Ja, absolutt. Nervesignaler.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0005", "start": 801.48, "end": 1064.84, "token_count": 586, "text": "Det er ikke nødvendigvis min analogi er helt perfekt, men det tenker jeg kanskje er litt... Det som er problemet med DNA, er at den både er hardware og prosessen i seg selv. Fordi du på en måte... DNA er kode som bestemmer hvordan alt blir. Menneske... Ja... Det kom masse forslag her. Veldig bra. Men det er med programmet. Og mennesket, da tenker jeg mer at det er kanskje... Er litt mer sånn hardware. Blod som pumpes rundt i kroppen. Ja, absolutt. Nervesignaler. Bevisstheten. Ja, det begynner å nærme dere. Men det er faktisk... Noe helt spesifikt som jeg er ute etter. Men vi har jo sånn som hardware, da. Lurer på hva det er også. Og da tror jeg kanskje kan være med på mennesker, sjel og ånd. Question does not compute. Men hvis jeg prøver å stille spørsmål på en litt annen måte, da. Hvordan... Hvis du ser på deg selv... Eller se på meg, da. Jeg har et DNA. Og det er jo egentlig bare en kjempelang streng med kode. Så den prosessen at mitt DNA kjører... Det DNA-et kjøres. Hva kan det kalles? Eller for din del, at ditt DNA kjøres. Det var masse forslag her. Noen som har flere ideer? Hvordan... Hvordan er det relatert til deg? Ja, gener - igjen gener. Det er selve DNA. Så... hjerte, ja, da er du inne på noe. For det er liksom det at... at det utføres. Men hva er selve prosessen? At man lever, ja. Det... Veldig bra. Der Mohammed kom med at man lever. Så det jeg vil si, er at selve prosessen for DNA-et er livet. Altså det som et menneske... Helt fra... Helt fra man blir født til man dør. Med prosesser også. Man har jo... Man har jo sånt som kill eller kontroll C. Det vil jo være drap eller død, ikke sant? Jeg ser chatten her om dette er fag i filosofi. Ja, absolutt. Prosesser skal vi snakke om hele tiden. Og det er veldig viktig at dette er mye mer enn bare et program som kjører. Og det er tanken med denne analogien, at hver gang dere hører ordet prosess,", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0006", "start": 1020.0, "end": 1268.46, "token_count": 588, "text": "Med prosesser også. Man har jo... Man har jo sånt som kill eller kontroll C. Det vil jo være drap eller død, ikke sant? Jeg ser chatten her om dette er fag i filosofi. Ja, absolutt. Prosesser skal vi snakke om hele tiden. Og det er veldig viktig at dette er mye mer enn bare et program som kjører. Og det er tanken med denne analogien, at hver gang dere hører ordet prosess, så skal dere da ikke bare tenke på det programmet som kjører, men dere skal tenke på at dette er hele livet for akkurat den koden som kjører. Hva kan hardware være da? Der igjen blir det litt vanskelige organer. Det var bra, var den som foreslo. Men jeg tenker at Hardware også er sånn noe mer enn bare mennesket selv, ikke sant? For det kan jo ha sånn som hus, mat, bygninger osv. Fordi at DNA på en måte opererer... DNA opererer over hele verden. Så...  Control-C er close... Det er jo copy-vinduet sitt. Det er faktisk sant. Men hvis du kjører en Linux-prosess og du skal stoppe den, så hvis du tasser control-C, så blir den drept. Men vi har et par andre viktige ting her. Hva med... Eller for å sette det motsatt... Hva kan man si at staten eller lovverket... Hva er det i denne analogen? Analogien. App i OS, ja. Andreas, supert. OS, operativsystemet, det er liksom staten eller lovverket, som da sørger for at prosesser ikke ødelegger for hverandre. For da er det sånn at hvis en av dere går inn i nabohybelen til en annen student, så kan ikke vi bare gå inn der og ta hva som helst. Og akkurat det er det operativsystemet sørger for. Det sørger for at de prosessene som kjører her på jorda, ikke her på jorda... Operativsystemet sørger for at prosessene i en datamaskin ikke ødelegger for hverandre. Og de kontrollerer at de deler på godene sånn som de skal. Og det samme kan man da si om operativsystemet. Det er en slags sånn overordnet sjef. Et politi kunne også kanskje vært. Som overholder lovverket. Politi. Som passer av prosessene, ikke ødelegger for andre.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0007", "start": 1223.12, "end": 1420.24, "token_count": 589, "text": "Det sørger for at de prosessene som kjører her på jorda, ikke her på jorda... Operativsystemet sørger for at prosessene i en datamaskin ikke ødelegger for hverandre. Og de kontrollerer at de deler på godene sånn som de skal. Og det samme kan man da si om operativsystemet. Det er en slags sånn overordnet sjef. Et politi kunne også kanskje vært. Som overholder lovverket. Politi. Som passer av prosessene, ikke ødelegger for andre. Så kan man også spørre seg om hva med Rut eller administrator? Hvem er dette i den analogien? Brian kommer en gang til med... veldig bra. Sjelden noen sier det så fort. Men det er Gud. Administrator har all makt. Og det er en del. Regjeringen Kongen, ja, det er også litt det samme. Men Gud er kanskje enda bedre. Dere har sikkert opplevd en del Ruth-eller-administratorer som føler seg som Gud. Men i denne analogien så er de det. For de er også en prosess. Det ble en litt omfattende diskusjon når vi skal diskutere om Gud også har DNA osv. Men det er på en måte en prosess som styrer de andre prosessene. Og en Gud kan jo da bare si OK, denne prosessen her, den gjør så mye galt. Så Rutel-administrator er på en måte en sånn... Er allmektig på toppen og styrer alle prosessene. OK. Jeg vet ikke om denne analogien er helt perfekt. Men det som er viktig med den, er at fra nå av, når dere tenker på en prosess, så må dere ta med alle de bitene som... Denne analogien viser at en prosess omfatter, da. For eksempel så skal vi senere se på hva som... At vi kan... Eller at operativsystemet... For å dele på godene, så driver operativsystemet hele tiden og stopper prosesser. Og hvis du stopper en prosess, så er det... Det er på en måte et drap, men det er mer sånn at du... Setter hele prosessen på hvile. Men da er det ikke bare å si at nå skal ikke du kjøre mer. Da må du også ta vare på alt det den prosessen hadde. Alle oppkoblinger, alt som ligger i registeret, internminnet. Alt det må lagres.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0008", "start": 1383.76, "end": 1566.14, "token_count": 578, "text": "Eller at operativsystemet... For å dele på godene, så driver operativsystemet hele tiden og stopper prosesser. Og hvis du stopper en prosess, så er det... Det er på en måte et drap, men det er mer sånn at du... Setter hele prosessen på hvile. Men da er det ikke bare å si at nå skal ikke du kjøre mer. Da må du også ta vare på alt det den prosessen hadde. Alle oppkoblinger, alt som ligger i registeret, internminnet. Alt det må lagres. Og på en måte fryses. Og det er mer sånn som... Hvor mennesker fryses ned og tines opp 100 år senere. Det er akkurat det operativsystemet gjør hele tiden. Det fryses ned en prosess i ett hundredels sekund. Men da må alt om prosessen også lagres, nøyaktig som når man skal vekke opp et menneske igjen. Naturlover går under ruteadministrator. Ja, det... Jo, du kan nok si det, men kanskje... Jo, men naturlover er vel litt mer sånn som hvordan hardware virker. Altså... For når du har program som skal kjøre på en datamaskin, så er det på en måte gitt av naturlover hvis du gjør den institusjonen. Det skjer det og det. Så det er kanskje litt mer sånn. Men... Ja, det er som sagt, det er ikke alt som klaffer 100 % med denne analogien. Men det som er viktig, er at dere har med det som... Odeta oppsummerer veldig fint at prosessen er livsløpet av programmet. Og absolutt, det er det. For hvis du har et program... Så har det en funksjon som det skal gjøre. La oss si det er et enkelt program som skal regne ut en sum fra 1 til 100. Og da er hele livsløpet til programmet at det starter, og så kjører det nøyaktig sånn som DNA-et tilsier, nemlig at det skal legge sammen alle disse tallene. Det bruker da hardware, det bruker da alle ressursene. Og så gjennom livsløpet til prosessen. Og så utføres nøyaktig det det skal, som beskrevet i DNA-et, eller i koden. Så kommer det fram til et resultat, og så gir det videre til noen andre. Absolutt. Prosessen er hele livsløpet til et program.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0009", "start": 1527.02, "end": 1743.54, "token_count": 589, "text": "Og da er hele livsløpet til programmet at det starter, og så kjører det nøyaktig sånn som DNA-et tilsier, nemlig at det skal legge sammen alle disse tallene. Det bruker da hardware, det bruker da alle ressursene. Og så gjennom livsløpet til prosessen. Og så utføres nøyaktig det det skal, som beskrevet i DNA-et, eller i koden. Så kommer det fram til et resultat, og så gir det videre til noen andre. Absolutt. Prosessen er hele livsløpet til et program. Men hva med CPU? Spør Floyd her. Jo, det blir mer sånn. CPU er da en del av hardware-et som... Men i denne analogien er det kanskje litt mer sånn at hjernen er CPU-en? Det blir litt komplisert, for DNA er også oppskriften på hjernen. Men så vil kanskje si mer at hjernen er CPU. Vi kan ta med det også. Men... ja. Nå begynner analogien å bli litt vanskelig. Så den er ikke perfekt, men prøv å huske å ta med dette videre. OK. Da skal jeg... Da stopper vi den analogien. Men husk dette videre. Når vi senere snakker om prosesser. OK. Da skal vi se... Da må jeg dele riktig screen... Sånn. Da ser dere forhåpentligvis eksempler på prosesser. Det er riktig. Ja, flott. Her ser vi utskrift fra topp i Linux. Og det viser da alle de prosessene som står her og kjører. Og hvor lenge de har levd, eller det jeg vil si da, hvor lenge de har kjørt, mye tid de har brukt, mye CPU de bruker osv. Det ser veldig likt ut på Windows. Akkurat det samme med ID-er osv. Så dette er sånt som vi skal se på senere i detalj. Et annet prinsipp som er viktig når det gjelder operativsystemer, er abstraksjon og hierarkier. Det er nemlig det at man har bokser på høynivå. Der har man oversikten. Dette kan være hele operativsystemet, kanskje. Så tar man ut en del av operativsystemet som kanskje har med scheduler. Så går man enda lenger ned og ser på detaljene inni her. Dette er ekstremt viktig. Det vet dere fra objektorientert programmering.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0010", "start": 1699.58, "end": 1921.2, "token_count": 593, "text": "Et annet prinsipp som er viktig når det gjelder operativsystemer, er abstraksjon og hierarkier. Det er nemlig det at man har bokser på høynivå. Der har man oversikten. Dette kan være hele operativsystemet, kanskje. Så tar man ut en del av operativsystemet som kanskje har med scheduler. Så går man enda lenger ned og ser på detaljene inni her. Dette er ekstremt viktig. Det vet dere fra objektorientert programmering. Man lager moduler som gjør akkurat det man skal. Og så bygger man opp hierarkier av denne type systemer. Ikke mens hardware, som vi skal begynne å se på nå, så er det veldig bygd opp. Om man sier OK, dette er en liten boks som gjør sånn og sånn, så bygger vi et stort hele av masse små bokser. Et Linux-eksempel på hierarki, det er hvis man gjør en kommando sånn som dette. Det er en kommando som bare skriver ut litt tekst som ligger i den filen på skjermen. For å få til det, så gjøres det da en rekke systemcall. Og dette er da systemcall som er API-et til Linux-kjernen. For eksempel så gjør man open, read, close og en mengde andre systemcall. Med kommandoen strace, strace, så hvis man utfører den...  Så får man se alle de systemkallene som gjøres. Her er det listet opp. Kjør en kommando. Read filen. Vi ser det er en rekke systemkall som under huden på... Da har vi en applikasjonsprogram. De snakker med operativsystemet gjennom systemcall når de skal gjøre noe spesifikt med hardware. OK. Da har vi en timinutterstide igjen, så skal vi ta en kort introduksjon til datamaskinarkitektur. Det er det vi skal jobbe med de neste ukene. Da har vi så vidt sett litt på hva operativsystemer og prosesser osv. er. For å kunne forstå det helt i detalj, hvordan operativsystemet virker, så trenger man også å forstå hardware. Man får forstå hvordan CPU og ram fungerer, for å forstå hvordan operativsystemet, Og hardware, det bygger i bunn og grunn på digitalteknikk. Alt i en datamaskin er representert ved nuller og enere.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0011", "start": 1873.26, "end": 2073.18, "token_count": 587, "text": "Det er det vi skal jobbe med de neste ukene. Da har vi så vidt sett litt på hva operativsystemer og prosesser osv. er. For å kunne forstå det helt i detalj, hvordan operativsystemet virker, så trenger man også å forstå hardware. Man får forstå hvordan CPU og ram fungerer, for å forstå hvordan operativsystemet, Og hardware, det bygger i bunn og grunn på digitalteknikk. Alt i en datamaskin er representert ved nuller og enere. Og det er ganske enkelt representert sånn at null, det er ingen spenning. Og en ener er f.eks. fem volts spenning i forhold til jord. Og dermed, med en gang man har nuller og enere, så kan man representere tall med nuller og enere, binære tall. F.eks. så kan du da sette 32-bitt ved siden av hverandre med nuller og enere. Da får man et heltall, en integer, og da kan man representere tall opp til 32. Eller omtrent 4 milliarder. I en datamaskin så er alt tall. Og utgangspunktet er da nuller og enere. Dette er typisk sånn som man har i en standard CPU. At du har null er representert med ingen spenning. Fem volt betyr da her er det spenning. Og det er null. Ja, dere vet sikkert at... eller man sier at alle datamaskiner er drevet binært. Det er riktig, men det er ikke opplagt at man skulle bruke det binære tallsystemet. Det var en del forskjell på å bruke desimale tall. Det kunne man oppnå ved å si at null er null volt. Én volt. Og så representere alt med desimaltall. Men det viser seg at det blir veldig komplisert i praksis å få til. Sånn at etter hvert så har alle datamaskiner benyttet det binære tallsystemet, fordi det er veldig enkelt å skille mellom null og én. Men ut fra binære tall, så kan man representere alt. Sånn som her. 0101 er fem. En ener pluss en firer, det blir en femmer. Så kan man representere bokstaver. F.eks. bokstaven P er bokstaven nummer 80. Da har du bokstaver. Så kan man representere piksler i grafikk.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0012", "start": 2034.26, "end": 2210.02, "token_count": 573, "text": "Sånn at etter hvert så har alle datamaskiner benyttet det binære tallsystemet, fordi det er veldig enkelt å skille mellom null og én. Men ut fra binære tall, så kan man representere alt. Sånn som her. 0101 er fem. En ener pluss en firer, det blir en femmer. Så kan man representere bokstaver. F.eks. bokstaven P er bokstaven nummer 80. Da har du bokstaver. Så kan man representere piksler i grafikk. Og fargen til piksler. Dermed har du alt som er en datamaskin. Og alt kan da representeres ved nulleregnere. Datamaskinarkitektur går da ut på å manipulere på disse nullene og enerne, sånn at man får gjort nøyaktig det man ønsker å gjøre. Så alt er tall. Og her ser vi da konkret hvordan et binært tall kan se ut. Og her ser vi sånne ledninger. Og det er ikke tull, det er virkelig ledninger. Du måler spenningsforskjeller i forhold til jord. Hvis det er null her, så betyr det at det er faktisk en null. Og fem volt her, det betyr en ener. Og sånn får vi tallet ti. Det er ener her. To en-toer. Ingen firere og en åtter. Og det blir til sammen tallet ti. Datamaskin trenger man ikke bare å representere tall, man må kunne lagre f.eks. 32-bit. Men man må kunne utføre alle mulige logiske og matematiske operasjoner på samlinger av bit. Som f.eks. addere, subtrahere, multiplisere, dividere, sammenligne, skifte operasjoner og en rekke andre operasjoner. Men disse er faktisk de viktigste. Og de fleste programmer kan man utføre bare ved å... Dette er maskininstruksjoner som vi skal se på i stor detalj. Men hvordan kan man lage én sånn enkel operasjon? Hvordan kan man få til det? Hvordan kan man få til å lage logiske operasjoner rent fysisk? Jo, det kan gjøres med logiske kretser. Bygge de logiske kretsene sånn teoretisk. Tenke seg hvordan bør dette se ut.", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0013", "start": 2167.72, "end": 2367.76, "token_count": 579, "text": "Og de fleste programmer kan man utføre bare ved å... Dette er maskininstruksjoner som vi skal se på i stor detalj. Men hvordan kan man lage én sånn enkel operasjon? Hvordan kan man få til det? Hvordan kan man få til å lage logiske operasjoner rent fysisk? Jo, det kan gjøres med logiske kretser. Bygge de logiske kretsene sånn teoretisk. Tenke seg hvordan bør dette se ut. Og etterpå så kan man da bygge de logiske kretsene fysiske som integrerte kretser. Som fysiske integrerte kretser. Logiske kretser, det er kretser som da utfører binær logikk eller binær algebra. kan utføres med såkalte and or not-operasjoner. Så da kan man... Alt man ønsker å få til, kan man få til ved disse operasjonene. Og da gjør man ganske enkelt sånn at man bygger disse tre logiske operatorene i hardware, og dermed så kan man få til hva man vil. Av både addisjon og divisjon og... Alle operasjoner det er mulig å få til. Hvis man setter sammen de riktige logiske operasjonene and or not. På en helt spesiell måte. Man må finne ut nøyaktig hvordan man skal sette det sammen. De fysiske implementasjonene av and or not, av disse operasjonene, det kalles porter. Som er logikken i det. Så må vi se litt på den fysiske utførelsen av de. For i de aller første datamaskinene så brukte man radiorør. Som man brukte for å implementere and-or-not-porter. Men de radiooverrørene har en fysisk størrelse som er... De er store. Så dermed bitte små... Det som i dag er bitte små... Små datamaskiner. Fylte da opp store saler. Det trengte enormt mye plass. Men... Det var en veldig stor oppdagelse i forrige århundre. Kvantemekanikken. Nemlig hvordan verden virker helt nede på mikronivå. På atomnivå. Og denne teknologien, det gjorde... Da ble det mulig å lage transistoren, som var helt grunnleggende for datamaskinen. Det som var fantastisk med transistoren, var at man kunne lage and or not-porter", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0014", "start": 2328.28, "end": 2509.8, "token_count": 600, "text": "Det trengte enormt mye plass. Men... Det var en veldig stor oppdagelse i forrige århundre. Kvantemekanikken. Nemlig hvordan verden virker helt nede på mikronivå. På atomnivå. Og denne teknologien, det gjorde... Da ble det mulig å lage transistoren, som var helt grunnleggende for datamaskinen. Det som var fantastisk med transistoren, var at man kunne lage and or not-porter som var ekstremt små. Sånn at man kan få i dag mange milliarder av dem på en kvadratcentimeter. Det er hele grunnlaget for datamaskinen. Og de er så små at ledningene er sånn... Et hårstrå er 100 000 nanometer. Du kan tenke deg hvor ekstremt små de er. Det man da bruker disse transitionordene til, det er å lage en liten logisk port, sånn som dette her. Dette er AND-porten. Den fungerer sånn at... Du har input A og B, nuller og enere. Så her kommer A inn som en... La oss si det kommer en null inn her, og B er en null. Og da kommer A prikk B, eller A and B, som de av dere som har diskré matematikk. Dere er kanskje vant til det. Men hvis det kommer to nuller inn, så kommer det en null ut. Og tilsvarende, hvis det kommer null og én eller én og null inn, så kommer det også en null ut. Og det er bare i tilfelle 1-1 kommer inn, så kommer det en ener ut. Dette er da en byggescene, en port. Det tar veldig kjapt. De andre er år, som har en litt annen virkemåte. Og not, som er rett og slett sånn at hvis det kommer en null inn, så kommer det en ener ut. Hvis det kommer en ener inn, så kommer det null ut. Hvis du kobler på en spenning null her, så vil det komme en spenning én ut i den andre enden. Det som er helt fantastisk, er at bare ved hjelp av de tre portene, så kan man lage en vilkårlig logikk. Og få til alle mulige logiske kretser. Sånn som dette her er eksempel på. Her setter vi sammen en and og en overport. Og så får vi ut et resultat. Og det som vi skal se på i neste uke, er hvordan man generelt kan lage", "source": "lecture"}
{"lecture_id": "os1b", "chunk_id": "os1b_0015", "start": 2469.3, "end": 2585.98, "token_count": 413, "text": "Hvis det kommer en ener inn, så kommer det null ut. Hvis du kobler på en spenning null her, så vil det komme en spenning én ut i den andre enden. Det som er helt fantastisk, er at bare ved hjelp av de tre portene, så kan man lage en vilkårlig logikk. Og få til alle mulige logiske kretser. Sånn som dette her er eksempel på. Her setter vi sammen en and og en overport. Og så får vi ut et resultat. Og det som vi skal se på i neste uke, er hvordan man generelt kan lage en stor, kompleks sak av sånne and over-porter. Og så kan man f.eks. få til det at man starter med to binære tall. Kanskje 32 bits binære tall, til og med. Og så setter man sammen en masse and over-porter på en sånn måte at... I andre enden kommer det som kommer ut da, er summen av de to tallene. Og det er veldig langt fra opplagt hvordan man kan sette sammen de, men ved hjelp av binær logikk, så kan man få til å sette sammen en smørja masse and or and not-porter på en sånn måte at hvis man sender to binære tall inn i denne svære boksen med and or and not-porter, så kommer det alltid ut summen i den andre enden. Og sånn er generelt en datamaskin bygget opp. Og vi skal faktisk i ganske stor detalj bygge opp en virtuell sånn maskin. Eller jeg skal vise dere en sånn bygning som dere skal teste ut. Og så skal vi kjøre programmer på den maskinen for å se helt nøyaktig hvordan den ser ut.", "source": "lecture"}
