{"lecture_id": "os3bdel9", "chunk_id": "os3bdel9_0000", "start": 0.0, "end": 192.44, "token_count": 600, "text": "Ja. For å utføre en sånn... For å utføre en sånn oppgave som å kjøre den summen, så hvis man skal skrive maskinkode, så må man lage... Så er det enkleste før man skriver maskinkoden, å bruke et slags... et språk som ligger tett opp mot maskinkoden. Det jeg har skrevet opp her, er assemble-kode som utfører den forløkken som vi så på her. Den utfører denne forløkken. Når man skriver maskinkode eller assemble-kode, så må man tenke litt annerledes enn når man skriver høynivåkode. Men det viktigste man alltid må ha, det er en... Enten en løkke eller en if-test. Og for å utføre en løkke eller en if-test, så må man hoppe i koden. Vi kan se veldig raskt på hvordan denne maskinkoden her utføres. Så det vi gjør først i de fire første institusjonene, er bare å legge verdier i r0rnr2r3. r0rnr2r3, det er da registeret. Så første institusjon... Legg tallet 3 i R0, og så legg tallet 1 i R1. Null i auto og null i R3. Og så utfører jeg en addisjon, I pluss pluss. Jeg bestemmer meg da bare for at variabelen I lagres i auto. Men det er noe jeg bestemmer når jeg skal skrive dette programmet. Tar verdien i auto og legger den til r1. Tallet r1 vil alltid være 1, så dette vil alltid bli en i pluss pluss. Altså at man øker auto med. Så utfører jeg summen. Jeg bare definerer da i hodet mitt at jeg velger da r3. Det vil jeg ha. Der vil jeg lagre s. Det er derfor jeg legger 0 inn i det registeret først. Denne institusjonen tar S, som er R3, og legger til I, som er R2, og så lagres det i R3. Det vil da være S lik S pluss I. Denne institusjonen kan datamaskinen min utføre. Så kommer et veldig viktig step. Jeg sammenligner. Og det jeg sammenligner, det er R2 og R0. R0, det er maks. Jeg ønsker at løkka skal bare gå opp til 3. Altså dette er maks. Og da sammenligner jeg R2, som er da...", "source": "lecture"}
{"lecture_id": "os3bdel9", "chunk_id": "os3bdel9_0001", "start": 150.0, "end": 327.66, "token_count": 593, "text": "Denne institusjonen tar S, som er R3, og legger til I, som er R2, og så lagres det i R3. Det vil da være S lik S pluss I. Denne institusjonen kan datamaskinen min utføre. Så kommer et veldig viktig step. Jeg sammenligner. Og det jeg sammenligner, det er R2 og R0. R0, det er maks. Jeg ønsker at løkka skal bare gå opp til 3. Altså dette er maks. Og da sammenligner jeg R2, som er da... På en måte variabelen i. Har den blitt så stor som 3? Men foreløpig er I liggende 1, så det har den ikke. Og når jeg da gjør neste institusjon, jump not equal, så hopper jeg opp til 4 igjen. Og den består av at man øker i med én. Så får jeg i lik to, og så får jeg summen lik én pluss to er lik tre. Og så gjør jeg dette en gang til. Her er i lik to, jeg hopper opp. Øker i lik tre. S er lik tre... Tre pluss tre, og da er summen seks. Og nå har i blitt tre, og da hopper jeg ikke opp igjen. Jeg har fått resultatet seks. Og programmet har blitt utført. Og det er nøyaktig sånn man går fra høynivåkode til assemblerkode eller maskinkode. Neste steppe nå er at jeg må kode inn denne maskinkoden eller denne asemblyen inn i maskinkode. Og det er veldig rett frem, for det er bare å oversette instruksjon for instruksjon. Og... Ja, hvis jeg bruker mye tid her nå... Jeg går litt over tiden, håper dere holder ut. Selv om det er litt tungt dette her, så får dere jobbe dere gjennom dette ved å se på oppgavene. Men hele clouet er nå at vi oversetter disse institusjonene én for én. F.eks. den første linjen'move i r03', altså legg tallet 3 inn i r0. R0 er destination. Source er det tallet vi skal legge inn. Det er tallet 3. Det skal legges i register 0. På samme måte, samme instruksjon, men nå skal vi legge 1 i r1. Da må det stå 1 der og 1 der. Etter hvert kommer vi ned til add.", "source": "lecture"}
{"lecture_id": "os3bdel9", "chunk_id": "os3bdel9_0002", "start": 284.6, "end": 383.98, "token_count": 348, "text": "Men hele clouet er nå at vi oversetter disse institusjonene én for én. F.eks. den første linjen'move i r03', altså legg tallet 3 inn i r0. R0 er destination. Source er det tallet vi skal legge inn. Det er tallet 3. Det skal legges i register 0. På samme måte, samme instruksjon, men nå skal vi legge 1 i r1. Da må det stå 1 der og 1 der. Etter hvert kommer vi ned til add. Lik R2 pluss R1. Da må vi skrive inn her av instruksjon nummer fire. Og så... Destination register, det er da R2, og da ser vi at det står et 2-tall der. Det gir da R2 og 1. Det betyr R1. Så dermed utføres R2 lik R2 pluss R1. Hvis jeg f.eks. hadde skrevet 3 her i stedet, så ville jeg utført R3 lik R3 pluss R1. Så på denne måten programmerer jeg maskinen med akkurat den koden jeg ønsker. Vanligvis, hvis du f.eks. har høynivåkode i C, så har man en kompulator. Du kompilerer høynivåkoden, og så lager kompulatoren denne maskinkoden. Og så kjøres den. Men i vårt tilfelle, så gjør vi dette.", "source": "lecture"}
