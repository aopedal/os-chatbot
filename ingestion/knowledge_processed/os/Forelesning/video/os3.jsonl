{"lecture_id": "os3", "chunk_id": "os3_0000", "start": 0.0, "end": 222.0, "token_count": 596, "text": "Ja, god morgen, alle sammen. Kjempehyggelig å se at dere er så mange av dere som har kommet dere opp. Kommer på forelesning. Det er veldig hyggelig. Og som sagt, jeg tror det er kjempebra å ha noen sånne faste punkter. For det ser ut som det fortsatt kommer til å bli digital undervisning frem til påske. Men forhåpentligvis så vil vi i hvert fall da kunne starte med fysisk undervisning. I dag så er det lagt ut oppgaver, sånn at man kan faktisk gjøre ferdig første obligg. Og levere inn det. Det har alltid gått med ting som er ferdig. Hvis du ligger litt i forkant, så prøv å få ferdig obliggen så snart du klarer. Jeg tenkte å starte med å si litt praktisk om det, men før jeg kommer så langt, så spør gjerne i skjetten underveis eller på timen. Og spesielt hvis det er noe... Hvis det er noe viktig, så f.eks. at dere ikke hører meg, eller at det er opplagt noe som er galt, så er det kjempefint om dere bare tar av lyden. Det kan dere uansett gjøre når som helst. I tillegg så kommer Ine i dag og kommer til å sitte og hjelpe meg med chatten og svare på alt som er av spørsmål. Kan ikke se at hun er her ennå. Hatt litt problemer med laptopen sin, men hun er der forhåpentligvis snart. OK, aller først.... Så skal vi se litt på obliggene. Skal si litt mer om det og grupper osv. Det blir litt praktisk å starte med. Da skal vi se på denne. Her er kanalsrommet. Som dere ser, så har det kommet oblikktider. Den første er satt. De andre skal jeg tilpasse med. Si gjerne fra også, hvis dere allerede nå ser at dette kolliderer, så kan vi flytte på innleveringer sånn at det passer best for dere. Dere har litt forskjellige fag også, så det er ikke så lett å få til for alle. Men vi prøver å få det til så bra som mulig. Men først og fremst så ligger første opplegg her. Og her står det en tekst om den. Opplegget er sånn at alle oppgaver som er merket rødt med Oblig i de første oppgavene,", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0001", "start": 180.02, "end": 363.72, "token_count": 594, "text": "Si gjerne fra også, hvis dere allerede nå ser at dette kolliderer, så kan vi flytte på innleveringer sånn at det passer best for dere. Dere har litt forskjellige fag også, så det er ikke så lett å få til for alle. Men vi prøver å få det til så bra som mulig. Men først og fremst så ligger første opplegg her. Og her står det en tekst om den. Opplegget er sånn at alle oppgaver som er merket rødt med Oblig i de første oppgavene, til og med uke fire, det utgjør den første obligatoriske oppgaven. Og alle de har lagt ut nå, så det inkluderer da oppgaver i neste uke. Dere skal... Ine er tilgjengelig i chatten. Kjempebra, Ine. Dere skal levere dette som grupper. Vi anbefaler grupper på to og tre. Det kan være mulig å være ene, hvis dere er alene. Hvis dere ikke har noen å jobbe sammen med eller andre forhold, anbefaler vi å jobbe i grupper. Noen som tidligere har jobbet i gruppe på fire, og til og med på fem. Vi anbefaler det ikke, men hvis dere er en sammensveiset gruppe, så går det altså an. Uansett om dere er én eller to eller opp til fem, så skal dere levere som en av OS-gruppene. OS 123. Og hvis man går inn på people, personer, er det der, så ser man at det er en... Her er en meny som heter OS her oppe. Og da ser vi at her er det en rekke OS1 og OS2-grupper nedover. Vi ser en del av dere har allerede meldt dere inn i grupper. Men da er det veldig fint om... Når dere fortsetter å gjøre det, så melder dere inn i første tomme gruppe. Her ser vi OS6 er nå den første tomme. Så hvis dere skal lage en gruppe nå, så tar dere OS6. Og da, etter at dere har laget gruppe, så leverer dere inn obliger som den gruppen. Og det kan være selv om det da er sånn som her, bare én student, så leverer du likevel inn sånn gruppe. Etter hvert skal dere få VM-er, virtuelle maskiner, eller aktisk dokker, virtuelle maskiner. Og da vil dere få utlevert passord osv. i disse gruppene. Dette står også på kurssiden.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0002", "start": 319.52, "end": 509.0, "token_count": 593, "text": "Så hvis dere skal lage en gruppe nå, så tar dere OS6. Og da, etter at dere har laget gruppe, så leverer dere inn obliger som den gruppen. Og det kan være selv om det da er sånn som her, bare én student, så leverer du likevel inn sånn gruppe. Etter hvert skal dere få VM-er, virtuelle maskiner, eller aktisk dokker, virtuelle maskiner. Og da vil dere få utlevert passord osv. i disse gruppene. Dette står også på kurssiden. Her ser vi. Dette er de fire første ukene. Vi er nå her i uke tre. Så dette er oppgavene vi skal jobbe med i dag. Men du kan allerede nå gå i gang med uke fire-oppgavene. Fristen for obligasjonen er ikke i neste uke, men i uken etter. Så at dere har litt tid på å få de siste oppgavene ferdige. Her står det egentlig bare den samme teksten som på KANDAS. Og det er det jeg tror dere trenger å vite om oppgavene. I dag så skal vi, som det står her, se på vipper og registre. Det er altså hvordan lagre bits i en CPU. Så skal vi se på CPU-arkitektur. Og det som egentlig er ganske fantastisk, er at vi skal bygge... Vi skal ikke bygge, men vi skal se på hele arkitekturen til en CPU. Hvordan den virker helt fra transistornivå og oppover. Og oppover, det betyr at vi skal være i stand til å implementere... Det vi implementerer, er en liten forløkke. Men i prinsippet gjelder akkurat det samme for all mulig kode. Så all mulig kode kan i prinsippet implementeres på den simuleringen vi har. Ja. Ellers så er det... tema fra digitale forelesninger i forrige uke, som da ukens oppgaver... Det er litt diverse Linux-kommandoer. Også noen små sånne triks for å jobbe raskere i skjellet. Det er det viktig å få med seg. Kan se kjapt på de òg. Her er det tidsbesvarende triks i et Linux-skjell. Det er det nyttig å få med seg for å kunne jobbe litt raskere og mer effektivt. Så er det litt diverse... Mye filbehandling. Litt om orientering osv.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0003", "start": 473.72, "end": 663.88, "token_count": 578, "text": "Det er litt diverse Linux-kommandoer. Også noen små sånne triks for å jobbe raskere i skjellet. Det er det viktig å få med seg. Kan se kjapt på de òg. Her er det tidsbesvarende triks i et Linux-skjell. Det er det nyttig å få med seg for å kunne jobbe litt raskere og mer effektivt. Så er det litt diverse... Mye filbehandling. Litt om orientering osv. Så er det ett punkt som er viktig her, og det er med filrettigheter. Det er det viktig å kunne sette på et Linux-system. Som vanlig så la jeg på onsdag ut diverse demoer rundt disse temaene. Så her kan dere jobbe som dere vil. Enten kan dere gå inn og se på demoene først, og så gjøre oppgaver, eller så kan dere kanskje starte på oppgavene. Hvis dere står fast, så kan dere gå tilbake og se hvordan jeg gjør det her. Men det aller viktigste er at dere faktisk gjør disse oppgavene, og får til det praktiske. For dette er stoff som du trenger å øve og prøve og feile litt for å få det inn i fingeren. OK. Da skal vi gå til dagens sema. Vipper og registre. Og datamaskinarkitektur. Først en kort oppsummering av hva vi gjorde sist. Veldig små brytere. Det kommer en ledning inn til bryteren som skrur den av og på. Er den på, leder transistoren strøm. Er den av, leder transistoren ikke strøm. Veldig enkelt. Dette enkle prinsippet kan man da bruke til å lage logiske porter. Og med logiske porter så kan man implementere and or not. Og man kan implementere alle logiske sammenhenger. Dette brukes av en datamaskin for å lage en maskin som gjør nøyaktig det vi ønsker den skal gjøre. Vi ønsker den skal gjøre forskjellige institusjoner. Som f.eks. å legge sammen to tall, trekke fra hverandre tall, sammenligne to tall, osv. Og når man har klart for seg hvilken funksjon man skal ha. I forrige gang så vi på dette med å addere to tall. Da så vi på algoritmen for å addere to tall.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0004", "start": 627.52, "end": 798.36, "token_count": 587, "text": "Dette brukes av en datamaskin for å lage en maskin som gjør nøyaktig det vi ønsker den skal gjøre. Vi ønsker den skal gjøre forskjellige institusjoner. Som f.eks. å legge sammen to tall, trekke fra hverandre tall, sammenligne to tall, osv. Og når man har klart for seg hvilken funksjon man skal ha. I forrige gang så vi på dette med å addere to tall. Da så vi på algoritmen for å addere to tall. Da fant vi ut at en bit av algoritmen kan vi ta ut og lage en logisk krets av. Det første man gjør, er å skrive ned en sannhetsstabell som viser logikken systemet skal ha. Og så så vi at ut ifra en sandstabell, så kan man skrive rett ned en krets med and or and not-porter. Det er en veldig rett frem-metode for å gjøre det. Etter at man har gjort det, så kan det bli ganske komplekse kretser. Men da kan disse forenkles med bolskalgebra. Og når man har gjort det, så har man en logisk rets som man kan tegne opp. Man kan sende den til en produsent, og så kan man få et kretskort som gjør nøyaktig det man ønsker. Man lager som regel ikke et kretskort av bare en liten av dere, som vi gjorde sist. Men man har en litt større krets. Men prinsippet er akkurat det samme. Vi så på én liten boks. Hemmeligheten med å lage en hel CPU er at man tar mange av den typen bokser og setter sammen til en stor og kompleks enhet. Det vi lagde sist, var en krets med en logisk krets som aderer tall. Avdelingskrets. Så dette var på en måte sluttresultatet fra forrige time. Logisk sett så var dette sluttresultatet. Og det vi har oppnådd, er at vi har lagd... Et lite kretssystem, bare ved hjelp av logikk og enkle brytere, A- og påbrytere, som er sånn at hvis vi sender inn fire bit A og fire bit B inn til denne maskinen, så uansett verdien på nullerne og enerne her, så får man ut summen C av A pluss B. I dette eksempelet her så står det tallet seks, både A og B.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0005", "start": 752.4, "end": 932.32, "token_count": 597, "text": "Avdelingskrets. Så dette var på en måte sluttresultatet fra forrige time. Logisk sett så var dette sluttresultatet. Og det vi har oppnådd, er at vi har lagd... Et lite kretssystem, bare ved hjelp av logikk og enkle brytere, A- og påbrytere, som er sånn at hvis vi sender inn fire bit A og fire bit B inn til denne maskinen, så uansett verdien på nullerne og enerne her, så får man ut summen C av A pluss B. I dette eksempelet her så står det tallet seks, både A og B. Og det som kommer ut, det er en ener, toer, firer og en åtter. Så det er åtte pluss fire. Det er tolv som kommer ut. Og det er det riktige svaret i dette tilfellet. Det vi kanskje ikke sa så mye om sist, er at det er et opplagt problem her. Hva om man legger sammen et stort tall? La oss si vi har enere på alle her. Det blir tre pluss tolv. Det blir 15. Hvis man legger sammen 15 pluss 15, så får man jo 30. Men det største tallet som kan lages eller vises med 4-bit, det er jo 15. Så her skjer det noe galt. Og da får man en såkalt overflow. Og det fører ofte til problemer. Men sånn er det. Hvis man regner med 32-bitstall, f.eks., så... Hvis man tar med pluss og minus, så kan de maks representere to milliarder. Hvis man da utfører et regnsyke i et C-program eller et annet program hvor resultatet blir høyere enn to milliarder, så får du en feil. Da kan man plutselig risikere å få ut et negativt tall når man legger sammen to store tall. Så dette gjelder for alle systemer, men man må bare ha nok prøver. Sånn at man kan få representert så store tall som mulig, eller som man behøver. Og så ser vi at vi egentlig bare trenger ett bit til, så kan vi representere summen av alle fire bits tall. Men nå kommer det vi trenger å gjøre videre. Det er problemer av denne kretsen. Og det er jo ikke alltid vi skal legge sammen. Så derfor så lager man da heller en litt mer kompleks krets, som kan gjøre flere ting på en gang.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0006", "start": 883.68, "end": 1071.4, "token_count": 593, "text": "Så dette gjelder for alle systemer, men man må bare ha nok prøver. Sånn at man kan få representert så store tall som mulig, eller som man behøver. Og så ser vi at vi egentlig bare trenger ett bit til, så kan vi representere summen av alle fire bits tall. Men nå kommer det vi trenger å gjøre videre. Det er problemer av denne kretsen. Og det er jo ikke alltid vi skal legge sammen. Så derfor så lager man da heller en litt mer kompleks krets, som kan gjøre flere ting på en gang. Og det man lager da, er en alu, og det skal vi snakke mye om i dag. Arithmetic Logic Unit står ALU for. Altså en aritmetisk og logisk enhet. Den kan både gjøre aritmetikk, altså legge sammen og trekke fra osv. Og i tillegg gjøre logikk, sammenligne og ande over osv. Det smarte trikset her er at det viser seg at en del kretser kan ligne litt på hverandre. F.eks. hvis du skal trekke fra, så kan du bruke addisjon. Altså gjøre noen smarte triks med to-ord-kompliment, som er en måte å representere. Hvis du representerer negative tall med to i kompliment, så kan man nesten bruke akkurat det samme som en adderer. Og så får man inn fortegnene også. Tilsvarende med andre komponenter. Man kan bruke litt av de andre portene, sånn at det blir mer effektivt. Så kommer det smarte at man putter inn noen kontrollbitt i aluen. Her står det S0 og... Og i dette tilfellet så har jeg lagd en alu som er sånn at... Ja, f.eks. hvis S0 er 0 og Sn er lik 1, så adderer denne kretsen. Det er bare noe man definerer. Men hvis begge to er 0, så kanskje så utføres a minus b. Og hvis det er to e-er inne her, så kanskje det som kommer ut da, er... Og det er tilfellet i... det tilfellet her, at det som kommer ut av C, er A pluss 1. Det er increment, altså man øker verdien med 1. Ja, det er spørsmål når du ser slides. Ja, det... Det er fint at de fleste ser slides. Det er meningen.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0007", "start": 1025.16, "end": 1206.56, "token_count": 583, "text": "Men hvis begge to er 0, så kanskje så utføres a minus b. Og hvis det er to e-er inne her, så kanskje det som kommer ut da, er... Og det er tilfellet i... det tilfellet her, at det som kommer ut av C, er A pluss 1. Det er increment, altså man øker verdien med 1. Ja, det er spørsmål når du ser slides. Ja, det... Det er fint at de fleste ser slides. Det er meningen. På denne måten så kan man få kretsen til å gjøre akkurat det den operasjonen man ønsker, ved å sette inn kontroll dit. Det er viktig å ha med seg videre når vi skal bygge opp en CPU. Så bruker vi nøyaktig den biten der. Det er dette som fører til såkalte instruksjoner, eller maskininstruksjoner. Disse bitene kontrollerer nøyaktig hva Alun gjør. For Alun, det er virkelig hjernen til CPU-en. Og CPU-en er hjernen til datamaskinen. Så det er her det skjer. All logikk og alt som du programmerer, det vil til syvende og sist utføres inni Alun. Alle operasjoner, som å addere, som vi så på. Riktignok med 3D-er, men subtrahere, eller subtrahere, det er å trekke fra. Og increment eller pluss-pluss, decrement. Skulle være minus-minus, altså du trekker fra én. Og litt mer komplekse operasjoner som å multiplisere og dividere. De aller enkleste allene kan ikke multiplisere og dividere. Hvis de skal lage noen små multiplikasjoner, så må de legge sammen mange ganger. Men i de mer komplekse aluene så har man en egen krets som multipliserer. Dividerer tar enda litt mer tid. Men det betyr at disse operasjonene kan ta litt lengre tid enn av dere. De første her er aritmetiske operasjoner. Så de tre siste er logiske. Så det er den logiske delen med logiske operasjoner. Skift, f.eks., som flytter alle bitt i én retning, det skal vi se på etterpå. Noe som man hele tiden gjør, f.eks. en GIF-test, er å sammenligne to størrelser.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0008", "start": 1171.24, "end": 1366.24, "token_count": 588, "text": "Dividerer tar enda litt mer tid. Men det betyr at disse operasjonene kan ta litt lengre tid enn av dere. De første her er aritmetiske operasjoner. Så de tre siste er logiske. Så det er den logiske delen med logiske operasjoner. Skift, f.eks., som flytter alle bitt i én retning, det skal vi se på etterpå. Noe som man hele tiden gjør, f.eks. en GIF-test, er å sammenligne to størrelser. Finne ut om de er like eller forskjellige, eller om den ene er større eller mindre enn den andre. De spesifiserer ofte 16 operasjoner til denne Alu. Ofte har de enda flere operasjoner. Dette er et tidlig Alu-design på en maskin som het Edzak-2. Som ble lagd i 1958. Dette var akkurat på overgangen til man begynte med transistorer. Men disse maskinene hadde radiorør. Et helt sånt radiorør tilsvarer en transistor. Da sier seg selv at da ble disse maskinene ganske enormt store. Men sånn så det ut. Det er ikke så langt tilbake. Men det illustrerer den enorme revolusjonen som transistoren gjorde, hvor vi kan få i dag milliarder av sånne transistorer inn på en liten brikke. Ja, nå er vi ferdig med en viktig del av Alun. Men den neste viktige nå er å kunne lagre dataene. Hvis vi går tilbake her, så ser vi... Jeg har ikke sagt noe om hvordan man lagrer disse bitene her. Men opplagt så trenger vi i en CPU utenpå Alun... Lagerenheter hvor vi kan lagre tall og størrelser. Det kan også være en representerende bokstav, men vi må i hvert fall ha en lagerenhet som lagrer en rekke med bitt. Det kalles et register, og det er da en veldig viktig komponent i NCPU. I tillegg at denne må kunne lagre tall, så må den være veldig rask. Disse portene her, disse logiske portene, de er ekstremt raske. Så... Så den beste løsningen er å lage disse registrene av samme teknologi som man lager enda flere porter, nemlig med transistorer. Og det er det mulig å få til. Man kan i prinsippet... På den enkleste måten.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0009", "start": 1322.66, "end": 1500.68, "token_count": 596, "text": "Det kalles et register, og det er da en veldig viktig komponent i NCPU. I tillegg at denne må kunne lagre tall, så må den være veldig rask. Disse portene her, disse logiske portene, de er ekstremt raske. Så... Så den beste løsningen er å lage disse registrene av samme teknologi som man lager enda flere porter, nemlig med transistorer. Og det er det mulig å få til. Man kan i prinsippet... På den enkleste måten. Måten å tenke seg å lagre null og én, er å lagre en liten mengde med ladning. Med elektrisk ladning. Akkurat som du gnir på en ballong, så har den positiv ladning. Og så kan du ta på den, så får du et lite støt, og da lader du ut ballongen. Da kunne du tenke deg at en ballong med ladning én, den er en ener. Og ladning null er en null. Teknologien brukes i ram, som vi skal se på senere. Det er noen problemer med ram. For det første at det ikke er like hurtig som porter. Og for det andre så må de refreshes. Man må lade dem opp kanskje sånn ti ganger i sekundet, hvis du skal beholde den ene. Derfor bruker man ikke dette i CPU-er, men man bruker i stedet såkalte vipper, eller flip-flops på engelsk. En konstitusjon som ved hjelp av korter gjør at man kan lagre nuller og enere. Vi skal se på i detalj hvordan man gjør det. Og det er mye raskere enn RAM. Det er ikke ekstremt, det er i hvert fall en faktor ti. Og kanskje mer i nå tilfelle. Men en faktor ti er mye. Og et 64-bit-register, f.eks., det består da av 64 VIP-er. En vippe er én enhet som kan lagre en null eller en ener. Det er ikke så enkelt å bare lage en lagringsenhet av porter. Men noe som vi må få til, er å lage en lukket krets. Det er eneste måten vi kan lagre noe, ellers er port bare input og output. Men vi ønsker å lagre det. Dermed må vi sette opp en lukket krets. Dette er det første forsøket vårt på å lagre en bit. Det jeg skal gjøre nå, er å prøve å feile", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0010", "start": 1458.46, "end": 1624.08, "token_count": 576, "text": "En vippe er én enhet som kan lagre en null eller en ener. Det er ikke så enkelt å bare lage en lagringsenhet av porter. Men noe som vi må få til, er å lage en lukket krets. Det er eneste måten vi kan lagre noe, ellers er port bare input og output. Men vi ønsker å lagre det. Dermed må vi sette opp en lukket krets. Dette er det første forsøket vårt på å lagre en bit. Det jeg skal gjøre nå, er å prøve å feile og så utvikle en konstruksjon som kan lagre en bit. Og q er da liksom den lagrede enheten. Så i dette tilfellet, i denne kretsen her, så lagrer vi en ener. Dette er en notport. Så kommer en null inn her, og så går den enere ut. Så ser vi at vi har koblet output fra den notporten til input på den som står under. Da ser vi for en litt lur krets. Det kommer en ener inn her, og da vil det gå en null ut. Så går en null inn der, og så kommer det en ener ut. Så her har vi konstruert en krets som inneholder en ener. Hva er problemet, er spørsmålet. Jo, problemet her er at det er vel og bra at vi har den eneren, men dette er en lukket krets, så der vil det bare bli stående en ener for evig og alltid. Så på en eller annen måte må vi kunne endre på denne verdien. Og da kommer neste forsøk. Her har vi en litt mer komplisert krets, hvor vi da kan endre en bitt-verdi. Etter pause tenkte jeg å ta en poll hvor vi får noen spørsmål fra dette. Så her gjelder det å følge med. Det ser jo litt komplisert ut. Men det er egentlig ikke så komplisert. Her fremme har vi den samme konstitusjonen med not-porter. Men i tillegg, for å kunne legge inn en verdi, altså verdien d, det er den som vi ønsker å lagre, så har vi satt opp et system med to år. Da kan man overbevise om at hvis man setter inn en null her, så lagres en null. Hvis man setter inn en ener, så lagres en ener. Vi kan jo se på hva som skjer hvis man setter inn en null.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0011", "start": 1588.42, "end": 1757.44, "token_count": 597, "text": "Men det er egentlig ikke så komplisert. Her fremme har vi den samme konstitusjonen med not-porter. Men i tillegg, for å kunne legge inn en verdi, altså verdien d, det er den som vi ønsker å lagre, så har vi satt opp et system med to år. Da kan man overbevise om at hvis man setter inn en null her, så lagres en null. Hvis man setter inn en ener, så lagres en ener. Vi kan jo se på hva som skjer hvis man setter inn en null. Jo, da kommer det en null inn her. Går inn i notporten. Da må det bli en ener her. Og så vet vi det at når det kommer en ener inn i en overport, så vil det alltid komme en ener ut. Det kommer en ener inn her, så uansett hva som er der, så kommer det en ener ut. Dermed får vi lagt inn denne verdien null i denne kretsen. For det kommer en ener inn her, og da blir det en null der. Så får vi på samme måte som tidligere at det er en lukket krets. Det går en null inn i denne orporten, og så kommer det en null herfra. Da er det null som går videre, og så blir det en ener der. Og en og en gir 1 og 0 osv. Og hvis man da ønsker å switche og legger inn en ener her, så får vi akkurat det motsatte. Og da vil det til slutt bli en ener her. Det som skjer da, er at da kommer det en ener inn her. En ener inn i en orfort vil alltid gi en ener. Så kommer det null her. Og da kommer det null inn der. Da kommer det to nuller inn der. Så på samme måte så funker den også. Men hva er problemet nå? Problemet nå er ikke like lett å se, men det vi skulle ønske, er at man på en måte kan skru av innvirkningen fra denne D-en. Man ønsker å ha en vippe, eller en lagerenhet, som er sånn at... Hvis vi setter på en null her, så lagres nullen. Men så skulle man ønske å på en måte skru av kretsen, sånn at den nullen blir bevart. Uansett om d-en her endres. Så jeg ønsker å ha et system som er sånn at om jeg endrer d-en til 1 her nå, så kan jeg velge at vippen, eller det registeret som holder denne verdien, det skal være uendret.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0012", "start": 1723.22, "end": 1929.52, "token_count": 596, "text": "Man ønsker å ha en vippe, eller en lagerenhet, som er sånn at... Hvis vi setter på en null her, så lagres nullen. Men så skulle man ønske å på en måte skru av kretsen, sånn at den nullen blir bevart. Uansett om d-en her endres. Så jeg ønsker å ha et system som er sånn at om jeg endrer d-en til 1 her nå, så kan jeg velge at vippen, eller det registeret som holder denne verdien, det skal være uendret. Med en gang de gjør en endring her, så forplanter den endringen seg. Og så lager vi en annen bit. Så dette er foreløpig løsningen. Det er en såkalt de-loch, eller de-latch på engelsk. Det er en enhet som lager et bitt. Men i tillegg... Så kan man velge å skru av enheten, sånn at den ikke reagerer på input. Vi har fått inn en C her i tillegg. Den virker sånn, det er en kontrollenhet. Den er sånn at hvis jeg liker én, så vil verdien som kommer inn på det her, den vil lagres. Og hvis jeg liker null, så vil denne lagrede verdien beholdes, helt uavhengig av hva som kan skje. Det har vi fått til ved å endre litt på den forrige. Vi har lagt inn to and-porter. Ellers så er de to ord-portene her. Vi ser tilbake. Konstruksjonen er helt lik, bortsett fra at vi har lagt inn to and-porter. Og da kan man igjen overbevise seg selv om at vi ser lik én. Da vil denne løsningen virke akkurat som den forrige løsningen. For vi vet at med and... Hvis det kommer en ener inn i en and-port, så... Jo, så er det den andre verdien som gir upput, f.eks.. Hvis... Hvis det kommer en 1 inn her og en ener inn der, så får man en ener ut. Men det er ikke helt riktig. Hvis det kommer en null inn, så kommer det alltid en null ut. For å overbevise om at denne virker, så kan vi kanskje se på... Hva skjer f.eks. hvis 1 er 1, og denne nå skal virke og skal endre? Hva skjer da med kretsen? Jo, hvis det kommer en ener inn på det og CL1, så kommer det en ener inn der.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0013", "start": 1888.0, "end": 2075.9, "token_count": 595, "text": "så får man en ener ut. Men det er ikke helt riktig. Hvis det kommer en null inn, så kommer det alltid en null ut. For å overbevise om at denne virker, så kan vi kanskje se på... Hva skjer f.eks. hvis 1 er 1, og denne nå skal virke og skal endre? Hva skjer da med kretsen? Jo, hvis det kommer en ener inn på det og CL1, så kommer det en ener inn der. Og samtidig vil det da komme null inn der. Og da vil kretsen fungere akkurat som. Som denne her, på samme måte. Men så ser vi i c-lik null. Da skrur vi på en måte av innvirkningen fra kretsen. For i c-lik null, så vil det komme en null inn i begge endeportene. Og da går det null videre til begge årportene. Og når det kommer null inn i begge årportene, så vil denne kretsen Den blir helt isolert, så den vil ikke endre seg, uansett om man endrer på det. Så man kan overbevises om det er slik kretsen virker. Det er egentlig bare å prøve alle kombinasjoner. Men det aller viktigste er bare å vite at sånn funker den kretsen. Hvis c er lik 1, så leser den impet-verdien og lagrer den. Hvis det er lik null, så beholdes verdien som er lagret, uavhengig av hva det er. Og så ser vi det som vi hele tiden gjør i datamaskinarkitektur. Vi lager da en liten sånn logisk boks som inneholder alt dette. Akkurat som vi lagret den aritmetiske enheten. Akkurat som vi lagde den Adereren. Vi lagde en kompleks aderer og en liten boks. Og så etterpå, når vi logisk skal sette det sammen, er det lett å bruke disse boksene. Det er spørsmål i kretsen om... I disse lukkede kretsene, hvordan kommer verdien ut? Går de ikke rundt og rundt i evighet? Jo, de går på en måte rundt og rundt i en evighet. Det er sånn vi ønsker å lagre f.eks. denne kretsen her. Her vil den gå rundt og rundt i evighet, og vi beholder den eneren. Men når vi lager en krets sånn som dette her, så kan vi koble det sammen.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0014", "start": 2036.92, "end": 2216.96, "token_count": 593, "text": "Og så etterpå, når vi logisk skal sette det sammen, er det lett å bruke disse boksene. Det er spørsmål i kretsen om... I disse lukkede kretsene, hvordan kommer verdien ut? Går de ikke rundt og rundt i evighet? Jo, de går på en måte rundt og rundt i en evighet. Det er sånn vi ønsker å lagre f.eks. denne kretsen her. Her vil den gå rundt og rundt i evighet, og vi beholder den eneren. Men når vi lager en krets sånn som dette her, så kan vi koble det sammen. Og da vil vi se at når vi setter selik 1 og endrer på intetverdien det, så vil vi få en endring her. Og dermed så får man en endring. Og da endres systemet hele tiden, og det er nøyaktig det som skjer i en CPU. Men det skal vi se på i detalj. Ja. Det er også et spørsmål om problemene i de to første kretsene. Vi har et par oppgaver som vi skal se på, men jeg kan si det kjapt. Her er problemet her. Det er at man ikke kan endre på verdien. Hvis man først har en ener inn her, så er det umulig å endre på den eneren og gjøre den til null. Så dermed legger vi på dette systemet for å kunne endre verdien. Og nå har vi et system som kan endre verdi. Nå er det null her. Da lagres den nullen. Hvis jeg endrer den til én, så kommer det en ener her. Er at med én gang jeg gjør en endring her, så endres verdien seg. Men jeg ønsker å ha en lagerenhet som man på en måte kan skru av. Sånn at den lagrede enheten bare forblir der, uten å endres. Og for å få til det, så trenger man en litt mer kompleks struktur. Nemlig en bryter, en kontroller C som skrur av og på det. At man kan lagre data. Så skal vi prøve å bruke disse fire delåsene for å gjøre noe praktisk med det. For det oppstår faktisk fortsatt et problem. Selv etter at vi har lagd den fine devicen her, så har vi fortsatt et problem. Ja, og det er et litt mer komplekst problem. Men vi ser... Dette er måten man setter sammen biter på. Man kabler dem sammen.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0015", "start": 2172.6, "end": 2360.1, "token_count": 581, "text": "Nemlig en bryter, en kontroller C som skrur av og på det. At man kan lagre data. Så skal vi prøve å bruke disse fire delåsene for å gjøre noe praktisk med det. For det oppstår faktisk fortsatt et problem. Selv etter at vi har lagd den fine devicen her, så har vi fortsatt et problem. Ja, og det er et litt mer komplekst problem. Men vi ser... Dette er måten man setter sammen biter på. Man kabler dem sammen. Så her ønsker jeg å lage et såkalt skiftregister. Hvor vi har lagret 1.0, 1.0. Og så ønsker vi at... Ved å skru på den bryteren her, så ønsker jeg å flytte... Alle byttene til høyre. Sånn at den nullen kommer inn her. Eneren skyver seg over dit, null over dit og én over dit. Sånn at vi utfører da operasjonen ved å gå fra 1010 til 0101. Og den operasjonen er faktisk da å dele på to, hvis man tenker på dette som et tall. Denne konstitusjonen ser jo helt fin ut, fordi vi husker at Q er det som lagres. Så hvis vi f.eks. ser på den siste enheten her, som har lagret en null. Så ser vi at den leser en ener. Verdien på den latchen, den låsen, som står til... Det er en ener. Og den kommer inn som input på det. Og så lenge c er lik 1, så vil den da lese den verdien. Da vil den få en ener. På samme måte så vil denne her lese den nullen og få en null. Denne vil lese eneren og få en 1. Denne leser 0 og får en 0 der. Og da vil det etterpå... Så vil det stå 0, 1, 0, 1. Og så kan vi da tenke oss at... Nøyaktig når jeg har gjort det, så skrur vi av C. Setter den til null, og dermed har vi utført den skiftoperasjonen. Men så er det et problem, og det som er problemet, er timing. Jeg sa at vi etter en stund så skrur vi av den eneren her. Setter den til null. Men da er spørsmålet hvordan får vi riktig timing her? Og det er en del av problemet.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0016", "start": 2320.96, "end": 2520.06, "token_count": 600, "text": "Og så kan vi da tenke oss at... Nøyaktig når jeg har gjort det, så skrur vi av C. Setter den til null, og dermed har vi utført den skiftoperasjonen. Men så er det et problem, og det som er problemet, er timing. Jeg sa at vi etter en stund så skrur vi av den eneren her. Setter den til null. Men da er spørsmålet hvordan får vi riktig timing her? Og det er en del av problemet. For dette er jo fysiske komponenter, så når man skrur på den eneren og får den til å virke, så vil det ta bitte litt tid. Kanskje i underkant av et nanosekund, når disse komponentene er ekstremt små. Men likevel litt tid. Fra denne nullen proposisjonen, Det er strøm... Bitte små strømmer som strømmer. Propagerer sånn at den blir til en null å lagre seg. Det tar litt tid. Dermed kan det være litt forskjell i hvor lang tid det tar. Dette kan være enda større forskjeller hvis disse enhetene ikke er like. Da kan det virkelig være en avgjørende forskjell i tid på. Hvor lang tid det tar før den strømmer herfra og hit. Og med en gang det skjer, så får man et problem med at... Vi ser denne leser jo en ener. Men hva om den nullen har propagert hit før den her har rukket å lese eneren? Da vil den å lese null. Og hvis man har en liten usikkerhet i tiden her, så vil ikke det. I tidligere år hvor vi hadde fysiske forelesninger, så prøvde jeg å illustrere dette. Ved at dere som studenter ble stilt opp i en rekke, sånn som dette. Med jenter og gutter. Fant ikke noen gode studentillustrasjoner, så det ser jo ikke sånn ut.  Ideen var da at man setter opp åtte menneskelige delåser på rad. Hvor en arm opp, sånn som de to her, det betyr en ener. Og en arm ned, det betyr en null. Og ideen var da at disse menneskene skulle virke som vipper. Og opplegget var da sånn at hun som står sist her, hun skal da se på den personen som står foran seg. Nei, det var faktisk motsatt. Han som står her, han skal se på hun som står til høyre for seg. For dette skal også være et skifteregister.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0017", "start": 2482.3, "end": 2682.92, "token_count": 595, "text": "Hvor en arm opp, sånn som de to her, det betyr en ener. Og en arm ned, det betyr en null. Og ideen var da at disse menneskene skulle virke som vipper. Og opplegget var da sånn at hun som står sist her, hun skal da se på den personen som står foran seg. Nei, det var faktisk motsatt. Han som står her, han skal se på hun som står til høyre for seg. For dette skal også være et skifteregister. Og så her er det null, hun har armen nede, og da skal han ta armen. Hun ser på han, så hun skal fortsette å holde armen opp. Han skal se på henne og skal løfte opp hånden, sånn at man får et skift. Altså at de to enerne går til venstre. Det viser seg når man setter opp dette og gjør det i praksis, så fungerer det veldig dårlig. Fordi det alltid er litt forskjell, når et menneske gjør noe sånt, i hvor lang tid man bruker. Og det som hele tiden oppstår da, er sånn som her, at det er to enere, og så plutselig blir det tre enere, for du får en ener til. Og det kan være fordi det er forskjell i hvor fort hun som står her, ser den hånden her. Så... Hvis han løfter den hånden veldig fort opp fordi han ser hunna-hånden i været, så vil hun plutselig ta hånden opp. Og dermed så oppstår det en bit som kommer ut fra ingenting. Og dette er opplagt... Dette er opplagt ikke bra for en sånn enhet. Dette gjør at man overhodet ikke kan stole på et sånt skifteregister. Så da kommer den siste fiksen som gjør at man får en enhet man kan stole på. Og det er en såkalt D-vippe. Det man gjør da, er at man setter sammen to låser. Dette er Hausser'n Master og Slave. Det er to låser som man... Dette er den endelige enheten som man lagrer på. Men jeg ser klokka er kvart over ni nå, så vi tar en pause der. Og så skal vi se mer på hva som gjør at denne vippen virker som den skal. At vi dermed kan bruke dette som en lagerenhet i en CPU. Og dette er den virkelige lagerenheten i en CPU.", "source": "lecture"}
{"lecture_id": "os3", "chunk_id": "os3_0018", "start": 2634.04, "end": 2707.62, "token_count": 180, "text": "Det man gjør da, er at man setter sammen to låser. Dette er Hausser'n Master og Slave. Det er to låser som man... Dette er den endelige enheten som man lagrer på. Men jeg ser klokka er kvart over ni nå, så vi tar en pause der. Og så skal vi se mer på hva som gjør at denne vippen virker som den skal. At vi dermed kan bruke dette som en lagerenhet i en CPU. Og dette er den virkelige lagerenheten i en CPU. Hvis vi setter sammen 64 sånne, så får vi et 64-bits-register som man har i en CPU. Men vi tar en pause der, og så ser vi på det etter pausen. Skal jeg prøve å stoppe recording her?", "source": "lecture"}
