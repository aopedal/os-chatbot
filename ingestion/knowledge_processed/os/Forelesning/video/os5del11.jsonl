{"lecture_id": "os5del11", "chunk_id": "os5del11_0000", "start": 0.0, "end": 218.68, "token_count": 600, "text": "Jo, jeg har en if-main her. Jeg skal nå prøve å lage en liten rutine som utgjør en if-test. Det jeg tenkte å prøve på, var å skrive den fra scratch i Assembly, sånn at vi kan se litt mer detaljer av hva som foregår. Eller ta det bare sånn. Da kan jeg prøve å starte og lage den if-testen. Ja... Jeg kan kalle den min if fra skillen fra de andre. Det jeg trenger å vite, er at det skal være en ekstern funksjon if-test, så det navnet må jeg ha med. Og da begynner jeg fra scratch. Det jeg trenger å si, er at det er en global... Det definerer den funksjonen jeg skal lage, at den heter det. Sånn at C kan få tak i den. Og så er det en label-if-test. Det er en slags standard måte å starte en funksjon på. Og den koden jeg skal lage... Vi kan se... Ja. Har en... Skal vi se... Den koden ser sånn ut. Jeg kan ta med den... Dette her ønsker jeg nå å lage. Så jeg kan kanskje ta med den inn i koden her, sånn at vi har et utgangspunkt. Sånn at de ser hva vi skal lage. Skal vi kommentere det... Sånn. Så tankene her er bare å illustrere hvordan man kan lage en if-test. Vi har lagd en foreloocker. Og med foreloocker så kan de også lage en vile. Det blir omtrent det samme. Så hvis vi kan lage en if-test nå, så vet vi omtrent hvordan alt som er av kode, lages i maskinkode. Det vi kan starte med, det er altså... Skal vi prøve å få dette til å virke? Det er å ha et lite dataavsnitt. Og der har jeg en variabel som jeg kaller svar. Det er den svar her oppe som er 32. Og da kan jeg si... Ja, jeg kan bruke koden. Sette av... 64 bit. Åtte bytes til en kode som... ja, som inneholder tallet 32. Det definerer den. Og så kan jeg... Bare for å se at dette her virker, så kan jeg bare teste først... Flytt tallet én til rax, og så returner. Da vil jo denne... Den assembly-koden her nå, den gjør da ingenting. Den skal bare returnere én. Jeg tenker bare å gjøre det her nå...", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0001", "start": 168.62, "end": 411.08, "token_count": 578, "text": "Og da kan jeg si... Ja, jeg kan bruke koden. Sette av... 64 bit. Åtte bytes til en kode som... ja, som inneholder tallet 32. Det definerer den. Og så kan jeg... Bare for å se at dette her virker, så kan jeg bare teste først... Flytt tallet én til rax, og så returner. Da vil jo denne... Den assembly-koden her nå, den gjør da ingenting. Den skal bare returnere én. Jeg tenker bare å gjøre det her nå... Først for å se om alt funker. Det kan være smart sånn at... Etterpå, når jeg skriver mer kode, så kan jeg være sikker på at det grunnleggende virker, i hvert fall. Da skal jeg lime den sammen med if main. Så... Den skal sammen med if main. Ja, der fikk jeg en warning... Ja, det er bare en warning. Jeg tror det er bare et linjeskift. Så vi kan se om den kjører. Ja, den kaller gif-test. Og så returnerer den svaret. Så det var en god start. Det var ikke noe linjeskift her, så jeg tror da var det mer. Men da skal jeg prøve å lage kode som lager en if-test. For vi har en variabel svar her, som vi tenker oss er et eller annet tall. Og så skal vi... Den skal, hvis svaret er større enn 42, så skal den returnere 1, og ellers skal den returnere 0. Ja, hva skal vi gjøre da... Jo, vi kan starte med... Det er jo 42 som er liksom tallet vi skal sammenligne med. Så vi kan starte med å legge 42 i et register. Da kan vi bare velge hvilket register vi vil. La oss si jeg bruker RBEX. Så skal jeg nå sammenligne da svaret med dette tallet. Så... Og da må jeg ha en compare. Håper det er litt på egen hånd, det. Jeg skal nå sammenligne RBX og svar. Og det kan rett og slett skrives sånn. En variabel kan bare skrives direkte sånn. Det vil da... Jeg ber nå... Dette er en institusjon som skal sammenligne de bitene som ligger her ute. Jeg sammenligner nå 42 med svar. Og så... så skal jeg hoppe. Da vil jeg hoppe hvis den er større igjen.", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0002", "start": 360.0, "end": 572.8, "token_count": 598, "text": "Håper det er litt på egen hånd, det. Jeg skal nå sammenligne RBX og svar. Og det kan rett og slett skrives sånn. En variabel kan bare skrives direkte sånn. Det vil da... Jeg ber nå... Dette er en institusjon som skal sammenligne de bitene som ligger her ute. Jeg sammenligner nå 42 med svar. Og så... så skal jeg hoppe. Da vil jeg hoppe hvis den er større igjen. Jg, det er jump greater than. Da kan jeg hoppe til et sted hvor det er større. Eller en linje hvor det er \"-greater\". Da husker vi fra simuleringen at da var det en sånn bransjekontroll, og den bransjekontrollen styrte dette her med hopping. Men da må jeg ha et eller annet sted en linje hvor det står -greater. Så her har jeg da en label som heter -greater. Og så vet jeg... Hvis jeg hopper til greater, da er den større enn 42, da skal jeg returnere 1. Og det kan jeg jo få til ved at jeg tar tallet 1, at jeg har en dollar foran når jeg skal skrive tall... Jeg tar tallet 1, og så legger jeg det i rax. For rax, det er det som returnerer sluttverdien. Så da har jeg på en måte den biten riktig. Men... Så må jeg jo prøve å se hva det er som skjer hvis... Altså, jeg skal ha en elsker igjen også. If svarer 42, da skal jeg returnere igjen. Jo, men det jeg rett og slett kan gjøre da, da kan jeg bare gå inn etter jumpgrater. For hvis... Hvis testen slår til, og den er grater, så hopper den til grater. Og hvis ikke, så vil den fortsette å bare utføre koden nedover her. For vi vet at når den ikke hopper, så utføres bare neste kodelinje. Neste kodelinje kan jo da være å putte null i prosent arrives. For da har vi fått til den elskeren. Men da blir det dumt hvis jeg nå hopper... Hvis jeg ikke gjør noe mer nå... Så kan vi se hva som skjer. Men det må jeg ha lenger ned her... Så må jeg ha en return. Og så return sånn. Og det som skjer her nå... Det er da verdi returneres i prosent av hex. Eller... Ja, liksom.", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0003", "start": 510.0, "end": 769.24, "token_count": 598, "text": "For vi vet at når den ikke hopper, så utføres bare neste kodelinje. Neste kodelinje kan jo da være å putte null i prosent arrives. For da har vi fått til den elskeren. Men da blir det dumt hvis jeg nå hopper... Hvis jeg ikke gjør noe mer nå... Så kan vi se hva som skjer. Men det må jeg ha lenger ned her... Så må jeg ha en return. Og så return sånn. Og det som skjer her nå... Det er da verdi returneres i prosent av hex. Eller... Ja, liksom. Så... Vi kan se... Vi kan prøve å se hva som skjer... Når jeg kjører dette her... I dette tilfellet, når jeg har svaret er 32, så skal den jo helst returnere null. Så vi kan prøve å komplere og se hva den returnerer. Da kompilerer jeg den sånn. Men den returnerer svar lik 1. Så det var ikke helt riktig, den koden jeg skrev. Men hva var det som var galt? Du har ikke fjernet den første returen... Kjempebra! Dette her skulle jo ikke med. Så da returnerte den den. Det var derfor den ble retur 1. Veldig bra. Da ser vi igjen. Og så ser vi kanskje for null nå. Nei. Det er fortsatt... ... får jeg svar 1. Er det noen som klarer å se hva som er galt i if-testen min nå? For at... Jeg kommer jo hit. Nei, den skal ikke slå til. Og dermed så skal jeg jo flytte null over RX. Nei, den er ikke lik, fordi jeg sammenligner 42 og 32. Altså... I sammenligningen her så sammenligner jeg RBE. Og svar er 32. Så... det som skjer... Jeg hopper ikke her, fordi den ikke er større. Og så går jeg hit, legger null i RX. Men så fortsetter den bare å gå ned til Grater. Så hvis jeg ikke gjør noe annet, så fortsetter man å kjøre linje for linje. Akkurat som den simuleringen. Og da går den til Grater, og så flytter den én til RX, og så går den til Return. Jo, det jeg må gjøre da, er at her må jeg jo legge inn... Her må jeg legge inn en jump. For jeg flytter null til rax, og da er jeg egentlig ferdig. Så jeg kunne lagt inn en return her,", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0004", "start": 732.44, "end": 941.8, "token_count": 580, "text": "Men så fortsetter den bare å gå ned til Grater. Så hvis jeg ikke gjør noe annet, så fortsetter man å kjøre linje for linje. Akkurat som den simuleringen. Og da går den til Grater, og så flytter den én til RX, og så går den til Return. Jo, det jeg må gjøre da, er at her må jeg jo legge inn... Her må jeg legge inn en jump. For jeg flytter null til rax, og da er jeg egentlig ferdig. Så jeg kunne lagt inn en return her, men jeg kan gjøre det eksplisitt og så se... OK, her vil jeg hoppe til return. Sånn, da. Jump return. Hvis jeg kommer hit, legger jeg null. Og så hopper jeg over greater, sånn at ikke den blir satt. Og det er akkurat det en if-test gjør. Jeg bare sjekker først at det funker. Ja, og da ser vi. Nå returneres svarlig null. Helt riktig. Det var akkurat det jeg må gjøre. Det dere må sitte igjen med av dette, er at her ser vi hvordan en kompulator må tenke. Hvordan en kompulator da kan oversette en if-test som dette her. Her har vi en branching. Her er det en test som utføres. Og det kan alltid oversettes med denne type sammenligninger og jump statement. Det er spørsmål om man kan ha return to steder. Det er jeg ikke sikker på... Jeg kan teste. Da burde det i så fall gjøres sånn. Ja, ser ut som det går fint. Ja. Det går det an å gjøre. Så denne vil utføre det samme, for den returnerer da direkte. Men da må jeg bare dobbeltsjekke. Funker det nå hvis... Hvis svar er større enn 42? Altså hvis svar er 52? Da må jeg kompilere på nytt og så kjøre. Ja. Det ser ut til å funke fint. Og det er liksom... Det er poenget. Nå var svar 52. Og Jg hopp hvis hun er større. Og da hopper den til greater, og så flytter den movien her. Så kunne jeg teste Jg om den faktisk funker. Hvis tallet er 42, så skal den jo ikke hoppe til 1 her oppe. Da skal den returnere 0, så vi kan prøve det til slutt.", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0005", "start": 900.02, "end": 1085.9, "token_count": 597, "text": "Da må jeg kompilere på nytt og så kjøre. Ja. Det ser ut til å funke fint. Og det er liksom... Det er poenget. Nå var svar 52. Og Jg hopp hvis hun er større. Og da hopper den til greater, og så flytter den movien her. Så kunne jeg teste Jg om den faktisk funker. Hvis tallet er 42, så skal den jo ikke hoppe til 1 her oppe. Da skal den returnere 0, så vi kan prøve det til slutt. Ja, da stemmer det. Den returnerer 0. Så den fungerer som den skulle. Så her ser vi hvordan... Hvordan man kan skrive... Dette vil egentlig si at man skriver maskinkode. For her... Assembleren, altså den GCC, når den lager maskinkode av denne, så bare oversetter den linje for linje. Den oversetter der... Move er institusjon nummer 112. Så skriver den 112, og så 42, og så adresse... RBX. Og så kodestøyen, akkurat som i simuleringen jeg har sett på tidligere. Pair blir en linje, dette blir en linje, move blir en linje osv. Så dette blir linje for linje. Det var spørsmål om hvilken verdi som reduseres når det bare står rett, og det er... RAX returneres alltid. Og det er en slags avtale med C-funksjoner. C-funksjoner forventer å få returverdien i RAX. Nei, jeg kan ikke returnere noe som ikke er RAX. Men hvis jeg har en funksjon som... Nei, så jeg må legge den returverdien i RAX. Men hvis du kaller det en funksjon, så har du andre rutiner. Da tar funksjonen imot variabler. Hvis vi har en funksjon som har to int-variabler, men da legges de... Nå husker jeg ikke hva konvensjonen er, men da kan det være sånn at de innkomne variablene legges i rax og rbx, f.eks. Så hele tiden må man ha konvensjoner, sånn at man vet hva funksjonene skal returnere. Men når du først har det, så kan man skrive kode som dette her, og sende variabler frem og tilbake til funksjonen. Men det som er viktig her, er at vi nå på en måte har en idé om", "source": "lecture"}
{"lecture_id": "os5del11", "chunk_id": "os5del11_0006", "start": 1056.08, "end": 1096.98, "token_count": 159, "text": "Nå husker jeg ikke hva konvensjonen er, men da kan det være sånn at de innkomne variablene legges i rax og rbx, f.eks. Så hele tiden må man ha konvensjoner, sånn at man vet hva funksjonene skal returnere. Men når du først har det, så kan man skrive kode som dette her, og sende variabler frem og tilbake til funksjonen. Men det som er viktig her, er at vi nå på en måte har en idé om hvordan enhver sånn konstruksjon som dette her, en forløkke eller en gif-test... Hvordan den produseres i maskinen.", "source": "lecture"}
