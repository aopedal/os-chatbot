{"lecture_id": "os14time2", "chunk_id": "os14time2_0000", "start": 0.0, "end": 271.32, "token_count": 579, "text": "Sånn. Der er vi i gang med recording. Ja... Dette er noe vi kommer tilbake til i neste uke i mer detalj. Men det kan være greit å ha det helt klart for seg. Og det kan være litt forvillende noen ganger også. Mange ganger 8K. Sånn som det der. Og strengt tatt definisjonen på K, altså i si-enheter... Skal vi se... Si-enheter er de som definerer kilo og alt mulig sånt. Så er egentlig K lik 1000, sånn som her. M er da ti i sjette, G er milliard, eller ti i niende. Men når vi snakker om Bite, så er det naturlig å snakke om det... I PowerA2. Og det... Det vi ofte gjør da, er at vi sier K er lik... Er lik 2 oppe i tiende? Så to i tiende bite. Men det er jo lik 1024.  Og pga. den lille forskjellen der, så er det noen som har prøvd å innføre, det har ikke helt lykkes, men at ki er lik to i tiende. Da vil du se at det står kib for kilobite. Er da eksakt lik 1024 byte. Så der kan det være en sånn liten forskjell. Men når jeg snakker om 8K, så når det gjelder ram, så betyr det 1024... Så tenker jeg på 1024 når jeg sier K. Men strengt tatt burde jeg sagt key. Og tilsvarende så har du da MIB. Som da er lik 1024 ganger 1024 bites. Eller ikke to i tiende, men to i tyvende. Men det 32 er tilnærmet lik 10 niende. Men... Eller en milliardbite. Eller det vi kaller for en gigabyte. Men når du begynner å komme her, så har den faktoren 1024 litt å si. Så da kan det begynne å bli litt forskjeller, spesielt når du kommer opp i terabyte. Men vi kan se på det senere. Men uansett så er akkurat det viktig å ha med seg. Ok. Da skal vi... ... se på nok et konkret eksempel på interne mine. Og vi skal se på noe som virker ganske rart i utgangspunktet. Vi starter ut med et lite og enkelt program.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0001", "start": 223.6, "end": 424.54, "token_count": 594, "text": "Men når du begynner å komme her, så har den faktoren 1024 litt å si. Så da kan det begynne å bli litt forskjeller, spesielt når du kommer opp i terabyte. Men vi kan se på det senere. Men uansett så er akkurat det viktig å ha med seg. Ok. Da skal vi... ... se på nok et konkret eksempel på interne mine. Og vi skal se på noe som virker ganske rart i utgangspunktet. Vi starter ut med et lite og enkelt program. Det eneste som ikke er så enkelt, er at det er veldig mange nuller her. Skulle kanskje brukt den definerte med ganger osv., sånn som vi gjorde i det andre programmet. Men hvis jeg holder på de nullene her, så ser vi at her er det... Så det er 1024 millioner. Så dette er da én milliard... eller én giga. Så det jeg prøver å definere her nå, er et... Eller det jeg definerer her, er et RAI som da bruker fire gigabyte ramme. Et svært RAI. Og så ser vi om jeg har en enkel... En liten fåløkke. Den er enkel, og den går ikke helt opp, men den går til 10 millioner. Så vi ser at jeg bruker da en hundredel av det store R-øyet. Eller går opp til en hundredel. Dette ser litt rart ut foreløpig, men bare tenk på det som en institusjon som vi ikke bruker. Vi setter J lik I gang i 100. Så den J-en går helt. Men i første omgang, det jeg gjør, er at jeg setter nå hvert ri lik i. Så jeg begynner med ri av 0 og setter den ned lik 0. ri av 1 lik 1, ri av 2 lik 2, osv. oppover. Så det er jo... ja. Dette er bare en demo på hva som skjer når man bruker ramm. Og da, hvis vi gjorde sånn som vi gjorde før pause, at vi så på topp som vi gjorde før pause... Så ville vi sett at etter hvert som man brukte det jeg er i, så ville det komme inn i RES osv. Men nå skal jeg bare kompilere programmet. Det heter MDC. Og så ta tiden på å kjøre. Skriver man til 1 million RAI-elementer, altså 10 millioner, så går det på 0,02 sekunder.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0002", "start": 370.32, "end": 570.88, "token_count": 582, "text": "Så det er jo... ja. Dette er bare en demo på hva som skjer når man bruker ramm. Og da, hvis vi gjorde sånn som vi gjorde før pause, at vi så på topp som vi gjorde før pause... Så ville vi sett at etter hvert som man brukte det jeg er i, så ville det komme inn i RES osv. Men nå skal jeg bare kompilere programmet. Det heter MDC. Og så ta tiden på å kjøre. Skriver man til 1 million RAI-elementer, altså 10 millioner, så går det på 0,02 sekunder. Selv om man sier at RAM er tregt, så går det jo veldig fort. Mye raskere enn til disk. Det er bare det at registeret er enda raskere, så der er det ekstremt raskt. Men i hvert fall - dette går fort. Men så skal jeg gjøre det som er litt spesielt. Endre i til j her. Det er den eneste endringen jeg gjør. Jeg bytter nå i ut med j. Det vil si at jeg gjør jo akkurat like mange instruksjoner. For det er ti millioner ganger som jeg løper gjennom her. Så den eneste forskjellen er at det første jeg gjør, er jeg av null lik null. Så er jeg av... Når i er lik 1, så vil j bli 100. Så neste institusjon er ra 100 lik 1. Og så ra 200 lik 2 osv. Men jeg gjør dette da 10 millioner ganger. Så i utgangspunktet... I hvert fall hvis ram var ram, så burde dette ta akkurat like lang tid. Men vi ser dette tar enormt mye lengre tid. Det tar 1,5 sekunder i stedet for 0,19. Altså... Dette er faktisk nesten en faktor 100. Så hvordan kan det ha seg? Er det noen som har noen idé om hva det kan skyldes? Veldig stor forskjell i effektivitet. Vi gjør det samme antall institusjoner. Ti millioner ganger så skriver vi noe til et RI-ram. Fyller opp programmet med tall. Ti millioner ganger. Helt det samme hver gang. Vel... Vi har snakket med om cash, og dette er absolutt noe som har med cash å gjøre. Ja, det er forslaget at det er på grunn av r-øyet.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0003", "start": 518.74, "end": 808.6, "token_count": 588, "text": "Så hvordan kan det ha seg? Er det noen som har noen idé om hva det kan skyldes? Veldig stor forskjell i effektivitet. Vi gjør det samme antall institusjoner. Ti millioner ganger så skriver vi noe til et RI-ram. Fyller opp programmet med tall. Ti millioner ganger. Helt det samme hver gang. Vel... Vi har snakket med om cash, og dette er absolutt noe som har med cash å gjøre. Ja, det er forslaget at det er på grunn av r-øyet. Ja, det er på grunn av r-øyet, og vi må prøve å tenke oss... Hva er det som... Hva er det egentlig som skjer her? Dette er et viktig poeng, så jeg tenker vi kan bruke litt tid på det. Kanskje jeg skal prøve å tegne... Jo, vi har et ærei. Og det... Dette ville da være logiske eller virtuelle adresser. Men de ville mappes over, avbildes på fysisk R-øye, ram, og da ligger de etter hverandre. Og det vi gjorde i det første programmet, det var å legge inn sånn... 0, 1, 2, 3, 4, 5 osv. Og da ser vi... Kanskje vi kom ned til 100 her nå? Eller vi kom egentlig mye lenger. Vi kom ned til faktisk 10 millioner. Vi kan ta med masse nuller der. Ti millioner... Kjempestort ære. Men likevel så må vi huske på at dette var bare én av de hundre sånne som vi hadde bortover. Hvis vi tenker oss at RAM bare fortsetter sånn, ned dit, O, ned dit, osv.... Her oppe hadde vi 10 millioner og 1... Og her så hadde vi plassnummer 20 millioner. Den lå her nede. Og så hadde vi 100 sånne bortover. For vi har 100 ganger så mye som 10 millioner. Det vi gjorde i det første programmet, det var bare å fylle opp. Det var... prog 1. Men så... Hva gjorde vi i prog 2? Jo, da så vi at vi fikk en faktor 100. Så hvis jeg prøver å skrive prog 2 med rødt der... Så i prog 2 så la vi fortsatt J lik 1. Så la vi... Fortsatt la vi 0 inn her.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0004", "start": 767.96, "end": 1004.28, "token_count": 592, "text": "For vi har 100 ganger så mye som 10 millioner. Det vi gjorde i det første programmet, det var bare å fylle opp. Det var... prog 1. Men så... Hva gjorde vi i prog 2? Jo, da så vi at vi fikk en faktor 100. Så hvis jeg prøver å skrive prog 2 med rødt der... Så i prog 2 så la vi fortsatt J lik 1. Så la vi... Fortsatt la vi 0 inn her. Men så begynte vi å legge inn her, i 100. Så la vi 1. Og så lenger ned her. 200. Så la vi 2. Og så fortsetter vi sånn nedover. Men da begynte vi å legge inn her også. Når vi kommer opp i over 10... over 10 millioner... Kanskje vi fikk da... Ja, her nede så la vi inn... I 20 millioner så la vi vel inn noe sånt som 200 millioner. Men håppoenget er at vi da legger over alt i ramm. Nå fyller vi ut hele det herreiet. Og så legger vi i den andre kjøringen. Altså når jeg hadde prog 2 var array av J lik I. Det var prog 2. Prog 1 var... Var... Jodligi. Da bare la vi nedover her. Jodligi, da økes... Det er da produkt O. Da økes jod med 100 for hver gang. Sånn at vi legger data utover i hele jordeiet, og totalt sett så var... Hele dette var på 4G. Så svært ærlig. Men da kommer vi til løsningen på dette. Ja, det er noen som kommer med et forslag her. Du må ut til Ramm og hente en ny del av RAM hver gang. Ja, det er riktig. Eller riktignok nå skriver vi til Ramm. Og skrive ut til Ramm. Men... Ja, og da, når du legger inn tall på alle plassene, kan du legge inn flere tall før den må ut igjen. Jo, men problemet... Da er jeg ikke helt sikker på om jeg forstår deg riktig. Men en skulle på en måte tro at... Det var... For å si det på en annen måte... Hvis dette var ramm i ordets rette betydning, random access memory, så skal det gå like raskt å skrive noe hit som å skrive noe dit. Eller hvor som helst i ramm.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0005", "start": 953.56, "end": 1153.64, "token_count": 592, "text": "Men... Ja, og da, når du legger inn tall på alle plassene, kan du legge inn flere tall før den må ut igjen. Jo, men problemet... Da er jeg ikke helt sikker på om jeg forstår deg riktig. Men en skulle på en måte tro at... Det var... For å si det på en annen måte... Hvis dette var ramm i ordets rette betydning, random access memory, så skal det gå like raskt å skrive noe hit som å skrive noe dit. Eller hvor som helst i ramm. Så du er inne på noe der når du sier hvis du går... På alle plassene. På én gang. Må systemet kanskje flushe cashen? Ja, men det er akkurat dette som er... Akkurat det er poenget. Cashen må flushes. Altså... Når du legger alle etter hverandre på denne måten her... Så det systemet vil gjøre da, det vil ta... Den vil ikke skrive én og én bite ut. Den vil ikke legge hver bite... Den vil ta hele... Litt avhengig av hvor stor LN Cash er. Kanskje det er plass til 200 bite i LN Cash. Så tar den hele den biten der og legger ut i LN Cash. Den kan ta hele biten etter hverandre, for den biten skal ligge på samme sted i RAM. Og da kan man ta hele biter og skrive ut. Eller hvis man leser, så leser man ikke én bite, men man leser fra RAM. Først fyller man opp hele EltreCash, så El2Cash og så L1Cash. Men hovedpoenget er at når de ligger etter hverandre, så kan de i sin helhet legges ut i L1Cash. Så kan du ta mange hundre bite av gangen. Og som vi ser, så går det 100 ganger så fort. Derimot, når vi prøver å kjøre program 2, så ser vi... Disse er spredt med 100 bite imellom. Så kanskje det er bare noen få bite som da treffer med hver gang L1 cash kjøres. Og noen flere treffer med L2, enda flere med L3, men du får ikke plass til alt. Så dette vil ta veldig mye lengre tid. Og vi ser det tar nesten 100 ganger så lang tid med Prog2. Og vi kan... Vi kan se litt mer i detalj på det. For vi har da et program som heter Perf.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0006", "start": 1114.7, "end": 1302.6, "token_count": 594, "text": "Disse er spredt med 100 bite imellom. Så kanskje det er bare noen få bite som da treffer med hver gang L1 cash kjøres. Og noen flere treffer med L2, enda flere med L3, men du får ikke plass til alt. Så dette vil ta veldig mye lengre tid. Og vi ser det tar nesten 100 ganger så lang tid med Prog2. Og vi kan... Vi kan se litt mer i detalj på det. For vi har da et program som heter Perf. Som jeg kan bruke til å se nøyaktig hva som skjer når jeg kjører programmet. Den enkleste versjonen først. Sette i den som går raskest. Her ligger det pent etter hverandre, så dette kan pusses i store biter ut i cash. Da går det kjapt. Det er den der. 0,02 sekunder. Men så kan jeg kjøre en... Altså, jeg har kjørt den før. Det er en kommando som heter perf, og den gir statistikk med antall... Her er jeg bedt eksplisitt om å skrive ut antall sykler, antall instruksjoner, antall cash references. Det er hvor mange ganger du har en cash-referanse. Hvor mange ganger du henter ut noe for cash. Ikke minst cash misses. Major faults og minor faults. Major faults, det er når man må... Ut på disken og hente. Og det skjer ikke her. Det er når du får en virkelig page fault. Minor faults, det er når man må... Når man ikke har lagd en side i MMU. Og det skal vi se, det må vi gjøre ganske ofte. Jeg kjører den først. Og da får vi statistikken for dette programmet. Igjen ser vi det går lynrask. 0,02 sekunder. Likevel ser vi... Den utfører 63 millioner sykler. Og gjør 71 millioner instruksjoner. Men omtrent da en instruksjon per sekund. Så ser vi... Cash misses. Ja, den bommer ganske ofte på cash. Og det er fordi at den nå tar ut bit for bit. Men ganske ofte så må den hoppe videre til... Til neste del av cashen. Den må fylle ut cash på nytt. Men fordelen når de ligger etter hverandre, er at den fyller hele cashen av gangen med elementene som ligger etter hverandre. Men vi ser her minor falts. 10 000 minor falts.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0007", "start": 1259.06, "end": 1452.48, "token_count": 590, "text": "Men omtrent da en instruksjon per sekund. Så ser vi... Cash misses. Ja, den bommer ganske ofte på cash. Og det er fordi at den nå tar ut bit for bit. Men ganske ofte så må den hoppe videre til... Til neste del av cashen. Den må fylle ut cash på nytt. Men fordelen når de ligger etter hverandre, er at den fyller hele cashen av gangen med elementene som ligger etter hverandre. Men vi ser her minor falts. 10 000 minor falts. Og det passer ganske bra med... Hvis det er 10K. På 1000 bytes. Vanligvis er den på 4K, så det går ikke helt opp. Men dette er omtrent 10 000 K. Og vi ser at vi får 10 000 minor folts. Og det er fordi at man... En minor folts er når man ikke har referert til denne delen av minnet. Og da lages det en adressering i MMU. Det gjøres 10 000 ganger. Så det tar også litt tid. Men alt i alt så går dette lynraskt. Så prøver vi å sette J1. Nei, vi setter inn ra av J. Og da hopper vi rundt i 4 GB. Og dette tar da mye lengre tid. Komplerer... Og kjører det samme. Og nå ser vi... Nå får vi først og fremst så får vi... Vi burde egentlig kunne sammenligne... Sånn, ja. Nå ser vi det tar 1,6 sekunder. Mye lengre tid. Og det er opplagt mange flere cycles. Og vi ser vi har veldig mange flere cash references og nesten alle bommer. Jeg har på en måte konstruert dette sånn at... Sånn at det skal bomme. Vi hopper med 100 hver gang. Det er veldig uvanlig at man gjør det på denne måten her. Men dette er bare for å illustrere hvordan cash virker, at det er viktig å være klar over det. Så vi får 75 millioner cash misses i stedet for 800 000 her oppe. Det er først og fremst det som gjør at det tar mye lengre tid. Det tar også tid å bygge opp MMU. For her ser vi... Her trengs det 1 million sider. For vi... Det r-øyet er på 4 g. 4 gigabyte. Og med en sidestørrelse på 4K...", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0008", "start": 1412.7, "end": 1656.68, "token_count": 596, "text": "at det er viktig å være klar over det. Så vi får 75 millioner cash misses i stedet for 800 000 her oppe. Det er først og fremst det som gjør at det tar mye lengre tid. Det tar også tid å bygge opp MMU. For her ser vi... Her trengs det 1 million sider. For vi... Det r-øyet er på 4 g. 4 gigabyte. Og med en sidestørrelse på 4K... Så så trenger man 1 million sider. Ja, så det går pent opp. Jeg glemte det... At en integer er på fire. Så dette, det tilsvarer da fire ganger ti millioner bite. Så i det første tilfellet så trengte vi bare 10 000 sider i MMU. Men her trenger vi én million sider for å kunne adressere... Og dette tar også mye tid å bygge opp NMU. Og da ser vi at det er oppe i 1,6 sekunder. Det kan vi også se på... ... Så kan vi se på hva tiden går bort til. Vi ser user. Det er 0,4. Men veldig mye brukes av system. Og det er da for å bygge opp MMU-sidene. Så det er også en faktor her. Så det er ikke bare cash, men det er også det at du må bygge opp MMU. Hvis vi nå kjører... Jeg ser på det samme med Adatat. Så ser vi... Jo, det er en andel system her også. Som er ganske stor. Den er faktisk litt større. For her også må de sidene bygges opp. Men altså, i begge tilfeller så ser vi at kjernen er inne og hjelper til med å bygge opp, da i dette tilfellet, 1 million pages. Og det tar litt tid. Cash misses i Prog1? Jo, det skyldes at... Tross alt, selv om man går etter hverandre, så går man veldig langt. Her så ser vi det er 10 millioner... 10 millioner bite, eller da 10 000 kilobite. Og hvis du regner med Int, så er det da 40 000 kB. Og det krever jo da... Det krever at man lager de 10 000 sidene her oppe. Men spørsmålet var kanskje hvorfor det var så mange catchmines som 801? Jo... Cash er da mindre enn 4K, så selv om du... Selv om du treffer veldig ofte,", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0009", "start": 1592.12, "end": 1839.86, "token_count": 588, "text": "Her så ser vi det er 10 millioner... 10 millioner bite, eller da 10 000 kilobite. Og hvis du regner med Int, så er det da 40 000 kB. Og det krever jo da... Det krever at man lager de 10 000 sidene her oppe. Men spørsmålet var kanskje hvorfor det var så mange catchmines som 801? Jo... Cash er da mindre enn 4K, så selv om du... Selv om du treffer veldig ofte, så er det jo med en gang du kommer utenfor i første omgang LN-cash-størrelsen. Så vil du måtte hoppe over på... En cash måtte reflushes. Og den vil da reflushes 800 000 ganger når det går oppover. Først med opptil 100, men du ser du skal helt opp til 10 millioner. Så derfor vil du ha flere cash misses enn der det er pages. Ok. Vi skal se på ett eksempel til før vi gir oss i dag. Vi skal bare se på internen min i dag, og så ser vi på disk neste gang. Skal vi se... Da skal vi se på... Nei, da må jeg finne fram her. Matt skal vi se på. Vi skal nå se på... ... dette programmet, som skriver til et RAI. Og noe av det som er viktig å vite her nå, er hvordan et RAI eller... Et todimensjonalt RAI, eller en matrise, hvordan den lagres i ramm. Ofte bruker man matriser sånn som dette her, RABA, med to indekser. For å lagre data. I maskinlæring og AI, f.eks., har man ofte sånne store matriser som dette her. Da er det viktig å vite hvordan et RA er organisert. For det er på en måte et valg når du har to indekser. Hvordan skal de ligge etter hverandre i ramm? Og da har jeg skrevet opp fasit. For C her nede... Det kan i prinsippet være organisert av forskjellige kompulatorer for forskjellige språk. Men for C så er det sånn at ra00 ligger rett før ra01 og r02. Så... Ja, dette er litt viktig for hele problemstillingen. Så jeg tenker vi skal... Vi kan prøve å tegne opp det også. Så hvis jeg kaller bare reiet A... Jeg har A, A, A... B. Sånn som det der.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0010", "start": 1790.56, "end": 2016.76, "token_count": 595, "text": "For C her nede... Det kan i prinsippet være organisert av forskjellige kompulatorer for forskjellige språk. Men for C så er det sånn at ra00 ligger rett før ra01 og r02. Så... Ja, dette er litt viktig for hele problemstillingen. Så jeg tenker vi skal... Vi kan prøve å tegne opp det også. Så hvis jeg kaller bare reiet A... Jeg har A, A, A... B. Sånn som det der. Og så har vi ram nedover her. Og da er det et velgør. De viktige poengene når vi skal kjøre dette, er at A av 00... Det er første element. Det ligger her. Og så kommer A av 01. Og så kommer A av 02. Og så videre nedover. Helt til vi kommer til å ha fylt opp første delen av r-øyet. Så kommer vi til AA1. Så kommer A av 1, 1 og så videre. Og så fortsetter den nedover i ramma. Og så kommer A av 2. Og så videre i det uendelige. Og her ser vi med en gang at her kan det bli noe trøbbel, eller noen forskjeller med hensyn på cash. For det er klart... Hvis vi skriver ut på denne måten av null først, og løper gjennom 1-2-3, 0-1-2, sånn, så vil det treffe bra med cash. For da vil hele den biten sendes ut i cash. Det er det vi nå skal se på. Og da ser vi... Skal vi se hvordan jeg gjør det her... I det eksempelet her... Så ser vi at... Ja, jeg har B, A... Kanskje jeg kan prøve å gjøre det sånn? Sette A først. For da... La oss si jeg skal prøve å få det til å gå så fort som mulig nå. A lik 0. Da er det den ytre forløkken der. Og da starter jeg på A av 0, og da vil jeg få A av 0, A av 0, A av 01 osv. Så denne måten burde være den raskeste. Men da prøver vi. Kompilerer og kjører. Ja... Jeg kan se om det er noen forskjell å komplere med stor O. På mer effektivt gode. Jo, det går fortere. Ikke tenk på at jeg bruker stor O når jeg skal komplere etterpå", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0011", "start": 1970.56, "end": 2186.0, "token_count": 591, "text": "Da er det den ytre forløkken der. Og da starter jeg på A av 0, og da vil jeg få A av 0, A av 0, A av 01 osv. Så denne måten burde være den raskeste. Men da prøver vi. Kompilerer og kjører. Ja... Jeg kan se om det er noen forskjell å komplere med stor O. På mer effektivt gode. Jo, det går fortere. Ikke tenk på at jeg bruker stor O når jeg skal komplere etterpå med den andre måten. Så bruker jeg fortsatt stor O. Og vi ser... Det går på 0,75 sekunder. Men så kan jeg prøve. Og det er opplagt... Det er det samme jeg gjør hver gang. Jeg bare løper gjennom på litt forskjellige måter. Totalt sett så vil programmet gjøre akkurat det samme. Men da ser vi... Dette programmet, som gjør nok til det samme, det går... Ca. 8... Det bruker 8 ganger så lang tid. Og det er akkurat den effekten som vi da forutsa. Her i det første programmet så tok vi og skrev til Errøya på denne måten. Vi skrev ut hvert element som da ligger etter hverandre pent og pyntelig i ramm. Og det kan kjøres i hele bolker i cash og sendes av gårde. På klasseforsøk så gjorde vi da noen enorme hopp fordi at vi måtte hoppe fra... Først skrev vi A00, og så skrev vi AA10. Og da måtte vi gjøre et svært hopp i ram herfra og hit, som var på 20 000. Og dermed ble det totalt cash miss. Og det kan vi da også se hvis du kjører perf på dette her. Heter det fortsatt Out og Out, så vi kjører perf på det andre forsøket. Og her ser vi... masse minor folts. Minner bare bygges opp. Det er kanskje ikke så forskjellig, men det er vel først og fremst cash misses som blir forskjellen her. Endre til det vi trodde var det beste. AB. Komplør på nytt. Og kjøre perf. Ja, da ser vi. Minor folds ble det samme. For i dette tilfellet bruker vi jo akkurat like stor del av ramm. Det blir det samme. Så det gir ikke noe stor tidsforskjell.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0012", "start": 2131.22, "end": 2342.76, "token_count": 585, "text": "Og her ser vi... masse minor folts. Minner bare bygges opp. Det er kanskje ikke så forskjellig, men det er vel først og fremst cash misses som blir forskjellen her. Endre til det vi trodde var det beste. AB. Komplør på nytt. Og kjøre perf. Ja, da ser vi. Minor folds ble det samme. For i dette tilfellet bruker vi jo akkurat like stor del av ramm. Det blir det samme. Så det gir ikke noe stor tidsforskjell. Men her ser vi på cash misses. Her er det en stor forskjell. Her er det 29 millioner cash misses, så det er en god del. Men her oppe så ser vi... Dette tar tid, for det er 700 millioner cash misses. Cash-referanser... Altså der hvor du i det hele tatt refererer til cash. Og igjen så ser vi at det er en... Her er det først og fremst en enorm forskjell i cash-bruken. Vi gjør akkurat det samme, men vi henter det fra et annet sted. Vi kunne også lurt på... Har det noe med at man bare legger ut fem? Det vi kunne gjøre, var for å gjøre det veldig eksplisitt, så kunne vi prøve å legge ut. Hva om vi legger ut A pluss B? Blir det noe særlig forskjell da? Og blir det noen annen forskjell på programmene? Vi ser... Ja, det tok litt lengre tid. Men vi ser i Cashmisses, så... Så er det ikke noe forskjell. For det er... Du gjør det samme. Kanskje hun gjorde et smart triks med at det ligger et tall 5 i hele cash, sånn at man bare hiver det ut. Men vi ser, selv når vi legger forskjellige tall, så er forskjellene samme. Og vi får den samme forskjellen... Med at det tar mye lengre tid... Og vi får omtrent det samme antall cash misses uansett. Så det at vi la ut det femtallet, hadde ingen betydning. Den store forskjellen var at i det ene tilfellet så måtte vi hoppe langt i ramm. Og det passer dårlig med cash. I det andre tilfellet så lå alle dataene pent etter hverandre når vi skrev det ut. Jeg skal prøve å oppsummere RAM med noen minnebegreper som er viktige.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0013", "start": 2295.8, "end": 2491.92, "token_count": 588, "text": "Med at det tar mye lengre tid... Og vi får omtrent det samme antall cash misses uansett. Så det at vi la ut det femtallet, hadde ingen betydning. Den store forskjellen var at i det ene tilfellet så måtte vi hoppe langt i ramm. Og det passer dårlig med cash. I det andre tilfellet så lå alle dataene pent etter hverandre når vi skrev det ut. Jeg skal prøve å oppsummere RAM med noen minnebegreper som er viktige. Den første er soft miss. Og det er en miss når pagereferansen ikke er i TLB. Og så har vi en hard miss, eller det som er mer vanlig å kalle en major fault eller en page fault. Da er det en side som mangler i ram, altså i minnet, og også da selvfølgelig i TLB. TLB er cash for minnereferanser, og den må hentes helt ut på disk. Og så en major fault. En minor fault, det er når det mangler en side i pagetabellen. Da må du ikke ut på disk og hente den, men den må lages. Vi så det ta litt tid. I det ene tilfellet så vi at vi skulle lage en million sider. Så da var det en én million minor faults. Og selv om det går raskt, alt skjer bare i ram og MMU, så... Så tar det litt tid. En dirty page, det er en side som har blitt endret, slik at... Hvis du da skal skrive ut den til disk, så må den ut av... Hvis den skal ut av minnet og ut på disk, så må den faktisk skrives ut. Hvis en side ikke er dirty, altså hvis den er akkurat som før, så kan man bare droppe den i rammen, for da ligger den allerede på såpeområdet på disken. Working set er et Windows-begrep som betyr så å si akkurat det samme som Ress, eller Resident, i Linux. Det er da de sidene som er i bruk, og som har vært i bruk nylig, og som ligger aktive der. Et segment vi har brukt noen ganger tidligere, det er da en hel logisk del av et programsminne. Sånn som hele programteksten eller hele tag-segmentet. Eller heap, og altså et stort segment. Til slutt buffer cash. Det høres ut som det har noe med L1 og L2 cash osv.,", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0014", "start": 2457.32, "end": 2670.16, "token_count": 595, "text": "eller Resident, i Linux. Det er da de sidene som er i bruk, og som har vært i bruk nylig, og som ligger aktive der. Et segment vi har brukt noen ganger tidligere, det er da en hel logisk del av et programsminne. Sånn som hele programteksten eller hele tag-segmentet. Eller heap, og altså et stort segment. Til slutt buffer cash. Det høres ut som det har noe med L1 og L2 cash osv., men det er da, som vi så, et filsystem-cash. Så det er noen av de viktige minnebegrepene som dere må huske. Ok... Jeg ser... Da skal vi slutte. Men før vi slutter, skal jeg oppsummere noen spørsmål. Ja, det var et godt poeng. Det var en som la merke til at det var mange context switcher. Så spørsmålet om den var nedprioritert på noen måte... Ja, det er et godt spørsmål. For det første så kjører den seks ganger lenger. Det er ikke så rart at det blir flere kontekst-witcher, men det er jo litt påfallende at det blir så mange. Det er ikke noen god forklaring på det annet enn at kontekst-witcher vil skje når det er andre prosesser som kjører på samme CPU. Så det vil alltid være litt tilfeldig. Men kanskje det kan være at den siden den prosessen her... ... venter så mye, siden det er så mange cash misses, at den oftere blir tatt ut av ready-list og oftere må bytte. Men vi kan jo se... Prøv å kjøre den noen flere ganger. Ja, så ser vi... Det var den samme adotat, og denne gang ble det Så det er nok... Den laptopen kjøres ganske hardt med OBS og med Zoom. Så det virket veldig som... Å, vi ser ikke koden! Sorry. Det er en lang dag. Begynne på nytt. Da får dere holde ut litt til. Der... Da hopper vi tilbake. Det var et godt poeng her om... Først så kjørte jeg den raske versjonen, 0,9 sekunder, som tok matrissen på riktig måte. Da fikk jeg bare én kontekst-witch. Og så er det spørsmål... Hvorfor fikk jeg 204 kontekst-witcher her? Og det første man kan si, er at programmet kjører seks ganger så lenge.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0015", "start": 2630.56, "end": 2823.48, "token_count": 591, "text": "Der... Da hopper vi tilbake. Det var et godt poeng her om... Først så kjørte jeg den raske versjonen, 0,9 sekunder, som tok matrissen på riktig måte. Da fikk jeg bare én kontekst-witch. Og så er det spørsmål... Hvorfor fikk jeg 204 kontekst-witcher her? Og det første man kan si, er at programmet kjører seks ganger så lenge. Så da burde det naturlig være flere kontekst-witcher. Kontekst-witcher skjer når man... Når flere prosesser kjører på samme CPU, og her konkurrerer de bl.a. med OBS og med Zoom, og de kjører en masse prosesser. En gang iblant. Men så prøvde jeg å kjøre programmet om igjen. Og da fikk jeg åtte kontekst-witcher og seks kontekst-witcher. Så vi ser at det... Det var nok litt tilfeldig at det ble så veldig mange akkurat der. Der ble det tolv. Mens hvis jeg... kjører på nytt den raske, så ser vi også at det er noen kontekst-witcher. Men jeg tror da som sagt at det var litt tilfeldig at det ble veldig mange context switcher. Jeg kjører et par ganger til. Ja, der var det oppe i 95. Men context switcher er jo da noe man ikke kan forutsi. Det vil variere fra gang. Og det vil jo også... Det er jo et poeng at det kan ta lengre tid hvis det er mange context sitcher, for da blir cash ødelagt for den prosessen. Så vi kan se om det... Det ser ut som det er noe forskjell på hvor lang tid det tar når det er mange context sitcher. Skal vi se... I det tilfellet overtok her oppe... Du kan kanskje se en antydning. 5,46 sekunder. De kontekst-switchene tar jo litt ekstra tid, men i tillegg vil du da ødelegge cash, sånn at det tar litt ekstra tid. Men i det tilfellet så ødelegger jo programmet cash for seg selv hele tiden. Men alt i alt, som svar på spørsmålet... Det var nok tilfeldig at det var så veldig mange. Antall kontekstsituasjoner varierer veldig med hvor mange andre prosesser som kjører. Så det er litt tilfeldig dette inn i bildet.", "source": "lecture"}
{"lecture_id": "os14time2", "chunk_id": "os14time2_0016", "start": 2794.28, "end": 2965.8, "token_count": 502, "text": "men i tillegg vil du da ødelegge cash, sånn at det tar litt ekstra tid. Men i det tilfellet så ødelegger jo programmet cash for seg selv hele tiden. Men alt i alt, som svar på spørsmålet... Det var nok tilfeldig at det var så veldig mange. Antall kontekstsituasjoner varierer veldig med hvor mange andre prosesser som kjører. Så det er litt tilfeldig dette inn i bildet. Så jeg tror først og fremst at når en kjører lenger, så er det flere kontekster. Ok. Da stopper vi der i hvert fall. Så skal jeg lage... I rekke... Et siste spørsmål! Det var... Eller tar et siste spørsmål. Det var filsystemcash, hva det var for noe. Jo, filsystemcash, det er rett og slett at man tar... I stedet for å lese bit for bit av en fil. La oss si jeg ønsker å... La oss si jeg gjør dette her. Og leser den biten der. Det Linux gjør neste gang jeg skal lese den filen... Så går det lynraskt, for da har Linux brukt ram og lagt hele filen inn i ram. Så hele filen ligger da i ram. Spesielt hvis det er en stor fil. 4 GB fil. Og hele ligger i ram, så går det lynraskt å hente ut deler av den fila i forhold til ovnen ligger på disk. Så det er det filsystem-cash er. Den bruker da ram som cash mellom... Ja, på en måte mellom ram og disken. Skal vi se om vi ikke har noen... Nei, det har jeg ikke. Men det er det, altså. På samme måte som cash, L1 og L2 og Eltre cash, ligger mellom registrene og ram, så kan du se at filsystem-cashen ligger mellom disken og Osepun. Sånn at det som ligger i filen, kommer raskere inn. Og behandle seg. Ok. Da skal jeg stoppe recording.", "source": "lecture"}
