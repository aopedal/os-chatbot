{"lecture_id": "os12del6", "chunk_id": "os12del6_0000", "start": 0.0, "end": 188.36, "token_count": 586, "text": "Her er et lite Linux-eksempel på... Som viser den i et annet tilfelle hvor man bruker en lås. Og det ligner på lokk og Mutex, dette også. Og det er en teknikk man ofte bruker for å si ifra at... Denne filen. Ingen aner om å bruke den. Og i SendMail, som er Linux-mailprogram, så gjøres det ved at man lager en lokk per bruker. Så hvis man driver og leser og skriver e-post til denne brukeren... For alle e-postene i SendMail, det er bare en stor fil med e-poster. Og hvis man får e-post eller gjør noen endringer på den filen... Så lager Linux-systemet en sånn lokkfil. Og det sørger da for at andre prosesser ikke endrer på innboksen. Men det er klart, da må alle prosesser som skal endre på denne filen... Altså på... Ikke på lokkfilen, men på innholdet i mailen... Det er en annen fil, som kanskje heter Varmail Haugerud i dette tilfellet. Så sjekker da bare prosessene. Nei, hvis den ikke finnes, OK, da kan jeg gjøre endringer. Men hvis den finnes, så må prosessen da så vente. Og den kan gjøre å stå i en venteløkke og sjekke om og om igjen om denne filen finnes, og så gå inn hvis den ikke finnes. Så det er et enkelt eksempel på en lokk. Men vi skal se at et sånt system er ikke helt bombesikkert. For igjen så kan du få trøbbel med contact switcher. I Windows har vi akkurat den samme problemstillingen. Og bind 32 av PI har to funksjonskall, enter critical section og leave critical section, som er da igjen et tilbud til programmerere å lage kritiske avsnitt. Og disse funksjonskallene vil da sørge for at etter enter critical section... Så vil ingen andre prosesser, heller ikke på andre CPU-er, vil endre på de felles variablene. Det som typisk er felles, det ligger i ramm. Så igjen så vil disse funksjonskallene låse av bussen, sånn at man har enerett på å endre de områdene av ramm som man ser på. Dette forsinker alle jobber som kjører i parallell.", "source": "lecture"}
{"lecture_id": "os12del6", "chunk_id": "os12del6_0001", "start": 142.6, "end": 202.0, "token_count": 200, "text": "Og disse funksjonskallene vil da sørge for at etter enter critical section... Så vil ingen andre prosesser, heller ikke på andre CPU-er, vil endre på de felles variablene. Det som typisk er felles, det ligger i ramm. Så igjen så vil disse funksjonskallene låse av bussen, sånn at man har enerett på å endre de områdene av ramm som man ser på. Dette forsinker alle jobber som kjører i parallell. Vi kjører i parallell for å få det til å gå fortere. Så hvis det er veldig mye synkronisering, så vil det gå saktere. Men dette er da opp til programmereren å lage et system som er smart nok, og som ikke bruker altfor mye tid i kritiske avsett.", "source": "lecture"}
