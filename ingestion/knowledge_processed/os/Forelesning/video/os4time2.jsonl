{"lecture_id": "os4time2", "chunk_id": "os4time2_0000", "start": 0.0, "end": 209.6, "token_count": 575, "text": "Ja... Da er vi i gang igjen. Før vi fortsetter med C-programmering, så skal jeg svare på noen veldig gode spørsmål som kom i pausen. Og så kan jeg også si at med OBS Studio så kan... Man slipper å... Som i Zoom, så må den... Så tar det en halvtime å få lagd den. Så her nå har jeg allerede... Lagt ut en... Nei, ikke slides. Skal vi se... I dagens forelesning... Her. Å starte recording. Og da ser vi at det funker faktisk. Og dette fører til at... Recordingen. Jeg skal ikke ta en dobbel... Så hvis det er noe du lurer på fra første time, så kan du gå tilbake og sjekke og eventuelt stille spørsmål. Men det var noen spørsmål fra pausen. Og det første var hvorfor ligger ikke RAM inne i CPU? Nei, hvorfor ligger RAM inne i CPU? Skulle ikke det ligget utenfor? Og da med en referanse til... ... til det vi har sett på tidligere. Dette bildet. Jo, og her ser vi... Simuler en... Tittelen her er en komplett CPU. Og det er helt riktig som det er påpekt. At... Ja, jeg tar opptak. Men jeg tar opptak... Veldig fint du spør. Jeg tar opptak i OBS-studio, sånn at opptaket pågår i bakgrunnen. Her står det at dette er en komplett SUPU. Og spørsmålet er hvorfor ligger RAM inni SUPU? Burde ikke den ligge utenfor? Jo, og det er helt riktig, så det er på en måte... Jeg tror jeg må rette opp figurtittelen her til å si en komplett CPU tilkoblet ram. For ram, den ligger egentlig utenfor CPU. Sånn at de åtte linjene her, i dette tilfellet, så utgjør de databussen mellom ram og CPU. Så det burde vært påpekt her. Det var også spørsmål om hva som er forskjellen på address out og data out i Datapath. Og det er også et godt og viktig spørsmål. Jo, adresse ut, den sender da de fire byttene til hvilken adresse i ramm vi skal skrive til. Mens dataene, de sender her... Data out... Her sendes data...", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0001", "start": 170.04, "end": 353.84, "token_count": 598, "text": "Sånn at de åtte linjene her, i dette tilfellet, så utgjør de databussen mellom ram og CPU. Så det burde vært påpekt her. Det var også spørsmål om hva som er forskjellen på address out og data out i Datapath. Og det er også et godt og viktig spørsmål. Jo, adresse ut, den sender da de fire byttene til hvilken adresse i ramm vi skal skrive til. Mens dataene, de sender her... Data out... Her sendes data... Så i det første tilfellet, når vi skulle lagre R3, som inneholdt 6, inn i ramm, så ble tallet 6 kablet rett inn her, til data out. Mens adressen... Da brukte vi R1, som var adresse nummer 1. Da ble de fire bitene koblet inn til adresse out. Og så ble det utført en tabelle. Skriving av resultatet. Så det er forskjellen på de to der. Men akkurat som på alle institusjoner må man da trykke på de riktige knappene her for å få til nettopp det. De riktige knappene i datapoden. Et siste spørsmål var om branch-kontroll i boksen på bildet. Altså den her tilsvarer kontrollenheten i CPU. Og det er også et godt spørsmål. Og svaret er ja, men i tillegg så... Så tilhører også instruksjonsdekoderen og program counter og alt det som ligger rundt datapath. Det tilhører også kontrollenheten i CPU. Og det spørsmålet tenker jeg er referert til... Bildet av en von Neumann-arkitektur. Nemlig... Her ser vi at vi har en kontrollenhet og en alu og registeret. Dette er et litt unøyaktig bilde. Det er vel kanskje det som er tilfellet. Men kontrollenhet her, det symboliserer bransjekontroll og instruksjonsdekoder og alt det som ligger rundt. Som gjør at en instruksjon som kommer inn her, sørger for... Kontrollenheten sørger da for at alle de rette knappene trykkes på i aluen og i registrene, sånn at riktig tall her aderes til et annet tall og lagres her nede, f.eks. Så alu og registers i denne figuren, det er det som vi vanligvis kaller datapath.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0002", "start": 314.24, "end": 508.48, "token_count": 591, "text": "Men kontrollenhet her, det symboliserer bransjekontroll og instruksjonsdekoder og alt det som ligger rundt. Som gjør at en instruksjon som kommer inn her, sørger for... Kontrollenheten sørger da for at alle de rette knappene trykkes på i aluen og i registrene, sånn at riktig tall her aderes til et annet tall og lagres her nede, f.eks. Så alu og registers i denne figuren, det er det som vi vanligvis kaller datapath. Og for vår tegning så er det veldig detaljert nøyaktig hva datapath er. Still gjerne enda flere spørsmål underveis. Det er veldig nyttig at dere stiller spørsmål. Hvis du har et eller annet du lurer på, så er det sikkert mange andre som lurer på akkurat samme. Så ikke vær redd for å stille spørsmål. Og så har jeg helt glemt å si at det er veldig hyggelig å se dere, alle sammen. Står opp så tidlig for å være med på dette her. Ok. Da skal vi gå videre med C-programmering. Og se på... Ja, og se på hvordan denne maskinkoden som vi så i simuleringen... Hvordan den faktisk er mer eller mindre akkurat den samme når vi kompilerer høynivåspråk ned til maskinkode. For heldigvis så slipper programmerere å skrive maskinkode. Det ville vært ekstremt tungvint hvis man skulle begynne å putte inn nuller og enere helt direkte, på samme måten som vi skriver den inn i ramme i simuleringen. Og du vil da skrive maskinkoden direkte inn. På de aller første datamaskinene så gjorde man det. Da... På de aller første datamaskinene så var det nettopp det man gjorde. Man skrev inn enere og nuller direkte inn i maskinen. Hadde gjerne hullkort som man da skrev enere og nuller på. Med hull på kortet. Det var nuller og enere. Og så ble det lagret inn i maskinen som et program. Og da var det maskinkode. Til å begynne med hadde man ikke kopilator. Men så fant man ut at... Dette ble ofte veldig feil. Fordi med de gamle maskinene så puttet man inn en bunke med hullkort med maskinkode.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0003", "start": 470.0, "end": 677.0, "token_count": 600, "text": "Man skrev inn enere og nuller direkte inn i maskinen. Hadde gjerne hullkort som man da skrev enere og nuller på. Med hull på kortet. Det var nuller og enere. Og så ble det lagret inn i maskinen som et program. Og da var det maskinkode. Til å begynne med hadde man ikke kopilator. Men så fant man ut at... Dette ble ofte veldig feil. Fordi med de gamle maskinene så puttet man inn en bunke med hullkort med maskinkode. Så fikk man resultatet. Oi, her hadde man gjort én bit feil, så alt måtte gjøres på nytt. Og denne operasjonen med å skrive maskinkode gir opplagt ekstremt mange feil. Så for å ordne på det så fant man opp høynivåspråk og kompulator. Og det som er ganske fantastisk, er at en kompulator kan oversette til maskinkode absolutt alle mulige former for høynivåkode. Så lenge syntaksen er riktig. Det er noen restriksjoner, syntaksen var riktig, men hvis du da skriver inn for-løkker og if-tester og wiløkker osv., så vil kompilatoren lage maskinkode som gjør nøyaktig det du ber om. Ja, det er en kommentar om at man klarte å lande på månen med hullkort og maskinkode, og det er riktig. Ikke helt riktig. Da man landet på månen i 69, så hadde man kompilatorer. Men hullkort var det mange som brukte fortsatt. Ok. Så... Det vi skal se på nå, er hvordan... Det er hvordan... Hva skjer når... Vi prøver å komplere en sånn løkke... Den løkken vi hadde med et C-program, som regner ut en sum. Så skal jeg først finne frem de riktige programmene som gjør det. Så skal vi prøve å se litt på hva innholdet egentlig er i denne... ... eller... Hello... Og da er det et... Det fins mange programmer som kan dumpe sånn Bite-kode. Eller ikke Bite-kode, men binær kode. For dette er en binær fil. Så X63 dumper ut innholdet av den binære filen. Og da ser vi kommer det en masse tegn. Vi kan pipe den til More, sånn at vi ser hva den inneholder. Og da ser vi... Ja, dette er da...", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0004", "start": 630.0, "end": 819.34, "token_count": 588, "text": "Så skal vi prøve å se litt på hva innholdet egentlig er i denne... ... eller... Hello... Og da er det et... Det fins mange programmer som kan dumpe sånn Bite-kode. Eller ikke Bite-kode, men binær kode. For dette er en binær fil. Så X63 dumper ut innholdet av den binære filen. Og da ser vi kommer det en masse tegn. Vi kan pipe den til More, sånn at vi ser hva den inneholder. Og da ser vi... Ja, dette er da... Dette er da Heks. Så ser vi det står 7F. Og det betyr at... Det første er det vanlige tallet 7, men hva er F? Jo, F er... Dette er heks, så det går opp til 16. Altså 10 er A... 11 er B, 12 C, 13 D, 14 E... Altså F er 15. Så F betyr da... F betyr da fire enere. Så... Så dette... Dette er da to bite. Så dette er... På en måte en... Det er en kortform av binært. Hvis du skrev det med nuller og ender, så ville det bli mye lengre. Så heks er en vanlig måte å skrive ut binær kode. Men elf er hva slags type binær kode dette er. Men vi kan se... Her nede så ser vi... Her kommer det... Oi... Hvis jeg tar... Sorry, en gang til. Her nede så kan man se at det står... Og det er en av de situasjonene hvor vi ser at i denne maskinkoden så snakker man med operativsystemet. Det er ikke bare institusjoner som adder og mover osv. Det er også kode her som snakker med operativsystemet, for man må be operativsystemet om å skrive ut resultatet. Og dette kommer vi masse tilbake til, hvordan operativsystemet... Og programmer snakker sammen. Så ser vi også at det er LIBC... Det er et bibliotek som da linkes inn. Dette er typisk biblioteker som brukes for å kunne skrive ut Printf. Men det vi skal prøve å fokusere på, er den koden som utfører algoritmen. Altså den forløkken som vi har sett på mange ganger. Hvordan utføres egentlig den? Men jeg ser det er masse koder der, og så rett og slett kommer det en goddel som bare er tomt.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0005", "start": 785.74, "end": 984.48, "token_count": 598, "text": "Så ser vi også at det er LIBC... Det er et bibliotek som da linkes inn. Dette er typisk biblioteker som brukes for å kunne skrive ut Printf. Men det vi skal prøve å fokusere på, er den koden som utfører algoritmen. Altså den forløkken som vi har sett på mange ganger. Hvordan utføres egentlig den? Men jeg ser det er masse koder der, og så rett og slett kommer det en goddel som bare er tomt. OK. Så... Det vi skal se på da aller først, det er et seerprogram som summerer. Så her har jeg et seerprogram. Som egentlig gjør akkurat det samme som vi kjørte i simuleringen vår. Nemlig den S-løkken som går tre ganger. Eller faktisk... Hvor mange ganger går denne her? Den går faktisk... Den starter på i lik null. Så den går en ekstra gang hvor... Den legger ikke til noe. Så det hadde vel egentlig vært riktigere å starte på 1 her. Hadde ikke det? Ja, for dette blir en gang som slår rundt i luften. Så hvis jeg starter på 1, så gjør den det samme som vår simulering. Altså den starter med I like 1, og S er initiert til 0.  Og så økes den første runde, så blir den én... Så legges i lik to, så legges to til, så blir det tre... Så går i opp i lik tre, og så legges den til. Så får vi resultatet seks, og så returneres det resultatet seks. Vi skal nå se hvordan dette utføres når vi kompilerer og kjører dette programmet. Hvordan blir egentlig maskinkoden? Det er viktig å vite at når man definerer en variabel, S lik 0, her, så tilordnes det en adresse i ram til denne variabelen. Og en integer, den er på 4 bite, eller 32 bits. Og det igjen er bare en konvensjon. Altså i C så skal integer være 4 bite. Den samme metallet her, I, den er også 4 bite. Men så har man andre variabler. F.eks. kan man lage en long-long int, som er 64 bit. Da brukes 64 bit, eller 8 bites, i ramm. Så når det lages plass til denne variabelen her i ramm, så settes det av 4 bites som ligger rett etter hverandre.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0006", "start": 939.8, "end": 1141.84, "token_count": 587, "text": "Og en integer, den er på 4 bite, eller 32 bits. Og det igjen er bare en konvensjon. Altså i C så skal integer være 4 bite. Den samme metallet her, I, den er også 4 bite. Men så har man andre variabler. F.eks. kan man lage en long-long int, som er 64 bit. Da brukes 64 bit, eller 8 bites, i ramm. Så når det lages plass til denne variabelen her i ramm, så settes det av 4 bites som ligger rett etter hverandre. Når man da skal aksessere den variabelen, Så sender man ut på bussen en adresse. Adresse 100.045 millioner. Der ligger vår variabel. Og så er det fire bite etter hverandre som ligger der. Så dette ble akkurat som vi gjorde i simulering. Ok. Jeg kunne ha skrevet dette, all koden, inne i Maine. Men... Og definere eller deklarere funksjoner på denne måten. Så nå har jeg gjort det for å kunne skille ut dette fra main, sånn at vi etterpå kan se på hva som skjer med akkurat denne koden. Hvordan ser den ut i maskinkode? Men før vi kommer så langt, så kan jeg vise hvordan vi kompilerer og kjører dette programmet. Kalle det sum. Ja, det er spørsmål om hvorfor det står int-main og ikke void-main. Det er et litt for vanskelig spørsmål. Det fungerer hvis du skriver void-main også, så vidt jeg husker. Men jeg tror det er en konvensjon fordi den returnerer et... Main returnerer et tall. Altså den returnerer en integer. Men, ja... Men det... Jo, det er mulig den returnerer det til operativstemme som en sånn feilkode etter at det har kjørt. At main da returnerer en integer-feilkode. Jeg tror det er det det kommer av. OK. Mens jeg kopierer programmet og kjører det, så ser vi at vi får sum like 6. Og siden vi var inne på det, skjer det noe annerledes hvis vi... Hvis vi starter med ILI-knull? Nei, det bør være det samme. Det er bare egentlig en overflødig linje, så vi kan like gjerne starte på én. Eller... Det er enda bedre. Men foreløpig så kan jeg på en måte ikke...", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0007", "start": 1092.44, "end": 1295.84, "token_count": 587, "text": "At main da returnerer en integer-feilkode. Jeg tror det er det det kommer av. OK. Mens jeg kopierer programmet og kjører det, så ser vi at vi får sum like 6. Og siden vi var inne på det, skjer det noe annerledes hvis vi... Hvis vi starter med ILI-knull? Nei, det bør være det samme. Det er bare egentlig en overflødig linje, så vi kan like gjerne starte på én. Eller... Det er enda bedre. Men foreløpig så kan jeg på en måte ikke... Jeg kan ikke kompilere denne biten alene, for alt henger sammen. Men det som går an å gjøre, er å dele opp C-programmet, sånn at vi har én bit som... Som utfører summen, og en annen bit som er mail. Da skal vi se hvis jeg finner den funksjonen. Jeg tror det er en som heter Sumfunksjon. Sånn, ja. Sumfunksjon, den inneholder da bare denne funksjonen. Og det går da an å kompilere det for seg. Og så kan man i tillegg ha... En main som kaller denne funksjonen. Så her har vi en extern int-sum i den sum main. Og den kaller da sum. Er katten sum to m-er, for ikke å blande? Sum kaller funksjon sum, og så skriver den ut hva den gjør. Og dette er mulig å gjøre i IC. Og her har jeg gjort det eksplisitt, fordi vi da etterpå skal kunne gå inn og se på maskinkode for denne summen. Hvis vi ser på den samlede maskinkoden for hele sum, så er det mye mer oversiktlig, for da inkluderer det main og all kommunikasjon med operativsystemet osv. Men da kan vi se hvordan vi kan kompliere dette. Og én måte å kompilere det på er å kompilere alt sammen. Sum main og sum funksjon. Og så kalle det gjensum. Og på samme måte så får vi da et program som vi kan kjøre. Men det som er fint for oss nå, som generelt er fint,  Man kan f.eks. ha samme main, og så gjør man bare endringer her i sum. Da kunne det vært fint å kunne komplere de uavhengige av hverandre. Og så skjøte de sammen etterpå. Og det er mulig.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0008", "start": 1257.22, "end": 1473.28, "token_count": 594, "text": "Sum main og sum funksjon. Og så kalle det gjensum. Og på samme måte så får vi da et program som vi kan kjøre. Men det som er fint for oss nå, som generelt er fint,  Man kan f.eks. ha samme main, og så gjør man bare endringer her i sum. Da kunne det vært fint å kunne komplere de uavhengige av hverandre. Og så skjøte de sammen etterpå. Og det er mulig. Jeg kan først komplere main. Men da må jeg legge på en... Hvis jeg legger på en opsjon minus c, så betyr det bare kompiler. Og ikke... Ikke load systembiblioteker og alt annet som trengs for å få en ferdig kjørbar kode. Bare kompler akkurat den koden inni her. Og så kan jeg kanskje kalle den for... La oss si... Main er vel et naturlig navn på den. Jeg kaller den Main. Det jeg fikk nå, var et... Eksekver hver kode som heter main, som inneholder bare den biten. Og så kan jeg gjøre det samme med... Med den symfunksjonen her borte. Den ønsker jeg å kompilere i en annen bit. Og så kan jeg kalle den for eksempel funk. Sånn. Og da gir dette maskinkode som inneholder bare koden for funksjonen funk. Så for å lage en eksekverbar kode der, totalt sett, så må jeg legge sammen... Den operasjonen jeg gjør nå, er å linke programmet. Og da oppfører Jesus seg som en linker. Jeg linker nå main og funk sammen. Og så får jeg ut en kjørbar fil som heter SUP. Så kjører jeg den, og så ser vi at det fungerer. Så i praksis er det samme operasjonen jeg gjorde her oppe, da jeg kompilerte hele programmet og kjørte det. Men jeg delte dem opp nå i to biter. Hvis vi ser på sum, det eksekverbare programmet, så ser vi det er 8672 bytes. Det er mye større enn summen av disse to. Det er fordi det da er linket til en biblioteker inn i den ferdige, eksekverbare koden. Og så er den da klar til å kjøre. OK... Men vi har da gått... Denne lange veien for å... For å kunne se på hva som egentlig er innholdet i...", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0009", "start": 1424.8, "end": 1640.0, "token_count": 584, "text": "Men jeg delte dem opp nå i to biter. Hvis vi ser på sum, det eksekverbare programmet, så ser vi det er 8672 bytes. Det er mye større enn summen av disse to. Det er fordi det da er linket til en biblioteker inn i den ferdige, eksekverbare koden. Og så er den da klar til å kjøre. OK... Men vi har da gått... Denne lange veien for å... For å kunne se på hva som egentlig er innholdet i... I sumfunksjon. Så skal vi kanskje hoppe litt i... I fremstillingen her. Og så kan vi prøve å be kompilatoren om å lage... Assembler-kode. Og måten man gjør det på, er at man... I stedet for... sånn som her... at jeg bruker minus C. Minus C sier 'lag maskinkode' av denne funksjonen. I stedet så kan jeg be GCC-kompilatoren om å lage assembler-kode. Så når jeg legger på den opsjonen minus S, Den ser vi at den er ganske liten. Vi kan se på den her... Hvordan... hvordan ser den ut? Jo, den er ikke større enn dette her. Og her ser vi... Her begynner det å ligne på noe vi har sett tidligere. Og dette her er såkalt assembly-kode. Og denne koden kan man skrive for hånd selv. Så tidligere i de tidligste datamaskinene var det veldig vanlig å skrive i assembly. I dag også så skriver man assembly i noen få tilfeller hvor man... Ønsker å få ting til å gå veldig fort for å optimalisere. Men det har blitt mindre og mindre vanlig å skrive assembly. Kanskje litt vanligere for ARM, for der er det veldig viktig at ting er effektive, mobile deviser. Men... Men det å skrive assembly, det er på en måte å gjøre jobben til kompilatoren. For det vi ser her, det er nå, da... Assembly-versjonen av den maskinkoden som GCC vil lage hvis jeg legger på minus C i stedet for minus S. Det jeg ba GCC om nå, var... Vis meg assembly-versjonen av den maskinkoden du vil lage. Og da ser vi at fra høynivåspråket så er det kompulatoren som da bestemmer nøyaktig hvordan denne loopen skal være.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0010", "start": 1601.72, "end": 1783.28, "token_count": 584, "text": "Men det å skrive assembly, det er på en måte å gjøre jobben til kompilatoren. For det vi ser her, det er nå, da... Assembly-versjonen av den maskinkoden som GCC vil lage hvis jeg legger på minus C i stedet for minus S. Det jeg ba GCC om nå, var... Vis meg assembly-versjonen av den maskinkoden du vil lage. Og da ser vi at fra høynivåspråket så er det kompulatoren som da bestemmer nøyaktig hvordan denne loopen skal være. Og vi ser her for eksempel så har vi en jump less equal. Det er hopp hvis... Hvis de to tallene, altså tallet 3 og dette her, som er en referanse til ram... Hvis... Jeg tror det er sånn at hvis denne er mindre enn 3, så skal du hoppe. Og det er typisk... Det er da metoden som kompulatoren har valgt. for å få til å lage en løkke. Da skal vi hoppe til L3, og det er opp her igjen. Og den utfører da akkurat den helt tilsvarende kode som vi lagde. Da skal vi se litt mer på den koden, men før vi gjør det, så kan det være greit å kjenne litt mer til X86 Assembly. De forskjellige tingene her... Hva de gjør. Så det vi skal se på nå, er hvordan man skriver assemblerkode direkte. Men det som kan være greit å ta med videre, er denne konstitusjonen her. Den ser litt rar ut. Og... dette er et register. Så denne konstitusjonen er... Det er en referanse til ram, og det er en referanse til den adressen i ram som ligger da inn i dette registeret RBP. Så akkurat som i simuleringen, hvis inni RBP ligger tallet 2, så er dette en referanse til byte nummer 2 i ramma. Men så er det litt sånn minus 4 her etter, og det er... Det betyr at... Det er egentlig ikke byte nummer 2, Så det blir da... Ja, la oss si RBP var åtte, da. Så blir denne adressen egentlig til bite nummer fire. For det er åtte minus fire. Du trekker fra fire bite. Eller du trekker fra adressen med fire bite. Og dette kan være... Jeg ser ganske gresk ut til å begynne med.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0011", "start": 1747.8, "end": 1935.9, "token_count": 590, "text": "så er dette en referanse til byte nummer 2 i ramma. Men så er det litt sånn minus 4 her etter, og det er... Det betyr at... Det er egentlig ikke byte nummer 2, Så det blir da... Ja, la oss si RBP var åtte, da. Så blir denne adressen egentlig til bite nummer fire. For det er åtte minus fire. Du trekker fra fire bite. Eller du trekker fra adressen med fire bite. Og dette kan være... Jeg ser ganske gresk ut til å begynne med. Men vi skal bruke litt tid på å se på assembly for å forstå hva som foregår. Det er også veldig nyttig senere, i andre sammenhenger, å kunne forstå hva assembly-koden er. Og så er dette på en måte linken fra transistorene og opp til høynivåkode. Så litt må vi forstå av registeret og hvordan de brukes. Når jeg snakker om registeret, og da ser vi at e-a-x er et register. ... så er det fire viktige registre. AX, BX, X og DX. Og E betyr at det er et 32-bitsregister. Og Move L betyr at vi skal flytte en long. Og en long det er da 32-bit. Så Movel, Adel og disse her opererer på 32-bit. Så jeg skal skrive litt assemblykode. Da skal vi bruke i stedet RAX. Og det er en utvidet versjon. Det er 64-bits-registeret. Men vi kan gå tilbake, og så kan vi se litt på... Vi kan se litt på det som står i notatene... Om Assembly. Det står ikke så veldig mye. Jeg har lagt inn et... Et par referanser... Det er et compaigner fra Erik Hjelmås som ligger i Canvas. Det inneholder litt om assembly. Så er det masse referanser på nettet også, sånn som denne her. Så vi skal ikke gå veldig dypt i assembly-programmering. Vi skal bare forstå og ta med oss noen enkle sammenhenger. Men det som er viktig å vite, er at nøyaktig som i den simulerte maskinen, så fins det assembly-institusjoner. Og det er ikke noe annet enn at i X86, når det finnes en institusjon Move, så har den bare et nummer i rekken. Det er en rekke institusjoner. Kanskje Move er institusjon nummer 24.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0012", "start": 1900.92, "end": 2100.28, "token_count": 587, "text": "Så vi skal ikke gå veldig dypt i assembly-programmering. Vi skal bare forstå og ta med oss noen enkle sammenhenger. Men det som er viktig å vite, er at nøyaktig som i den simulerte maskinen, så fins det assembly-institusjoner. Og det er ikke noe annet enn at i X86, når det finnes en institusjon Move, så har den bare et nummer i rekken. Det er en rekke institusjoner. Kanskje Move er institusjon nummer 24. Og når den skal utføres av en X86-maskin... Så står tallet 24 der, og da er det kodet akkurat som i vår simulering. Tallet 24 betyr - legg sammen. Og så er det da en syntaks for alle instruksjoner, sånn som for move. Så angir man... Man starter med en assemblerinje med move, og så angir man source og destination. Så move SDD... Her skriver move ax til bx, så betyr det rett og slett... Ta det som ligger i register ax, og legg i bx. Og så er assembly lagd av en masse sånne institusjoner som tilsvarer alle maskininstitusjoner. Så når maskinen er lagd, så definerer den alle institusjoner. Og f.eks. add sd... Det betyr da... Hvis jeg nå adds AxBx, så vil det bety legge sammen det som ligger i Bx med Ax, og lagre det i designation, nemlig Bx. Og tilsvarende for andre institusjoner. Det vi trenger for å gjøre akkurat den samme løkken som vi hadde i simuleringen, er disse institusjonene. Så trenger vi også å compare. Som er akkurat den samme som vi hadde i simuleringen. Sammenlign verdien av de to registrene. Og så etterpå så har vi en jump not equal. Den finnes også i Exo-86. Og da... Jump not equal, den hopper da til den riktige linjen i programmet. Og da, når vi har med det, så vet vi omtrent... For å skrive en sånn summeringsfunksjon. Så da kan vi prøve å gå inn og se på hvordan... hvordan det ser ut. Så skal vi se. Da har jeg... noen sånne funksjoner her. Og... Denne, ja. Dette er da et assembly-program som vi har skrevet.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0013", "start": 2043.96, "end": 2269.64, "token_count": 591, "text": "Og da... Jump not equal, den hopper da til den riktige linjen i programmet. Og da, når vi har med det, så vet vi omtrent... For å skrive en sånn summeringsfunksjon. Så da kan vi prøve å gå inn og se på hvordan... hvordan det ser ut. Så skal vi se. Da har jeg... noen sånne funksjoner her. Og... Denne, ja. Dette er da et assembly-program som vi har skrevet. Det er egentlig bare å sette seg ned med en taxi door og skrive assembly-kode. Så det jeg prøver å etterligne, eller det er egentlig ikke den... Det er den funk... sum... funksjonen. Denne. Det jeg gjør nå, er at jeg prøver å skrive et assembly-program som kan erstatte denne funksjonen her. Og så skal vi også se at den kan erstatte den funksjonen. Og den erstatter da direkte denne funksjonen. Kanskje vi kan gjøre det først, så kan vi se veldig kjapt her. Hvis dere ser godt etter, så er dette program som ligner helt på programmet fra simuleringen. Den eneste forskjellen er at her hadde vi... Maks i løkka kalte vi vel kanskje den for R0. Men det er fire registre, akkurat som vi i simuleringen brukte R0, R1, R2, R3 og R4. Så denne skal gjøre den løkka, og så skal den sende resultatet tilbake til main. Så det... Vi kan se på hvordan det fungerer i praksis. Så det jeg skal gjøre nå, er den.summain.c. I stedet for å kompilere den sammen med dette C-programmet, så vil jeg nå kompilere den sammen med as.s. Og det kan jeg gjøre på samme måte. Jeg kan si at jeg vil ha med summain, og så vil jeg ha med as.s. Sende ut en eksekverbar kode, som er sum. Hvis jeg gjør det, og så kjører den, så ser vi... Ja. Vi får tallet seks. Men man er på en måte ikke helt overbevist om at det er faktisk denne koden her som kjører. Og da kan vi jo teste det veldig raskt ved å si... Det tallet der er jo en maks som man skal gå til i løkka, som man sammenligner med. Skal se litt nøyere på koden etterpå.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0014", "start": 2240.04, "end": 2430.92, "token_count": 595, "text": "Sende ut en eksekverbar kode, som er sum. Hvis jeg gjør det, og så kjører den, så ser vi... Ja. Vi får tallet seks. Men man er på en måte ikke helt overbevist om at det er faktisk denne koden her som kjører. Og da kan vi jo teste det veldig raskt ved å si... Det tallet der er jo en maks som man skal gå til i løkka, som man sammenligner med. Skal se litt nøyere på koden etterpå. Men jeg kan i hvert fall save den der, og så prøve å kompilere på nytt, og så kjøre det. Og da ser vi... Jo, det ser ut til å virke, dette her. Det er den assembly-koden som nå utfører denne løkken her. Og da har jeg hele clouet at jeg som programmerer kan nå velge å si at nei, jeg stoler ikke på GSWC. GCC lager ikke bra nok kode. Jeg vil skrive denne koden i stedet. Og så skriver jeg denne koden, som jeg håper er mer effektiv enn koden som GCC lager. Men fra vårt ståsted så er det viktigste å se hvordan henger dette her sammen? Altså hvordan går man fra høynivåkode, som her, til maskinkode? Er det da kompilatoren som gjør den jobben? Den kompilerer da symfunksjon.c og lager eksekverbar kode. Men i stedet nå så kan vi... Vi kan gjøre sånn også. Kompilere as.s. Og så lage eksekverbar kode som jeg kan kalle as. SumMain, var det katten. Og så kan jeg kalle den Main. Og så kan jeg lime sammen de to bitene AS og Main og lagre det som en kjørbar filsum. Og så kan jeg kjøre det igjen. Nå er dette på en måte to uavhengige biter, så jeg kan gå inn her og endre tilbake. Endre den til tre igjen, sånn at summen skal bli ti. Da trenger jeg ikke kompilere sum main på nytt, men jeg må kompilere... Assemblykoden. Den må jeg kompilere på nytt, og så må jeg linke den sammen med main til en ny eksekuerbar kode, og så må jeg kjøre den. Så jeg kunne gjort dette én operasjon, men dette var bare for å illustrere at nå er det denne koden jeg kompilerer, og bare denne.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0015", "start": 2395.04, "end": 2573.26, "token_count": 598, "text": "Endre den til tre igjen, sånn at summen skal bli ti. Da trenger jeg ikke kompilere sum main på nytt, men jeg må kompilere... Assemblykoden. Den må jeg kompilere på nytt, og så må jeg linke den sammen med main til en ny eksekuerbar kode, og så må jeg kjøre den. Så jeg kunne gjort dette én operasjon, men dette var bare for å illustrere at nå er det denne koden jeg kompilerer, og bare denne. Og det er uavhengig av meg. Og det gjorde jeg ved denne operasjonen. Da kan vi til slutt se litt på hvordan denne koden virker. Hva er det som egentlig skjer her? I koden her så er det bare litt info. Jeg har oppsummert noen av de størrelsene som man bruker i Assembly. B står for bite, 8-bit. W er Word, 16-bit. L er long, 32-bit eller har 4-bite. Og Q er code, 64-bit eller 8-bite. Så har man da tilsvarende registre som er av forskjellig størrelse. Så har man tradisjonelt AX, BX, CX og DX. Og så har man en slags... Åtte-bit-registeret, AH og AL. Og da omtaler man egentlig første og andre, altså high og low av de 16-bitene i AX. Så har vi Extended AX, som er 32-bit. De første CPU-ene var på 4... Etter hvert var det vanlig med 16-bits CPU-er. Men så kom 32-bits, og da måtte man utvide registrene. Så kom, sånn rundt 2000, 64-bits CPU-er. Og da måtte man utvide til 64-bit. Det som jeg bruker her, er som vi ser, RCX. Det er da et 64-bits-register. Så det er litt overkill når vi bare snakker om så små tall. Men jeg gjør akkurat det samme som i simuleringen. Jeg legger først tallet 3 i R6. Med move-kommandoer så legger jeg tallet 1 i AddX. Og vi ser det som er litt... Dette er syntaksen i Assembly. Den er sånn at tallet 3... Dette er bare en konstant. Hvis det står en dollar, så kommer det en konstant etterpå. Så dette er tallet 3. I tillegg må man ha en prosent foran registeret når man antaller et register.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0016", "start": 2542.76, "end": 2717.0, "token_count": 588, "text": "Jeg legger først tallet 3 i R6. Med move-kommandoer så legger jeg tallet 1 i AddX. Og vi ser det som er litt... Dette er syntaksen i Assembly. Den er sånn at tallet 3... Dette er bare en konstant. Hvis det står en dollar, så kommer det en konstant etterpå. Så dette er tallet 3. I tillegg må man ha en prosent foran registeret når man antaller et register. Så jeg legger nå 3 i icx, 1 i dx, 0 i bxax... Og så begynner jeg å kjøre en løkke. Og da... Det første jeg gjør her, er add dx til bx. Og det betyr da egentlig... Ta verdien i RBX og så legg til RDX. Og det er da en I pluss pluss. Jeg kunne gjort dette her med bare en Operasjon INK. Da ville det hatt den samme effekten. Men jeg gjør det akkurat som i simuleringen, og så legger til tallet 1. Og så fortsetter jeg add RBX i RAX. Det betyr da ta RAX lik RAX pluss RBX. Og det er den summen. Og så kommer sammenligningen. Jeg sammenligner nå R6 og RBX. Og R6... Det ser vi i det tallet i den løkka jeg hadde. Så den avgjør hvor langt løkka går. Så når jeg endret den til fire, så gikk den én runde til. Det kommer først som compare, er i lik tre. Og så jump, not equal. Hvis de ikke er like. Så hopp opp til start. Og her står det 'Label start'. Det er da... I virkeligheten så vil dette programmet ligge i ramm når det er kompilert, og da er dette en adresse som den hopper opp til. Akkurat som i simulering. Så når alt er ferdig, så returnerer man. Og da kan man endre på koden her. For eksempel så sa jeg... RBX er lik RBX pluss RDX... Det kunne man jo f.eks. i stedet. Så kunne jeg bare si ink rbx her. Det betyr øk rbx med én. Så kan jeg da teste. Det er veldig lett å skrive feil i assembly-programmer. Men jeg kan teste nå om dette gikk bra. Kopierer først assembly-koden. Så linker jeg med meg.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0017", "start": 2676.92, "end": 2864.02, "token_count": 590, "text": "Så når alt er ferdig, så returnerer man. Og da kan man endre på koden her. For eksempel så sa jeg... RBX er lik RBX pluss RDX... Det kunne man jo f.eks. i stedet. Så kunne jeg bare si ink rbx her. Det betyr øk rbx med én. Så kan jeg da teste. Det er veldig lett å skrive feil i assembly-programmer. Men jeg kan teste nå om dette gikk bra. Kopierer først assembly-koden. Så linker jeg med meg. Og så kjører jeg. Ja, det gikk faktisk bra. Jeg oppnådde det samme med en annen institusjon, nemlig INK, som er Increment. Den bare øker RBX med én. Ja, da ser vi at vi har brukt opp tiden. Men det er noen spørsmål i chatten. Hvordan vet man at man ikke overskriver registeren eller RAM hvis de f.eks. brukes av en annen prosess? Og det er et veldig godt spørsmål. Og det kommer vi tilbake til etter hvert. Men der er det helt klare kjøreregler. Hvis vi husker tilbake da vi snakket med Prosesser om at Prosesser er et liv En veldig viktig oppgave for operativstemme er å sørge for at de ikke ødelegger for hverandre. Når det gjelder ramm, gjøres det ved at til hver prosess eller hvert program tildeles det en gitt bit av ramm. De bitene er sikret, sånn at det er umulig for den prosessen å skrive til andre deler. av ram enn det operativsystemet har bestemt. Så da får man en feil hvis man prøver å skrive til en adresse. Ofte i C-programmet så får man sånn core damped. Det er typisk da hvis man prøver å skrive til et sted i ram hvor man ikke har lov til, så krasjer programmet. Så det er én ting. En annen ting er med registrene. Og da er det faktisk sånn at... Registrene brukes av ett program av gangen. Vi skal se på senere... Når et operativsystem kjører flere programmer, så bytter de på. Hvis dette programmet kjører, sånn som nå... Så innimellom her at denne summen ble regnet ut. Så kunne det være et annet program som kjørte en kort stund.", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0018", "start": 2824.88, "end": 3027.6, "token_count": 590, "text": "ikke har lov til, så krasjer programmet. Så det er én ting. En annen ting er med registrene. Og da er det faktisk sånn at... Registrene brukes av ett program av gangen. Vi skal se på senere... Når et operativsystem kjører flere programmer, så bytter de på. Hvis dette programmet kjører, sånn som nå... Så innimellom her at denne summen ble regnet ut. Så kunne det være et annet program som kjørte en kort stund. Det typiske de gjør, er at de får ca. et hundredels sekund Og når de er ferdige med det hundredels sekundet, så lagrer operativsystemet alle registerverdiene. Alle verdiene som er i registeret. Og alt som er i RAM, er allerede lagret. Men de verdiene som er i registrene, lagres av operativsystemet i RAM. Og når prosessen etterpå skal inn og kjøre videre, så laster man tilbake de registerverdiene. Ja... Det er et spørsmål om hvordan vet du hva som returnerer? Bare å skrive rett. Og det er et godt spørsmål. Det er... Men det er bare en konvensjon. Og konvensjonen er at verdien i r-a-x, det er den som returneres. Så hvis... Hvis jeg her, for eksempel, bare skriver inn ... move 42... 43... 42 til... Da må jeg komme til... Hvor var det jeg skulle? RAX. Sånn. Så kan vi se at etter programmet er ferdig, så er det en konvensjon som bare returnerer det som er i RAX. Så da må vi kompilere på nytt. Og kjøre. Så ser vi... Da kommer sum 42. Nå har jeg jo ødelagt hele programmet. Men det er det jo da veldig fort å gjøre. Så hvis jeg f.eks. skriver en syntaksfeil sånn som dette her... Nei, det var ikke til den... Det er komplisert. Så ser vi... Her får jeg en beskjed fra assembleren. Her har du gjort noe feil. Og det er rett og slett en syntaksfeil. Vi kan si til slutt at dette her med å assemble kode sånn som dette er, For en assembler, som man ofte kaller det programmet som lager maskinkode fra assembly, en assembler stort sett så er det bare direkte oversettelse", "source": "lecture"}
{"lecture_id": "os4time2", "chunk_id": "os4time2_0019", "start": 2982.52, "end": 3154.68, "token_count": 493, "text": "Nei, det var ikke til den... Det er komplisert. Så ser vi... Her får jeg en beskjed fra assembleren. Her har du gjort noe feil. Og det er rett og slett en syntaksfeil. Vi kan si til slutt at dette her med å assemble kode sånn som dette er, For en assembler, som man ofte kaller det programmet som lager maskinkode fra assembly, en assembler stort sett så er det bare direkte oversettelse av institusjon for institusjon til maskinkode. Og det er bare snakk om bokholderi. Altså ad er institusjon nummer fire. Compare er nummer 32. Så lager man 0001 osv. Og tilsvarende med... Hvilket register det er. Så det er en veldig enkel prosess. Derimot - det å kompilere høynivåkode, det er en veldig kompleks prosess. Og det er veldig vanskelig å skrive en kompulator. Det er et veldig avansert program som må kunne oversette enhver høynivåkode til maskinkode. Og det er komplisert. Men en assembler kunne man relativt enkelt skrive. Ok. Men da stopper vi der. Og så tar vi en liten pause. Jeg tror ikke det er så mange i dag. Det blir kanskje bare jeg og Rune som er her. Så har jeg også en tosk igjen, men har ikke fått kontrakt ennå. Men han kommer etter hvert. Men uansett så skal jeg lage i hvert fall to breakout-rooms. Så kan dere komme dit etter pausen. Og så stille spørsmål. Jobb med oppgavene. Det er en del oppgaver til slutt denne uken som går på akkurat dette her. Her ser du forelesningstotatene til hvor langt det kom. Så hvis det kommer noen oppgaver som er litt for tidlig ute, så kan du prøve på det også. Men vi kommer til å snakke mer om dette i neste uke. Da stopper vi der.", "source": "lecture"}
