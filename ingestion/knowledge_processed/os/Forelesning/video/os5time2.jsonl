{"lecture_id": "os5time2", "chunk_id": "os5time2_0000", "start": 0.0, "end": 257.24, "token_count": 583, "text": "Ja... Da starter vi igjen. Det var noen spørsmål i pausen, så jeg tenkte jeg skulle prøve å tegne og forklare litt mer før vi ser mer på... Men det var én kommentar til, kanskje, først. Jo... Det ble spurt om... Kode, hva den betydde. Ja, jeg har lagt til litt her. Kode betyr åtte bytes. Men f.eks. long betyr fire bytes. Da ville jeg skrevet noe sånt. Da settes det av 4 bit i ramm til denne variabelen, som vil da være en 32-bitsvariabel. Så det typisk Jesus gjør, er når man bruker int, så er det long, og da settes det av 4 bit til variabelen. Dette vil også kompilere og kjøre. Det jeg ønsket generelt, var å bruke 8 byte til disse variablene. Hvis du bruker en long og du får tall som er større enn det som er plass til en long, så kan du få problemer. Ok. Men da skal jeg prøve å si litt om ram og CPU. Helt klart. Skal vi se... Hvis jeg klarer å... Jo, hvis vi tenker oss... ... at denne boksen er CPU-en. Håper det ser OK nå. Så inni CPU-en ligger da de registrene. CX osv. Og de er registre sånn som jeg hadde i simuleringen. I simuleringen så var registerstørrelsen 4-bit. Her er AX egentlig enda lengre. Den er på 32-bit. Nei, forresten. Den er 16-bit. EAX er på 32-bit. Så da er det bare lengre ray av bitt, sånn som dette her. Og med nuller og enere. Og så inni CPU-en så har vi da en alu. Og da har vi sett tidligere at vi... Det som skjer inni CPU-en, er at du har en kanal fra registrene. Som går inn i aluen. Og så kommer resultatet etter at aluen har gjort beregninger. Den kommer tilbake til registrene. Så her kan vi sitte og regne og holde på. F.eks. de Fibonacci-tallene. De regnes ut lokalt inne i SEPUN. Men så begynner vi å gjøre instruksjoner sånn som Move. Hadde en institusjon sånn som move%eax-til-svar i den koden som vi kjørte nå nettopp...", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0001", "start": 210.0, "end": 448.48, "token_count": 588, "text": "Som går inn i aluen. Og så kommer resultatet etter at aluen har gjort beregninger. Den kommer tilbake til registrene. Så her kan vi sitte og regne og holde på. F.eks. de Fibonacci-tallene. De regnes ut lokalt inne i SEPUN. Men så begynner vi å gjøre instruksjoner sånn som Move. Hadde en institusjon sånn som move%eax-til-svar i den koden som vi kjørte nå nettopp... Så betyr det, flytt resultatet av det vi hadde, til ram. Så dette er ram. Det skal vi studere senere i detalj. Men RAM er egentlig bare et svært reim med bites. Så her er det - skal vi se - åtte bit. Så dette er da adresse null i RAM. Dette er adressen i RAM. Det vi holder på med når vi sier'move prosent EAX' til svar, det er at vi ønsker å legge verdien av EAX fra CPU-en også ut i RAM. Så kan det òg godt være at... Hvis så... La oss si den svaret er 'long', da. Hvis jeg har definert en variabel som long... Så er den på fire bite. Og da betyr det at det settes av fire bite i ram. Og dette her er da de fire bitene til svar. Og det vi så i koden, det var noe sånt som minus fire prosents RDB eller noe i den stillingen her. Det er et register som ligger i CPU, men det inneholder et tall. Så dette er en adresse, og den adressen kan f.eks. være til rammelinje nummer 3757. Og den minus 4 betyr at det er den adressen minus 4. Så dette her... Når du ser det i et assemblerprogram, så... Peker det til et eller annet sted i ram. Og den inneholder da en adresse, som er den adressen her. Hvilket nummer... Hvilket bite i ram som skal legges der. Så det som skjer med den institusjonen her, det er at man tar de verdiene som lå i AX, og så legger man ut her. Det er EAX, så den EAX inneholder 32-bit. Så de 32-bitene får da plass i det som er satt av i ramm til de 32-bitene. Og når man skriver kode, int... Hvis man skriver kode sånn som dette her... Int svar er lik 42. Så det er...", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0002", "start": 399.6, "end": 620.4, "token_count": 597, "text": "Hvilket nummer... Hvilket bite i ram som skal legges der. Så det som skjer med den institusjonen her, det er at man tar de verdiene som lå i AX, og så legger man ut her. Det er EAX, så den EAX inneholder 32-bit. Så de 32-bitene får da plass i det som er satt av i ramm til de 32-bitene. Og når man skriver kode, int... Hvis man skriver kode sånn som dette her... Int svar er lik 42. Så det er... Det kompulatoren gjør da, som vi kan gjøre direkte i Assembly, er å finne en plass her i ram, og så skrive inn ener og nullere som tilsvarer 42, sånn at du lagrer dataene. Men når vi da gjør operasjoner sånn som add, så... Så opererer da add på registrene. En add-operasjon kan også operere på en variabel og et register samtidig. Så vi kan f.eks. si add % eax til svar. Så hvis jeg gjør en sånn... Hvis jeg gjør en sånn operasjon, så sier jeg ta det tallet som ligger i eax. Et tall 10 som ligger der, og legg til svar. Og så ligger det allerede 32 her i svar. Og så ligger det kanskje... Her ligger det 10 i det eksempelet vi hadde. Denne maskininstitusjonen her, den vil nå utføre operasjonen at den tar det tallet 10 og legger til 32, sånn at etter den institusjonen Så står det 42 her. Men det er klart at dette er hardware-kodet, altså denne institusjonen, på en sånn måte at først må verdien 32 som ligger her, den må sendes på databussen fra RAM til CPU. Her er databuss. Og det skjer da bak kulissene når man utfører en sånn operasjon som dette. Men det er på en måte hardware-kodet på forhånd, at når den institusjonen er der utføres, så tar man først 32 og legger inn her i et register. Og så legges det da tallet sammen med AX gjennom aluen. Det tallet 32 må sendes inn til Alun. Det går via registeret. Så lagres det ut igjen i... Mellomlagres resultatet. Så lempes det ut via datobussen ut hit, sånn at 42 lagres.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0003", "start": 577.24, "end": 816.44, "token_count": 596, "text": "Men det er på en måte hardware-kodet på forhånd, at når den institusjonen er der utføres, så tar man først 32 og legger inn her i et register. Og så legges det da tallet sammen med AX gjennom aluen. Det tallet 32 må sendes inn til Alun. Det går via registeret. Så lagres det ut igjen i... Mellomlagres resultatet. Så lempes det ut via datobussen ut hit, sånn at 42 lagres. Nøyaktig hva som skjer ved en institusjon, det er brent inn i kretskortet... Det er forhåndsbestemt hvordan dette skjer. Det eneste vi som programmerere vet, og ens operativsystem vet, er at resultatet blir sånn som det. Dette vet kompulatoren om, så den kan i stedet for å lage instruksjoner som da går inn og ut av databussen, som tar tid, så prøver den å optimalisere og gjøre mest mulig med registeret her inne. Ut på databusen og ut til ham. Så sånn røftelig er det... Det fungerer. Så nå skal vi se litt mer på Assembly. Vi skal se på en if-test. Og kanskje vi kan prøve å også lage den sånn fra scratch. Skal vi se... Se om jeg klarer å komme inn her. Oi. Der, ja. Må bare legge av litt. Ja, da skal jeg lage en liten if-test. Men vi kan se på... Jo, jeg har en if-main her. Jeg skal nå prøve å lage en liten rutine som utgjør en if-test. Det jeg tenkte å prøve på, var å skrive den fra scratch i Assembly. Se litt mer i detalj hva som foregår. Eller ta det bare sånn. Step for step. Så da kan jeg prøve å starte å lage den If-testen. Ja, jeg kan kalle den min If fra skillen fra de andre. Det jeg trenger å vite, er at det skal være en ekstern funksjon-if-test, så det navnet må jeg ha. Da begynner jeg fra scratch. Det jeg trenger å si, er at det er en global if-test. Det definerer den funksjonen jeg skal lage. At den heter det. Så C kan få tak i den. Så er det en label-if-test. Det er en slags standard måte å starte en... Den koden jeg skal lage... Vi kan se. Jeg har en...", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0004", "start": 766.92, "end": 995.36, "token_count": 587, "text": "Ja, jeg kan kalle den min If fra skillen fra de andre. Det jeg trenger å vite, er at det skal være en ekstern funksjon-if-test, så det navnet må jeg ha. Da begynner jeg fra scratch. Det jeg trenger å si, er at det er en global if-test. Det definerer den funksjonen jeg skal lage. At den heter det. Så C kan få tak i den. Så er det en label-if-test. Det er en slags standard måte å starte en... Den koden jeg skal lage... Vi kan se. Jeg har en... Den koden ser sånn ut. Jeg kan ta med den... Dette her ønsker jeg nå å lage. Så jeg kan kanskje ta med den inn i... Sånn at de ser hva vi skal lage. Skal vi kommentere det... Sånn. Så tanken her er bare å illustrere hvordan man kan lage en if-test. Vi har lagd en foreløkke. Om jeg får løkka, så kan de også lage en vile. Det blir omtrent det samme. Så vet vi omtrent hvordan alt som er av kode, lages i maskinkode. OK. Det vi kan starte med, det er altså... Nå skal vi prøve å få dette til å virke. Det er å ha et lite dataavsnitt. Og der har jeg en variabel som jeg kaller svar. Det er den svar her oppe som er 32. Da kan jeg si... Ja, jeg kan bruke kode igjen. Sette av 64 bit, 8 bytes, til en kode som... Ja... Som inneholder tallet 32. Det definerer den. Og så kan jeg... Bare for å se at dette her virker, så kan jeg bare teste først. Flytt tallet én til rax, og så returner. Da vil jo denne assembly-koden her nå, den gjør da ingenting. Den skal bare returnere én. Jeg tenker bare jeg gjør det her nå, først for å se om alt funker. Det kan være smart sånn at etterpå, når jeg skriver mer kode, så kan jeg være sikker på Da skal jeg lime den sammen med Ifmain. Den skal sammen med Ifmain sånn. Ja, der fikk jeg en warning... Ja, det er bare en warning. Jeg tror det er bare et ligneskift. Men vi kan se om den kjører. Ja, den kaller if-test, og så returnerer den svaret. Så det var en god start. Jeg lurer på om den...", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0005", "start": 947.88, "end": 1168.68, "token_count": 598, "text": "Jeg tenker bare jeg gjør det her nå, først for å se om alt funker. Det kan være smart sånn at etterpå, når jeg skriver mer kode, så kan jeg være sikker på Da skal jeg lime den sammen med Ifmain. Den skal sammen med Ifmain sånn. Ja, der fikk jeg en warning... Ja, det er bare en warning. Jeg tror det er bare et ligneskift. Men vi kan se om den kjører. Ja, den kaller if-test, og så returnerer den svaret. Så det var en god start. Jeg lurer på om den... Ja, det var ikke noe linjeskift her, så jeg tror da... Var det med et linjeskift, så ville den ikke gi den ordningen. Ok. Men nå skal jeg prøve å lage kode som lager en if-test, da. For vi har en variabel svar her, som vi tenker oss er et eller annet tall. Og så skal vi... Den skal... Hvis svaret er sånn... Så skal den returnere 1, og ellers skal den returnere 0. Og da... Ja, hva skal vi gjøre da? Jo, vi kan starte med... Det er jo 42 som er liksom... Tallet vi skal sammenligne med. Så vi kan starte med å legge 42 i en... I et register. Da kan vi bare velge hvilket register vi vil. La oss si jeg bruker RBX. Og så skal jeg nå... ... sammenligne svaret med dette tallet. Kanskje jeg skal... Nei, sånn. De tabbene er litt... Jeg håper det er litt på egen hånd, jeg. Jeg skal nå sammenligne RBEX og svar. Det kan rett og slett skrives sånn. En variabel kan bare skrives direkte sånn. Dette er en instruksjon som skal sammenligne de bitene som ligger her ute, i svaret svar, som da tilsvarer den der. Så jeg sammenligner nå 42 med svar. Og så... så skal jeg hoppe. Så da vil jeg hoppe hvis den er større igjen. JG, det er 'jump greater than'. Da kan jeg hoppe til et sted hvor det står... Eller en linje hvor det er 'greater'. Da husker vi fra simuleringen at da var det en sånn bransjekontroll. Og den bransjekontrollen styrte dette her med hopping. Men da må jeg ha et eller annet sted... Så må jeg ha en linje hvor det står 'greater'.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0006", "start": 1127.88, "end": 1334.04, "token_count": 597, "text": "Og så... så skal jeg hoppe. Så da vil jeg hoppe hvis den er større igjen. JG, det er 'jump greater than'. Da kan jeg hoppe til et sted hvor det står... Eller en linje hvor det er 'greater'. Da husker vi fra simuleringen at da var det en sånn bransjekontroll. Og den bransjekontrollen styrte dette her med hopping. Men da må jeg ha et eller annet sted... Så må jeg ha en linje hvor det står 'greater'. Så her har jeg da en label som heter Grater. Og så vet jeg... Hvis jeg hopper til Grater, da er den større enn 42, da skal jeg returnere 1. Og det kan jeg jo få til ved at jeg tar tallet 1... Alltid ha en dollar foran jeg skal skrive tall. Jeg tar tallet 1, og så legger jeg det i RAX. For RAX, det er det som returnerer. Sluttverdien. Så da er på en måte den biten riktig. Men så må jeg jo prøve å se hva det er som skjer hvis... Altså, jeg skal ha den elsker-en også. Hvis svarer 42, da skal jeg returnere igjen. Jo, men det jeg rett og slett kan gjøre da, er å bare gå inn etter jumpgrater. For hvis... Hvis testen slår til, og den er greater, så hopper den til greater. Hvis ikke, så vil den fortsette å bare utføre kode nedover her. For vi vet at når den ikke hopper, så utføres bare neste kodelinje. Neste kodelinje kan jo da være å putte null i prosent rx. For da har vi fått til den elskeren. Men da blir det dumt. Hvis jeg nå hopper... Hvis jeg ikke gjør noe mer nå... Vi kan prøve å kompilere, så kan vi se hva som skjer. Men det må jeg ha lenger ned her. Så må jeg ha en return. Og så return sånn. Og det som skjer her nå, det er da... Verdi returneres i prosent av x. Eller ea, ikke sant. Sånn. Vi kan se... Vi kan prøve å se hva som skjer når jeg kjører dette her. I dette tilfellet, når jeg har svaret er 32... Så skal den jo helst returnere null. Så vi kan prøve å komplere og se hva den returnerer. Da kompilerer jeg en sånn.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0007", "start": 1273.04, "end": 1493.18, "token_count": 596, "text": "Men det må jeg ha lenger ned her. Så må jeg ha en return. Og så return sånn. Og det som skjer her nå, det er da... Verdi returneres i prosent av x. Eller ea, ikke sant. Sånn. Vi kan se... Vi kan prøve å se hva som skjer når jeg kjører dette her. I dette tilfellet, når jeg har svaret er 32... Så skal den jo helst returnere null. Så vi kan prøve å komplere og se hva den returnerer. Da kompilerer jeg en sånn. Men den returneres av lik én. Så det var ikke helt riktig, den koden jeg skrev. Men hva var det som var galt? Du har ikke fjernet den første returen... Kjempebra! Dette her skulle jo ikke med. Så da returnerte han den. Det var derfor den ble retur 1. Veldig bra observert. Da ser vi en. Og så ser vi kanskje for null nå. Nei. Det er fortsatt... Får jeg svar 1? Hva gikk galt i If-testen min nå? Fordi at... Jeg kom jo hit, og så sammenligner jeg... \".Jump greater\". Nei, den skal ikke slå til. Og dermed så skal jeg jo flytte 0 over rx. Nei, den er ikke lik, fordi at jeg sammenligner 42 og 32. Altså, i sammenligningen her så sammenligner jeg RBX og svar, og svar er 32. Ja, om jeg bytter plass i Compere, er det noen som foreslår? Nei, det hjelper ikke. Men det er noe med logikken her som ikke stemmer helt. For det som skjer nå, er at hvis jeg ikke hopper, så går jeg hit. Ja, nettopp. Den går gjennom linje for linje. Så... Det som skjer, jeg hopper ikke her fordi den ikke er større. Og så går jeg hit, legger null i RX. Men så fortsetter den bare å gå ned til greater. Så hvis jeg ikke gjør noe annet, så... Så fortsetter man å kjøre linje for linje, akkurat som den simuleringen. Og da går den til greater, og så flytter den én til rax, og så går den til return. Så hvordan skal jeg fikse det? Jo, det jeg må gjøre da, er at her må jeg jo legge inn... Her må jeg legge inn en jump, for jeg flytter null til rax,", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0008", "start": 1459.5, "end": 1665.44, "token_count": 593, "text": "Og så går jeg hit, legger null i RX. Men så fortsetter den bare å gå ned til greater. Så hvis jeg ikke gjør noe annet, så... Så fortsetter man å kjøre linje for linje, akkurat som den simuleringen. Og da går den til greater, og så flytter den én til rax, og så går den til return. Så hvordan skal jeg fikse det? Jo, det jeg må gjøre da, er at her må jeg jo legge inn... Her må jeg legge inn en jump, for jeg flytter null til rax, og da er jeg egentlig ferdig. Så jeg kunne lagt inn en return her, men... Jeg kan gjøre det eksplosivt og så si... OK, her vil jeg hoppe til Return. Sånn, da. Jump Return. Hvis jeg kommer hit, legger jeg null, og så hopper jeg over greater, sånn at ikke den blir satt. Og det er akkurat det en iftest gjør. Det funker. Ja... Og da ser vi... Nå returneres svarlig knull. Ja, det var en som foreslo \".Jump to return\". Helt riktig. Det var akkurat det jeg må gjøre. Og det som dere må sitte igjen med av dette her, er at... Her ser vi hvordan en kompilator må tenke, hvordan en kompilator da kan oversette. Her har vi en branching. Her er det en test som utføres. Og det kan alltid oversettes med denne type sammenligninger og jump statement. Det er spørsmål om man kan ha return to steder. Jeg er ikke sikker på... Jeg kan teste. Da burde det i så fall gå å gjøre sånn. Ja, ser ut som det går fint. Ja. Det går det an å gjøre. Denne vil utføre det samme, for den returnerer da direkte. Men da må jeg bare dobbeltsjekke. Funker det nå? Hvis svar er større enn 42. Altså hvis svar er 52. Da må jeg kompulere på nytt og også kjøre. Ja, det ser ut til å funke fint. Og det er liksom... det er poenget. Nå var svar 52, og JG hopp hvis hun er større. Og da hopper han til greater, og så flytter han Mooby inn her. Så kunne jeg teste JG, om den faktisk funker. Hvis tallet er 42, så skal den jo ikke hoppe til 1 her oppe.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0009", "start": 1620.02, "end": 1815.64, "token_count": 592, "text": "Hvis svar er større enn 42. Altså hvis svar er 52. Da må jeg kompulere på nytt og også kjøre. Ja, det ser ut til å funke fint. Og det er liksom... det er poenget. Nå var svar 52, og JG hopp hvis hun er større. Og da hopper han til greater, og så flytter han Mooby inn her. Så kunne jeg teste JG, om den faktisk funker. Hvis tallet er 42, så skal den jo ikke hoppe til 1 her oppe. Da skal den returnere 0. Så vi kan prøve det til slutt. Ja, da stemmer det. Den returnerer 0. Så den... Den fungerer som den skulle. Her ser vi hvordan man kan skrive en assemblerkode. Og dette vil egentlig si at man skriver maskinkode. For her er assembleren... Den gcc-en når den lager maskinkode av denne. Så bare oversetter den linje for linje. Move er institusjon nummer 112. Så skriver den 112. Og så rbx. Og så kodestøyen, akkurat som i simuleringen jeg har sett på tidligere. Compare blir en linje, dette blir en linje, move blir en linje osv. Så dette blir linje for linje. Det var spørsmål hvilken verdi som reduseres når det bare står rett? Og det er... Rax returneres alltid. Og det er en slags sånn avtale med c-funksjoner. Jeg forventer å få returverdien i RAX. Nei, jeg kan ikke returnere noe som ikke er RAX. Men hvis jeg har en funksjon som... Nei, så jeg må legge den returverdien i RAX. Hvis du holder en funksjon, så har du andre rutiner. Da tar funksjonen imot variabler. Hvis du har en funksjon som har to int-variabler, men da legges de... Jeg husker ikke hva konvensjonen er, men da kan det være sånn at de innkomne variablene legges i rax og rbx. Så hele tiden må man ha konvensjoner, sånn at man vet hva funksjonene skal. Når du først har det, så kan man skrive kode som dette her og sende variabler frem og tilbake til funksjonen. Men det som er viktig her, er at vi nå på en måte har en idé om", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0010", "start": 1783.88, "end": 1991.52, "token_count": 596, "text": "men da legges de... Jeg husker ikke hva konvensjonen er, men da kan det være sånn at de innkomne variablene legges i rax og rbx. Så hele tiden må man ha konvensjoner, sånn at man vet hva funksjonene skal. Når du først har det, så kan man skrive kode som dette her og sende variabler frem og tilbake til funksjonen. Men det som er viktig her, er at vi nå på en måte har en idé om hvordan enhver sånn konstruksjon som dette her, en foreløpige eller en if-test... Hvordan den produseres i markinen. Spørsmål om... Jo, om returverdien, hvorfor det står int i... I maine. Altså, det er en int maine. Men maine har også en returverdi, så det... Her kan maine returnere tall. Og det er derfor du har en int-verdi på maine. Hvis jeg nå kompilerer den her... Også kjører add-og-topp... Så vil jeg da se at... Da kan jeg lese ut returverdien fra det jeg kjørte programmet. Så den leverer et heltall, og på den måten kan program levere en feilkode når det kjøres. Så hvis jeg er i Linux her, så er feilkoden... Da får jeg ut akkurat den feilkodete i meg. Ok. Da skal vi til slutt se på noen slides og komme veldig raskt innom pipelining. Kanskje vi ser litt mer på det neste gang, men... Vi kan iallfall starte. Først skal jeg si litt om forenklinger ved den CPU-simuleringen vi hadde. Den simulerte CPU-en vi hadde, den virker i prinsipp som alle mer komplekse og moderne CPU-er. Det er klart... Den simulerte CPU-en vi hadde, den virker i prinsipp som Men den har en rekke forenklinger. Det er vel heller de moderne CPU-ene som er mer komplekse, og de er blitt lagd mer komplekse for at de skal være raskere. I prinsippet så virker de på samme måte. For det første så bruker institusjoner mer tid enn én CPU-sykkel på å utføres. Og det er fordi at det er... De operasjonene er mer komplekse enn i vår enkle CPU, så det tar mer tid. F.eks. så hentes typisk først hver institusjon inn fra RAM,", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0011", "start": 1955.12, "end": 2133.56, "token_count": 591, "text": "Det er vel heller de moderne CPU-ene som er mer komplekse, og de er blitt lagd mer komplekse for at de skal være raskere. I prinsippet så virker de på samme måte. For det første så bruker institusjoner mer tid enn én CPU-sykkel på å utføres. Og det er fordi at det er... De operasjonene er mer komplekse enn i vår enkle CPU, så det tar mer tid. F.eks. så hentes typisk først hver institusjon inn fra RAM, og så deles den opp i flere biter. F.eks. hvis en institusjon leser fra RAM eller skriver til RAM, så er det egne deler av institusjonen. Så en X86-institusjon deles generelt opp i små biter, eller mikro... Vi skal se litt på det snart. Men aller først, det som er veldig viktig å ha med videre, det er at vi har en CPU-ulykke, akkurat som med den i simuleringen. Så lenge maskinen ikke blir skrudd av, så utfører den instruksjoner. En NOP-instruksjon, Novo Operation, som ikke gjør noen ting, bare står og slår i lufta. Så dette er gangen for enhver CPU. Først henter man denne instruksjonen den skal kjøres. Og så øker programkontoen, og så utføres den instruksjonen. Instruksjoner kan være sånne som hopper i koden, men hvis det ikke er noe hopp i koden, så utføres bare... Så økes PC bare med én, og så fortsetter den å kjøre. Men CPU er også koblet til annen hardware, som tastatur og nettverkskort osv. Så når som helst så kan CPU-en bli avbrutt av et interrupt. Det skal vi se på senere. Da må CPU-en stoppe i de operasjonene den gjør. Og så må den behandle interruptet. Så må CPUN stoppe opp og gjøre institusjoner som tar imot det tegnet, sånn at det kan skrives ut til skjermen. Den type avbrudd er det ikke CPUN som styrer, for det er avbrudd som kommer utenfra, så de kan komme når som helst. Pipelining. Jeg nevnte at en i institusjonen deles opp i flere biter. Man klarer ikke å gjøre den på én klokkesyklus.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0012", "start": 2094.88, "end": 2271.72, "token_count": 587, "text": "Og så må den behandle interruptet. Så må CPUN stoppe opp og gjøre institusjoner som tar imot det tegnet, sånn at det kan skrives ut til skjermen. Den type avbrudd er det ikke CPUN som styrer, for det er avbrudd som kommer utenfra, så de kan komme når som helst. Pipelining. Jeg nevnte at en i institusjonen deles opp i flere biter. Man klarer ikke å gjøre den på én klokkesyklus. Det er rett og slett for mange operasjoner som skal gjennomføres, så man har funnet ut at det er bedre å dele opp instruksjonene i små biter enn å ha en veldig lang syklus. Så i de aller første mikkelprosessorene var det bare én syklus, sånn som i vår simulering. Snart med to sykler, altså fetch og execute. Først hente instruksjonen, og så utføre den. Etter hvert ble det en standard som hadde de viktigste operasjonene. Fetch, decode, execute rights. Fetch, hente instruksjonen. Decode er instruksjonsdekoderen som da finner ut hvilke knapper skal man trykke på i alle datapapp for å utføre instruksjonen. Og det må dekodes. Og så kommer execute. Det er virkelig å utføre instruksjonen. Hvis det er å legge sammen to tall, så skjer dette inni ALU. Og så skrive resultatet deres. Det er jo ikke alltid alle deler som utføres. Men med dette kan dere tenke dere én måte å dele opp instruksjonene på. Men Moderne Sepur har enda flere stages enn dette her. 14 stages. Eller 14 deler, da... er vanlig. Og da deles da det som vi har tenkt på som én institusjon... En ad, f.eks. Det deles da opp i 14 små biter. Som på en måte er detaljer av den institusjonen som skal utføres. Og alt dette... Denne inndelingen gjøres for at alt skal gå fortere. Det man kan gjøre når man har delt opp når man har den type pipelining, det er at institusjoner kan gjøres samtidig. Det vi kan tenke hvis vi har 'fetch' og 'execute'. Hvis vi bare har to stages. To stadier er det vel på norsk.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0013", "start": 2230.28, "end": 2421.36, "token_count": 576, "text": "En ad, f.eks. Det deles da opp i 14 små biter. Som på en måte er detaljer av den institusjonen som skal utføres. Og alt dette... Denne inndelingen gjøres for at alt skal gå fortere. Det man kan gjøre når man har delt opp når man har den type pipelining, det er at institusjoner kan gjøres samtidig. Det vi kan tenke hvis vi har 'fetch' og 'execute'. Hvis vi bare har to stages. To stadier er det vel på norsk. Så har vi første stadiet å hente institusjonen. Og andre er å utføre. Da kan vi tenke oss at OK... Men når vi er i gang med å utføre den første institusjonen, så kan neste institusjon hentes av fetch. For da slipper vi å vente på at den hentes. Og det er akkurat det som er pipelining. Man gjør operasjoner samtidig. Så hvis vi har fire stadier, så kan vi tenke oss at uten... Den blå er en institusjon, den røde er en annen. Så går klokka bortover sånn. I vår simulering gjør vi én institusjon på hvert klokkesyklus. Men hvis vi har en CPU som må ha fire sykler for å utføre en institusjon, så ser vi at den første - fetch, decode, execute også right. Men pipelining vil si at man gjør to operasjoner samtidig. Man begynner på den neste institusjonen før den første er ferdig. Så da får vi denne rekkefølgen istedenfor åtteklokkesykler. Så blir vi da ferdig på fem. For da henter vi først den første institusjonen, og så på neste syklus så dekodes den første institusjonen. Men samtidig så hentes neste. Og det er opplagt at da går ting raskere. Ja, her ser vi noen sånne mikroarkitekturer for Intel. Som jeg sa, de aller første... 8086 var en av de første CPU-ene for PC-er. Da var det en pipeline med to steg, eller to stages. Så ser vi at den har økt en del oppover. 54 plater hadde enormt mange stages. Men så har man gått litt tilbake. Og i de mer moderne er det 14 stages som er vanlige. Så dette er pipelining.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0014", "start": 2370.0, "end": 2566.84, "token_count": 584, "text": "Og det er opplagt at da går ting raskere. Ja, her ser vi noen sånne mikroarkitekturer for Intel. Som jeg sa, de aller første... 8086 var en av de første CPU-ene for PC-er. Da var det en pipeline med to steg, eller to stages. Så ser vi at den har økt en del oppover. 54 plater hadde enormt mange stages. Men så har man gått litt tilbake. Og i de mer moderne er det 14 stages som er vanlige. Så dette er pipelining. Det gjør at vi gjør på en måte én og én instruksjon, men at man tjusstarter. Så kommer et litt annet prinsipp, og det er superskalararkitektur. Her utnyttes både pipelining, det samme prinsippet, men også i en superskalararkitektur så gjøres ting faktisk i parallell. Så sa vi at man har... La oss si du har åtte institusjoner etter hverandre. Det er de åtte neste som skal gjøres, eller seks institusjoner, som i dette tilfellet. Seks institusjoner etter hverandre. Så da er det kanskje én institusjon som er ad, og én er move. Og de er av litt forskjellig type. Og da gjør man faktisk de instruksjonene i den grad det er mulig, i parallell. Og her kan dere kanskje skimte at det står alu. Her er det to aluer, og så er det en load her, og så er det en alu her borte med jump osv. Så det som skjer da, er at man... Først så deler man alle de seks institusjonene inn i mikroinstitusjoner. Så hver av de har kanskje 14 mikroinstitusjoner, med fetch-delen her oppe. På den måten at de seks institusjonene hvis mulig utføres i parallell på helt uavhengige små aluer her, som jobber parallelt med å regne og lagre. Og at dette er selvfølgelig bare for å få ting til å gå fortere. For da kan man få til å... Man kan utføre instruksjoner i løpet av en syklus, eller kanskje enda raskere, ved at man gjør ting i parallell inne i CPU-en. Dette må ikke forveksles med det vi skal se på senere med multitasking,", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0015", "start": 2531.14, "end": 2706.52, "token_count": 594, "text": "på helt uavhengige små aluer her, som jobber parallelt med å regne og lagre. Og at dette er selvfølgelig bare for å få ting til å gå fortere. For da kan man få til å... Man kan utføre instruksjoner i løpet av en syklus, eller kanskje enda raskere, ved at man gjør ting i parallell inne i CPU-en. Dette må ikke forveksles med det vi skal se på senere med multitasking, for da har vi helt fullstendig store CPU-er som jobber helt uavhengig av hverandre. Men her deles institusjonene, sekvensielle institusjoner som kommer etter hverandre, opp i små biter. Og så utføres de i parallell. Så her kan det være institusjon 1 som holder på, samtidig med at institusjon 3 holdt på her borte. Det er klart, alle institusjoner kan ikke utføres i parallell. Altså, noen er avhengige av hverandre. Men det er et samarbeid mellom kompilatoren og CPU-en. Så prøver man å gjøre så mye som bare mulig parallelt. En skalær prosessor. Det norske ordet kan kanskje diskuteres. Jeg lurer på om kanskje skalar er bedre? En skalar i motsetning til en vektor er noe som ikke er i parallell. Men i hvert fall en skalar prosessor utfører institusjoner én og én. De superskalære prosessorene, som egentlig er alle prosessorer etter år 2000, de er superskalære. De har flere parallelle enheter som utfører mikrooperasjoner. De kan ha flere aluer og FPU-er, sånn at de kan jobbe med helt forskjellige institusjoner på én gang, og kjøre de faktisk samtidig. Men det bryr man seg egentlig vanligvis ikke så mye om som operativsystem, for man ser ikke dette. CPU-en sørger alltid for at den logikken... Den kan til og med utføre operasjoner auto-warder i en annen rekkefølge enn det sekvensielle programmet tilsier. Men da hender det man må gå tilbake og rette opp hvis noe går galt. Her ser vi Intel Core 2, som er en relativt moderne SPU-arkitektur. Den deler da institusjonene opp i mange småbiter.", "source": "lecture"}
{"lecture_id": "os5time2", "chunk_id": "os5time2_0016", "start": 2656.6, "end": 2889.4, "token_count": 600, "text": "Men det bryr man seg egentlig vanligvis ikke så mye om som operativsystem, for man ser ikke dette. CPU-en sørger alltid for at den logikken... Den kan til og med utføre operasjoner auto-warder i en annen rekkefølge enn det sekvensielle programmet tilsier. Men da hender det man må gå tilbake og rette opp hvis noe går galt. Her ser vi Intel Core 2, som er en relativt moderne SPU-arkitektur. Den deler da institusjonene opp i mange småbiter. Og så ser vi her nede, så har vi da i parallell flere aluer. Her er en alu-branch og SSE-alu, og så har vi store-address. Store-data, load-address. Så for hver... Samtidig kan det kjøres i parallell. Dette gir da mye større ytelse på prosessoren. Man får da prosessoren til å yte litt ekstra ved at tingene gjøres parallelt. Men det er en grense for hvor mye du kan parallellisere. Utover det er det veldig vanskelig å få til parallellisering. Det er ikke alltid det virker, det er avhengig av koden. Så det er et samarbeid mellom kompulatoren og CPU-en å få til den optimale kjøringen av en énprosess. Og det er... Det gjøres ved de to metodene, pipelining og parallellitet, eller superskalær. OK, jeg tenkte å begynne å se på bransjeprediction. For det er et sånt eksempel på hvordan pipelining kan faktisk ha innflytelse på det å kjøre programmer. Men jeg ser klokka er såpass mye nå, så jeg lurer på om vi bare utsetter den bransjeprediction-delen til neste gang. Og så stopper vi der. Med mindre det er noen spørsmål... noen som har noen de lurer på? Nei, still uansett gjerne spørsmål i chatten. Og så vil vi nå som vanlig, som alltid, så åpne jeg... Breakout rooms. Så kommer jeg og Ine og... Håper Rune er her også. Rune, er du her? Ja, Rune er her, ser jeg. Da lager jeg tre breakout-room, så må dere komme og spørre i de rommene. Still også gjerne spørsmål i chatten her ute, så kan vi... Men da stopper vi der, og så lager jeg Breakout Rooms.", "source": "lecture"}
