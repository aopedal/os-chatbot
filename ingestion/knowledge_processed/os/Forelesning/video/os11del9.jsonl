{"lecture_id": "os11del9", "chunk_id": "os11del9_0000", "start": 0.0, "end": 209.0, "token_count": 600, "text": "Ok. Da skal vi se på Java-tråder på vinduer. Jeg har kopiert over den samme mappa. Det er prio.java. Så jeg kan kjøre den. Eneste forskjellen var at jeg... Ba den første tråden om å sove i 3000 millisekunder, altså i 3 sekunder. Vi kan se av kjøringen hva slags prioriteter vi har. Tråd nummer to starter med prioritet 10, så den har høyest prioritet. Etter tre sekunder starter tråd nummer én med prioritet 5. Men da ser vi Windows tar virkelig hensyn til prioriteten. Den kjører bare tråd nummer to fordi den har høyest prioritet. Men så ser vi at nå endrer vi prioritet for tråd nr. 2. Og så endres den til 4. Og da er det tråd nr. 1 som har prioritet 5. Den kjører hele tiden. Så vi ser en enorm forskjell i prioriteter. Hvis en tråd har høyere prioritet enn en annen, så tar den omtrent alt som er av... Vi ser på uttid. Mens Linux default ikke bryr seg om Java-prioritet, så tar Windows ekstremt stor hensyn til det. Hvis man ser på prioritet i Windows, så er den veldig sterk. Hvis man endrer prioritetsklasser, så får man en veldig stor effekt. Og det ser vi tydelig her. Tråden som hadde prioritet fire... Den var enerådende i praksis hele veien, mens tråden som hadde prioritet nummer fem, den måtte i praksis vente til den andre var ferdig. Og så fullførte den sin jobb. Så vi kan konkludere at implementasjonen av prioritet på Java den er plattformavhengig. Som også, som sagt, så skredulerer operativstemmen, altså både Windows og Linux, veldig bra med default prioritet. Sånn at dette her er ikke opplevd som noe veldig stort problem. Man kan jo da også individuelt omprioritere med nice, f.eks. Eller på andre måter prioritere. Moderne operativsystemer er så gode på å gi respons til de som trenger det interaktivt, og gi da en litt saktere respons til prosesser som bruker mye CPU. Og dette gjør da operativsystemene dynamisk på en så bra måte at det som regel ikke er noe stort behov for programmereren å gi egne...", "source": "lecture"}
{"lecture_id": "os11del9", "chunk_id": "os11del9_0001", "start": 162.68, "end": 215.0, "token_count": 133, "text": "Sånn at dette her er ikke opplevd som noe veldig stort problem. Man kan jo da også individuelt omprioritere med nice, f.eks. Eller på andre måter prioritere. Moderne operativsystemer er så gode på å gi respons til de som trenger det interaktivt, og gi da en litt saktere respons til prosesser som bruker mye CPU. Og dette gjør da operativsystemene dynamisk på en så bra måte at det som regel ikke er noe stort behov for programmereren å gi egne... Prioriteringer til prosesser.", "source": "lecture"}
