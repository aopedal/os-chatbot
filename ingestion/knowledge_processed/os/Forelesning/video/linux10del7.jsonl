{"lecture_id": "linux10del7", "chunk_id": "linux10del7_0000", "start": 0.0, "end": 209.96, "token_count": 597, "text": "Da skal vi se på to typer hypervisor, type 1 og type 2. Det er litt flytende skiller mellom de, men det er ett poeng som er viktig, og det er at type 1 hypervisor... Det er på en måte en helt selvstendig hypervisor som kjører... Oppå hardware, direkte. Sånn som med WMWare, f.eks. Hvis du skal virtualisere med WMWare, så må du installere WMWare på en server, og så etterpå så installerer du virtuelle maskiner oppå det. Det samme gjelder Send og Hyperware, Microsofts virtualisering. Da setter de opp en hypervisor i bunnen her, og så... Oppå den kan man kjøre forskjellige operativstemmer. Sånn som Windows, Linux og andre OS. Og her ser vi at det går fint å kjøre Windows og Linux på samme Hypoviser. For Hypervisoren tilbyr bare CPU, ram og IO. Den tilbyr bare grensesnittet som hardware gir. Og ikke noe annet. Så da er det ved ekte virtualisering... Så er det ikke noe problem å kjøre Windows. Og Linux som to VM-er ved siden av hverandre oppå på den samme hypervisoren. Her vil det være sånn at alle sensitive instruksjoner som utføres i juss-mode, de trapper til kernel-mode og fanges opp av hypervisor. Så... Og vi kan si at hypervisor kjører direkte på hardbet. Type 2 hypervisor er litt annerledes. For da... Da har man et eksisterende OS. Her har du et OS sånn som f.eks. Linux, som kjører direkte på hardware. Det som vi har her nede, det er et standard Linux-oppsett. Men så... Så ser vi at man får en type to... Ops. Unnskyld hvis jeg skrur av litt lyd her. Du kjører oppå Linux. Dette vil du f.eks. se med KVM. Virtual Box er en annen sånn løsning. I praksis vil man rett og slett starte en hypervisor. I KVM har du en Kemu hypervisor. På Linux OS så starter man en prosess som heter Kemu. Det imaget kan være en Linux-VM, eller en Windows-VM. Da er det en prosess som står der og kjører på Linux-operativsystemet. Mens Host-OS kan ha andre prosesser som kjører sammen med Hypervisor. Men dette ser jo da veldig lite effektivt ut. Vi skal se noen resultater.", "source": "lecture"}
{"lecture_id": "linux10del7", "chunk_id": "linux10del7_0001", "start": 163.0, "end": 364.38, "token_count": 597, "text": "I praksis vil man rett og slett starte en hypervisor. I KVM har du en Kemu hypervisor. På Linux OS så starter man en prosess som heter Kemu. Det imaget kan være en Linux-VM, eller en Windows-VM. Da er det en prosess som står der og kjører på Linux-operativsystemet. Mens Host-OS kan ha andre prosesser som kjører sammen med Hypervisor. Men dette ser jo da veldig lite effektivt ut. Vi skal se noen resultater. Som viser hvor lite effektivt det er. Hvis det kjører kun som en fortolker... Hvis denne hypervisoren ikke får hjelp av kjernemoduler, så vil dette gå veldig sakte. For da må på en måte... Dette vil da bli en emulering av hardware. Og det er for tungt i praksis. Det som redder dette opplegget, er at her nede så har du KVM. Cornal Virtual Machine. Det er altså kjernemoduler som hjelper Linux med å gjøre dette her mer effektivt. Man kan si at kjernemodulene gjør at det ligner mer på dette. Altså at hypervisoren kjører rett på ram. Sånn at... Prosessen her oppe kan kjøre mer effektivt på hardware. Det man ønsker er at hvis det er en Windows-applikasjon som legger sammen tall, så ønsker man at de institusjonene skal kjøre rett på CPU. Det får man også til. Nå er det mange lag imellom her, men på samme måte som en applikasjon som kjører på Linux, hvis den legger sammen tall, så står ikke Linux og kontrollerer hver institusjon. Det Linux gjør, er at den sørger for at koden til denne applikasjonen her oppe, den blir lagt direkte i CPU-en og utføres fort som bare det. Og det samme klarer man ved hjelp av kjernemoduler å få til her også. At det meste av koden vil kjøre direkte på hardware. Men Hypervisor vil hele tiden kontrollere, og ikke minst hvis Gjeste-OS, Gjør et kall til kjernen, så vil det trappe til hypervisor. Og så tar den kontroll. OK. Vi skal se noen eksempler på KVM-virtualisering litt senere. Binær oversettelse. Før 2005 så måtte alternative metoder brukes uten hardwarestøtte. At hvis man ikke gjorde det, så fikk man problemer med", "source": "lecture"}
{"lecture_id": "linux10del7", "chunk_id": "linux10del7_0002", "start": 319.56, "end": 484.0, "token_count": 467, "text": "At det meste av koden vil kjøre direkte på hardware. Men Hypervisor vil hele tiden kontrollere, og ikke minst hvis Gjeste-OS, Gjør et kall til kjernen, så vil det trappe til hypervisor. Og så tar den kontroll. OK. Vi skal se noen eksempler på KVM-virtualisering litt senere. Binær oversettelse. Før 2005 så måtte alternative metoder brukes uten hardwarestøtte. At hvis man ikke gjorde det, så fikk man problemer med de institusjonene som ikke trappet. Da lagde VMWer en hypervisor som mens programmet kjørte, så skannet den koden og så etter sensitive instruksjoner. Typisk sensitive institusjoner som ikke trapper til kjernen. Da gjorde den det for hver kodeblokk som endte i jump, call, trap eller lignende. Hvor du ønsket å snakke med kjernen. Så ble disse sensitive institusjonene oversatt til kall i WMW-prosedyrer inni hypervisoren. Og da fikk man til å kunne kjøre disse kodebitene veldig effektivt. Og i enkelte tilfeller så kunne han faktisk få det til å kjøre enda mer effektivt enn om man kjørte direkte på bare metal. Et problem med hardware-støttet virtualisering er at det genererer mange traps. Hver gang Gjeste-OS gjør et kall som trapper, så tar det litt ekstra tid. Paravirtualisering er en type virtualisering som gjør at gjeste-OS må endres. Derfor er ikke det helt optimalt, for da må man inn og gjøre endringer i gjeste-OS. Det som kan være en fordel, er at da kan man ha egne drivere som er laget for paravirtualisering, og det er en veldig effektiv metode. Men stort sett brukes det ikke så mye. Det er viktig at vi tåler det selv.", "source": "lecture"}
