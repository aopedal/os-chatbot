{"lecture_id": "os14del4", "chunk_id": "os14del4_0000", "start": 0.0, "end": 186.08, "token_count": 600, "text": "Det jeg skal se på, er et STED-program. Vi skal se i detalj på hvordan det virker. Men det vi aller først ser her, er at vi definerer et stort RA. Og da har jeg definert et tall S, som er 1024 ganger 1024. Dette er bare for at jeg skal få... Én megabyte, eller det vil si... Det er et int RA. Altså én int er fire bite, så derfor blir dette fire megabyte. Dette er da et RA som tar... Hvis størrelsen er fire megabyte. Men før vi gjør det, så kan du... Altså... Det første vi skal gjøre, er å se på hva som skjer når vi deklarerer dette RA-et, og så begynne å kjøre. Så ser vi at det stopper ved første linje og skriver ut størrelse kolon. Og Scanf leser inn den variabelen. Så det programmet vil skrive ut størrelse, og så vil det stoppe der. Etterpå skal vi se hvordan vi da kan lese inn størrelsen på dette. Og så allokere det med Mallock. Men vi ser først bare på starten. Og da trenger vi bare å bry oss om de tre første linjene her. Så kanskje det kan gjøres. Aller først er det bare å lage et bitte lite array med én bite. For det vi skal se på nå, er hvordan... Hvordan ser det ut i topp når vi kjører dette programmet? Og programmet heter Res, så jeg compilerer det sånn. Og så kjører jeg det med Adopt Out. Da ser vi jeg blir bedt om størrelse. Det jeg ønsker å gjøre nå, er å se på det i Topp. Og da har jeg en litt smart kommando her som ser sånn ut. Den sier Topp minus P. For nå ønsker jeg å se på akkurat bare Topp for dette programmet. Og når jeg gjør Topp minus P, der kan jeg spesifisere hvilken payday jeg vil se på. I tillegg - paydayofa.out. Jeg kan gjøre det eksplosivt. Den gir meg da hvilken payday A.out har. Så dermed kan jeg starte Topp på den måten her. Og så får jeg se bare info om A.out. Og det er denne infoen her om minnene som vi skal se på nå. Tidligere har vi sett på payday og priority and nice osv. Men nå skal vi se på... De tre bitene der. VIRT, DRESS og SHELL.", "source": "lecture"}
{"lecture_id": "os14del4", "chunk_id": "os14del4_0001", "start": 142.66, "end": 352.12, "token_count": 595, "text": "Og når jeg gjør Topp minus P, der kan jeg spesifisere hvilken payday jeg vil se på. I tillegg - paydayofa.out. Jeg kan gjøre det eksplosivt. Den gir meg da hvilken payday A.out har. Så dermed kan jeg starte Topp på den måten her. Og så får jeg se bare info om A.out. Og det er denne infoen her om minnene som vi skal se på nå. Tidligere har vi sett på payday og priority and nice osv. Men nå skal vi se på... De tre bitene der. VIRT, DRESS og SHELL. Og kortversjonen er at VIRT, det er på en måte det virtuelle adresserommet. Det er så mye som er definert for denne prosessen. Altså så mye ram. Og ram her er definert i K. Så dette betyr at det er 4516. Med virtuelt adresserom. Så det er det som det lages plass til for hele prosessen. Alt den inneholder. Og så kommer det en kolonne som heter Ress. Her ser vi det er 748 K. Og Ress, det er det som er resident. Altså det som ligger i RAM nå, og som er i bruk. Så ligger alt, men det er ikke alt som er i bruk. Og det kommer ikke nødvendigvis i bruk. Det spørs hvordan programmet kjøres. Men hvis mer tas inn i RAM, så skal vi se. Da vil RES øke. Men det vi først kan se, er VIRT gir 4516 K. Og så kan vi prøve å se... Å lage det RA-et på nytt, men denne gangen lage... En 4 MB RA. Så da stopper jeg programmet igjen. Så går jeg inn her og bruker den opprinnelige S-faktoren. Og da... Bare for å se hva som skjer, så kan jeg regne litt her nede. 1024 ganger 1024... Ja, det blir omtrent én million. Men det jeg egentlig er interessert i, det er hvor mye vil... Hvor mye vil Virt øke når jeg legger på et r-øy? Så da må jeg kanskje ta med og... Skal vi se hva vi hadde her. Sånn. Og så skal jeg nå øke... Nå burde jo den VIRT-adresserommet øke med fire ganger 1024 ganger 1024. Det vil si den burde da øke med fire ganger 1024. Eller...", "source": "lecture"}
{"lecture_id": "os14del4", "chunk_id": "os14del4_0002", "start": 306.24, "end": 546.54, "token_count": 588, "text": "Men det jeg egentlig er interessert i, det er hvor mye vil... Hvor mye vil Virt øke når jeg legger på et r-øy? Så da må jeg kanskje ta med og... Skal vi se hva vi hadde her. Sånn. Og så skal jeg nå øke... Nå burde jo den VIRT-adresserommet øke med fire ganger 1024 ganger 1024. Det vil si den burde da øke med fire ganger 1024. Eller... Ja, vi kan skrive 4 ganger 1024. Fire ganger 1024. For det er K vi snakker om. Da burde det komme 8612 K. Så skal vi se hva som skjer her, da. Om vi får til det. Jeg kompilerer nå på nytt med det store r-eiet med én million integer. Så må jeg starte topp på nytt for å få med den... Riktig add-add-out. Og da ser vi... Jo, det flingerer faktisk akkurat. Da står det 8612 her, som er da... Det opprinnelige adresserommet vi hadde. Så har vi i tillegg definert fire... Hva blir det? Fire megabyte. 4 ganger 1024 K. Og da får vi akkurat den størrelsen der i hvitt. Men vi ser... Så det... Det passet akkurat med teorien. Men vi ser... Ress her er fortsatt 748. Så kan det spørres hvorfor... Hvorfor ble ikke den endret? Hvis vi ser i koden her, så har vi bare kommet hit. Så vi har ikke begynt å bruke det static-reiet i det hele tatt. Så etter hvert som man begynner å bruke det, så vil den vil da kunne øke. Men i stedet for å bruke det, så skal vi se nå på hvordan vi kan legge til statisk minne. Men... Nå glemmer vi den første. Og så... skal vi se på statusen min. Det er ett spørsmål i chatten her. Kjempebra. Stopp å spørre. Vi... Én int er fire bite. Så for det første så ble... Én int er fire bite. Og så i tillegg... Så dette... Dette teller jo opp antall elementer. 1024 ganger 1024, det er én mega. Men det vil også si at når vi regner i K, så er dette 1024 K. 1024 bite, det er én K.", "source": "lecture"}
{"lecture_id": "os14del4", "chunk_id": "os14del4_0003", "start": 485.8, "end": 725.92, "token_count": 592, "text": "Og så... skal vi se på statusen min. Det er ett spørsmål i chatten her. Kjempebra. Stopp å spørre. Vi... Én int er fire bite. Så for det første så ble... Én int er fire bite. Og så i tillegg... Så dette... Dette teller jo opp antall elementer. 1024 ganger 1024, det er én mega. Men det vil også si at når vi regner i K, så er dette 1024 K. 1024 bite, det er én K. Så dermed ble totalstørrelsen på dette ærøyet, dette her, det ble fire ganger 1024 K. Eller fire ganger 1024 ganger 1024 bite. Så derfor ble det fire ganger 1024. Fire ganger 1024 ganger 1024... Er lik 4096 K. Så det er det som var de fire ganger 1024 her nede. Ok. Da skal vi gå tilbake. Så skrur jeg av det ri her, og så skal vi se det lage... et like stort ri dynamisk. Da stopper jeg Adatalt igjen. Sånn. Og så ser vi... Ja, da kan vi egentlig bare kompilere det programmet her. Og starte det. Så kan vi gå og se på topp hva som skjer. Så er det 4516. Det er da... Det vi starter med i utgangspunktet. Og så kan vi prøve å regne ut... Vi kan prøve å lage et r-e som er like stort, som har så mange elementer. Og når vi ser i koden her... Scanf, den leser inn... Med prosent d, så leser den inn Det som skjer i programmet når jeg skriver inn noe her, det er det blir lest inn... Jeg skriver ut lager interrøy med det antallet elementer. Og her er det en kommando mallock. Mallock er opplagt en... Må opplagt gjøre et kall til kjernen, et systemkall, for å be operativstemma om å allokere minner. Og da ser vi... Det jeg sender med, er size. Det er den størrelsen i tallet. Ganger size of int. Size of int pleier å være 4. Det kan også i prinsippet endres. Men dette gir da... Størrelsen i bite som jeg ønsker å lokkere til her. I C er det... Skal ikke gå for mye inn på det, men dette er da en...", "source": "lecture"}
{"lecture_id": "os14del4", "chunk_id": "os14del4_0004", "start": 678.76, "end": 854.2, "token_count": 594, "text": "Må opplagt gjøre et kall til kjernen, et systemkall, for å be operativstemma om å allokere minner. Og da ser vi... Det jeg sender med, er size. Det er den størrelsen i tallet. Ganger size of int. Size of int pleier å være 4. Det kan også i prinsippet endres. Men dette gir da... Størrelsen i bite som jeg ønsker å lokkere til her. I C er det... Skal ikke gå for mye inn på det, men dette er da en... En adresse. Når du definerer et r-øye, så definerer du adressen til første punkt i r-øyet i minnet. Så det er da en minneadresse. Men etterpå bruker vi r-øye akkurat som med Java. Nå står det 'klar til å bruke r-øye'. Og så har jeg en løkke her hvor jeg går gjennom alle elementene og skriver til det. Og så stopper jeg bare med å vente på å avslutte. Men da ser vi... Her går jeg i gang og faktisk bruker r-øyet. Og det skal vi se på hvordan det funker i res. Men aller først... Vi har virtuelt 4516. Og så sier jeg... OK, jeg ønsker et så stort ære. Og da så vi... Da spratt den der opp til 8616. Det ble litt mer enn forrige gang, hvis du husker det regnestykket der. 8-6-12. Det ser ut som det er 4K som bør brukes av ramm til å administrere et eller annet rundt... Sannsynligvis bruker Mallock noe ekstra ramm i tillegg til akkurat det som setter seg til her. Men foreløpig er det bare i virt. Det er bare den biten som har endret seg. Men nå klarte jeg å bruke r-øye, så da kan jeg sende meg hva som helst. Den bare leses, egentlig bare for at det skal stoppe. Så begynner jeg å bruke r-øye, og da så vi at det tok litt tid, og så spratt den opp i 5384. Og da, hvis en fulgte godt med, så jeg at det var kanskje noe sånn som... Hva var det det sto her? 700 og noe. Det ble ikke helt riktig... Altså... Eller riktig... Det skulle blitt noe sånt som 700 pluss 1466. Men vi ser at det ble en del mer.", "source": "lecture"}
{"lecture_id": "os14del4", "chunk_id": "os14del4_0005", "start": 816.68, "end": null, "token_count": 426, "text": "Den bare leses, egentlig bare for at det skal stoppe. Så begynner jeg å bruke r-øye, og da så vi at det tok litt tid, og så spratt den opp i 5384. Og da, hvis en fulgte godt med, så jeg at det var kanskje noe sånn som... Hva var det det sto her? 700 og noe. Det ble ikke helt riktig... Altså... Eller riktig... Det skulle blitt noe sånt som 700 pluss 1466. Men vi ser at det ble en del mer. Og det er tydeligvis en del mer som hentes inn i RAM og brukes aktivt. Men vi ser i hvert fall... Med en gang man da bruker dette her, så kommer det i bruk som i RAM. Registreres i MMU osv. Og da dukker det opp som RES her. Og når man kjører programmer og ser og kanskje har mine problemer, så er det veldig viktig å se hvite forskjeller på dette her. Du kan ha et kjempestort hvitt, men så lenge det ikke er i bruk i RES, så er det ikke tungt for systemet. Så det er den viktige forskjellen på de to målene her - på hvor mye... Veldig kort til slutt om SHR, eller Shared. Det er da minnet som deles med andre programmer. F.eks. så kan det være dynamisk bibliotek. Stort sett så fins det noen dynamiske bibliotek som brukes. F.eks. C-bibliotek som da deles.  Det så vi på sist, at vi kunne lage statisk bibliotek som blir kompilert inn i programmet. Da vil det være en del av Virt og en del av Ress. Men dynamiske bibliotek, de er da... De vil da dukke opp som sjel.", "source": "lecture"}
