{"lecture_id": "os7del16", "chunk_id": "os7del16_0000", "start": 0.0, "end": 241.6, "token_count": 589, "text": "Jo, vi har sett at operativsystemet fordeler prosesser på CPU-er. Men nå skal vi se på en metode vi kan bruke for å selv spesifisere hvilken CPU en oppgave skal kjøres på. Og det kan vi gjøre med TaskSet. Og da kan vi... Men programmet Tasset er et verktøy som gjør at vi kan si... Tasset minus C null sier plasser den følgende jobben på CPU0. Så når jeg kjører denne regnejobben her nå, så sier jeg:\"Den skal så på CPU0.\" Og kanskje... Ja... Hvis vi kjører AgeStop, kan vi kjøre Toppe og så skru på Last Used CPU. For å se hvor den kjører.  Der har vi med Last Jus CPU. Så sier jeg start den på tasset, kjør den på prosessor 0, og da ser vi - den kommer på prosessor 0. Hvis jeg i stedet sier kjør den på prosessor 1, så ser vi - da starter den å kjøre på 1. Vi gjør noen interessante eksperimenter, for da kan vi eksplisitt saye at nå vil jeg kjøre begge regnejobbene på prosessor 1. La oss bruke adatat, som er litt raskere. La oss si nå at jeg skal starte to regnejobber. Men så vil jeg da time task-sett. Og så vil jeg sette begge på null. Sånn. Og nå vil begge de to regnejobbene kjøre på... ... på samme prosessor. Og da ser vi... Da brukte de... Da får de bare 50 % CPU. Fordi da har jeg eksplisitt satt dem på den samme CPU-en. Hvis jeg i stedet hadde satt de på CPU1 og -2 på den måten, da ville de to regnejobbene kjørt på hver sin CPU. Da gjør vi sånn som operativsystemet ville ha gjort det. Satt de på hver sin CPU, og det går da dobbelt så fort. Helt til slutt så kan vi se litt på... Se litt på hvordan man kan... Finne ut hvilke CPU-er som tilhører hvilken... Nei... Hvilke par det er av CPU-er som er hyperthroding. Denne Threadsiblings-list som jeg lister her, det er en liste over hvilke CPU-er som hører sammen. I dette tilfellet så er det CPU-110 og -4 som egentlig er 30 deciblings.", "source": "lecture"}
{"lecture_id": "os7del16", "chunk_id": "os7del16_0001", "start": 189.6, "end": 389.54, "token_count": 600, "text": "Satt de på hver sin CPU, og det går da dobbelt så fort. Helt til slutt så kan vi se litt på... Se litt på hvordan man kan... Finne ut hvilke CPU-er som tilhører hvilken... Nei... Hvilke par det er av CPU-er som er hyperthroding. Denne Threadsiblings-list som jeg lister her, det er en liste over hvilke CPU-er som hører sammen. I dette tilfellet så er det CPU-110 og -4 som egentlig er 30 deciblings. Som er de to som da deler på aluen. Helt til slutt så kan vi prøve å se om det er tilfellet. For jeg kan... Først kan jeg kjøre regnejobber på denne måten. Den første settes på CPU1, og den andre settes på CPU2. Hvor lang tid tar det nå å kjøre den regnejobben? Jo, det tar 18 sekunder. Men så kan jeg i stedet si... OK, nå vil jeg eksplisitt sette de to jobbene på 0 og 4. Dette betyr nå... Kjørte den ene på null, og kjørte den andre på fire. Og det var ikke tilfeldig valg, for nå har jeg bedt dem om å kjøre regnejobbene på den samme hyperthreading CPU-en. Så nå er det null og fire. De er siblings. Det betyr de deler på en del av hardwaren, inkludert CPU-en. Så nå ser vi straks at dette tar lengre tid. De står på 0 og 4. Kunne du se at de står på 0 og 4 her? Men tiden det tok... Den var nå... Den ble da plutselig så godt som doblet. Og det er fordi 0 og 4... Det er akkurat samme kommandoen her. 1 og 2. I stedet her så kjører de på 0 og 4. Og da er de på samme hypertrenings-IPU. Og da må de bytte på å dele aluen. Og dermed så går det dobbelt så lang tid å få det ferdig. OK... Jeg ser det er noen spørsmål i chatten her. Hadde også tatt fire sekunder om du kun kjørte ett, ja. Det var litt tilbake her. Men hvis jeg bare kjører én, så tar det også fire sekunder. Så om man kjører... Så... Hvis jeg bare kjører én prosess sånn som dette, så tar det fire sekunder.", "source": "lecture"}
{"lecture_id": "os7del16", "chunk_id": "os7del16_0002", "start": 346.68, "end": 482.0, "token_count": 404, "text": "Og da må de bytte på å dele aluen. Og dermed så går det dobbelt så lang tid å få det ferdig. OK... Jeg ser det er noen spørsmål i chatten her. Hadde også tatt fire sekunder om du kun kjørte ett, ja. Det var litt tilbake her. Men hvis jeg bare kjører én, så tar det også fire sekunder. Så om man kjører... Så... Hvis jeg bare kjører én prosess sånn som dette, så tar det fire sekunder. Og hvis jeg da kjører fire uten noe task-sett eller noe som helst... Hvis jeg ikke bruker task-sett... Og kjører... fire prosesser... Så er dette fire helt uavhengige CPU-er. Og de bruker da like lang tid som om vi kjører én. Vi kan se noen ganger at det tar litt mer tid. Det er fordi at da kjører du 100 % på alle fire CPU-ene på en server. Og det er alltid noe prosesseringskraft som trengs på en server for å styre alle andre prosesser. Du ser at det går litt mer tid. Men generelt sett så tar det omtrent fire sekunder. Om du kjører på én, eller om du kjører på fire. Men som vi har sett, når vi da kjører på alle åtte, så tar det nesten dobbelt så lang tid fordi det egentlig er hypentreding. AMD har det samme som på din AMDoc-serveren som dere har containere. Den har også... Hypertrening, eller AMDs hypertrening, som er SMT. Simultaneous Multitreading. Det er det også på den serveren.", "source": "lecture"}
