{"lecture_id": "os9del3", "chunk_id": "os9del3_0000", "start": 0.0, "end": 226.56, "token_count": 591, "text": "Ok. Da skal vi begynne å se på det vi skal gjøre i dag. Aller først skal vi se litt på systemkall og timertics. Vi kunne jo starte aller først med sist. Da håper jeg dere har fått med dere den forelesningen med vafler. Og jeg lager vaffelrøre og foreleser samtidig. Og det er langt fra bare på tull. Jeg håper at den illustrerer på en god måte hvordan et operativsystem virker, og da spesielt scheduleren, som schedulerer mellom de prosessene som skal stå og kjøre. Så jeg vil bruke en del referanser til dette, f.eks. dette med cornal mode. Med en gang en timer interrupt kommer, så setter jeg på hjelp. Og da kjører jeg i kernel mode. Og da er det kjernen som stiller. Og det... Ja. Det er litt av det vi skal se på nå med systemcall. For som dere husker for eksempel når jeg skulle knuse egg... Det var typisk noe som man ikke kan gjøre i UseMove. Da må man inn og bruke hardware ressurser. Og da må man gjøre et systemcall. hvordan systemkall fungerer. Da skal vi se det i et terminalvindu. Her. Så... Her har jeg et se-program. Og det set-programmet... Det utfører et systemcall en rekke ganger. Så get pay-pay-id. Det er faktisk et systemcall. Og i C så er mange av Linux-systemcallene implementert direkte. Sånn at jeg kan utføre et systemcall direkte med en metode. Det er det umulig å kalle get payPay. Og det er da get parent ID. Så vi skal ikke bruke den i den, men vi skal bare se hva som skjer når man utfører ti millioner systemcall på kort tid. Så jeg kan da prøve å kompulere get payID, og så kan jeg kalle det get payPayID. Sånn. Sånn. Da får jeg et program som heter Get PPID. Og så kan jeg kjøre det. Da ser jo vi at det skjer ikke så mye. Men det som skjer i bakgrunnen, er at vi kjører det 10 000 ganger. Men det jeg egentlig ønsker å se på, er hvor mye av dette foregår nå... Og hvor mye i Kölnmold. Så da kan jeg åpne en annen fil som heter... Hva kalte jeg den? Syss.", "source": "lecture"}
{"lecture_id": "os9del3", "chunk_id": "os9del3_0001", "start": 180.0, "end": 373.84, "token_count": 589, "text": "Sånn. Da får jeg et program som heter Get PPID. Og så kan jeg kjøre det. Da ser jo vi at det skjer ikke så mye. Men det som skjer i bakgrunnen, er at vi kjører det 10 000 ganger. Men det jeg egentlig ønsker å se på, er hvor mye av dette foregår nå... Og hvor mye i Kölnmold. Så da kan jeg åpne en annen fil som heter... Hva kalte jeg den? Syss. Her er et lite program med syss.shell. Og det det gjør, det prøver å telle opp antall tics. Som kjøres. Og da er det antall tics i use-emboved og i curler-mode. Og vi har sett tidligere på Proc at her så ligger det informasjon dynamisk om hver prosess som kjøres. Og det dette programmet gjør, er at det først så ser det på en linje som inneholder CPU3 i ProcSat. Og denne linjen... Den inneholder all informasjon om TIX som kjøres av CPU3. Og TIX, eller GIFFIS, som det ofte omtales, det er den minste tidsenheten, som typisk er et hundredels sekund. Den kan varieres, men i praksis vil jeg si at den ofte er et hundredels sekund. Og det er akkurat det samme som... Kjøkkenklokka jeg hadde i vaffelsimuleringen, som bruker ett minutt. Men i det virkelige tilfellet, eller i dette tilfellet, så bruker den da 100 sekunder. Og så er det i Proxats statistikk som teller opp hvor mange tics brukes i user mode, og hvor mange tics brukes i curl mode av systemet. Og det telles opp for hver prosess. Det er en... Vi har en oppgave denne uken. Dere skal se på hvor mange tics en regnejobb bruker. En regnejobb som regner hele tiden, bruker vanligvis 100 tics per sekund. Så hvis dere teller opp for en regnejobb, bør det komme opp med ca. 100 for hvert sekund. For den kjører bare beregne-i. Men her, når vi gjør den get-paid-a, pluss noen andre instruksjoner, Så skal vi se at det blir litt forskjellig. Så vi kan prøve å kjøre den SUS. Da ser vi... Den skriver ut...", "source": "lecture"}
{"lecture_id": "os9del3", "chunk_id": "os9del3_0002", "start": 333.9, "end": 531.92, "token_count": 600, "text": "Dere skal se på hvor mange tics en regnejobb bruker. En regnejobb som regner hele tiden, bruker vanligvis 100 tics per sekund. Så hvis dere teller opp for en regnejobb, bør det komme opp med ca. 100 for hvert sekund. For den kjører bare beregne-i. Men her, når vi gjør den get-paid-a, pluss noen andre instruksjoner, Så skal vi se at det blir litt forskjellig. Så vi kan prøve å kjøre den SUS. Da ser vi... Den skriver ut... Den skriver ut linjen for CPU3, og så kjører den... ... get payday, og så skriver den ut linjen igjen. Dermed kan vi se hvordan tallene øker. Og da ser vi at det er to tall som øker. Det er den, den kolonnen, og så er det den. Det kan være nyttig å vite hvordan... Hvordan vet jeg hva disse tallene er? Det er også nyttig i denne oppgaven dere har, men da kan man se på ManProk. Vi kan søke på akkurat de feltene i Prok. Her kan vi søke på Prokstat. Og under Prokstat så kan vi se at det står at det er linjer her. Da blir det veldig mye info. Vi kan ta med Prokstat, så skal vi se... Første delen av Prokstat er ganske ok. Her er et total... Oppsummert all statistikk for alle CPU-ene. Og så ser vi det for hver enkelt CPU nedover her. Så det vi ser på nå, er CPU3. Og så må man også vite hva kolonnene betyr. Og vi ser første kolonne er user. Det er time spent in user mode. Altså det er antall tics spent eller brukt i user mode. Og så er det andre kolonne er nice. Det er det ikke så mange av, men vi skal se på det senere i dag. Men så kommer den tredje kolonnen som er time spent in system mode. Fjerdekolonnen Idol av den fjerdekolonnen er ofte veldig stor. Så den er størst. For stort sett så idler disse CPU-ene. Så de gjør ingenting. Så summen av Idol er vanligvis størst. Men vi ser da at vi kan konsentrere oss om user mode. Det er da antall tics som blir brukt... Av getPPID. Vi kan kjøre det en gang til. Og så... Ja. GetPPID, den bare står og gjør systemcall.", "source": "lecture"}
{"lecture_id": "os9del3", "chunk_id": "os9del3_0003", "start": 487.08, "end": 725.88, "token_count": 595, "text": "Fjerdekolonnen Idol av den fjerdekolonnen er ofte veldig stor. Så den er størst. For stort sett så idler disse CPU-ene. Så de gjør ingenting. Så summen av Idol er vanligvis størst. Men vi ser da at vi kan konsentrere oss om user mode. Det er da antall tics som blir brukt... Av getPPID. Vi kan kjøre det en gang til. Og så... Ja. GetPPID, den bare står og gjør systemcall. Men vi kan jo se hva den der gjør. Så først så grepper vi på SUPU3. Da får vi ut den linjen her. Og det tallet her, 2 606 714, det er antall tics som er kjørt i user mode. Og så ser vi... Forskjellen her er at den blir 7071. Hvordan jeg søkte på ManPedge... Det er et godt spørsmål, så jeg kan ta det. Når jeg har en mann-side oppe, så taster jeg slash. Sånn. Og da står det en slash nederst til venstre, og så skriver jeg prok.stat. Og så kommer jeg dit. Hvis jeg skal finne neste, så taster jeg N. Men la oss si jeg ser på Stad, da. Så taster jeg N, så kan jeg bla meg nedover. Så det er veldig nyttig. Men jo, vi så på det tallet her. Vi kan kjøre den en gang til, vi. Så blir det litt lettere å se. Sånn, ja. Den har hoppet over fra 7000 her. Men her kan vi se... Usertics... 2608 920 minus usertics her... 574. Og det... Det burde bli 354 usertics.  Og det betyr 354 hundredels sekunder. Er det ikke det, kyss...? Nei, vent litt. Det ble 26. Det er... 44 blir det vel. Nei, det kan det ikke bli. 46. Ja, det er litt tidlig for hoderegning. Det er forskjellen i user tics, og dette er antall hundredels sekunder som det programmet vi kjørte, brukte i user mode. Og så kan vi se på sys, og det er her. Det ser vi blir litt færre. Der har den kommet opp i 5000 der. Minus dette tallet. Så det blir 136. 149, skulle det bli... 149 sånn. Og det betyr 1,49 sekunder. Men så kan man jo også...", "source": "lecture"}
{"lecture_id": "os9del3", "chunk_id": "os9del3_0004", "start": 677.76, "end": 911.98, "token_count": 593, "text": "Ja, det er litt tidlig for hoderegning. Det er forskjellen i user tics, og dette er antall hundredels sekunder som det programmet vi kjørte, brukte i user mode. Og så kan vi se på sys, og det er her. Det ser vi blir litt færre. Der har den kommet opp i 5000 der. Minus dette tallet. Så det blir 136. 149, skulle det bli... 149 sånn. Og det betyr 1,49 sekunder. Men så kan man jo også... For å teste dette her så kunne man kjøre time. 3.56 har det en som sier det. Ja, da har du sikkert rett i det. Nei, 56. Blir ikke det for mye? Ja, det er ikke så farlig. Vi kan se på dette tilfellet i stedet. Nå kjører jeg i time på cyst.so, og da kan vi se nøyaktig hva disse tallene betyr, for her kommer det opp noe tilsvarende. Realtime 4,9 sekunder, user 3.531 og 1.418. Og disse skal da tilsvare hverandre. Og da kan vi forhåpentligvis se... Hvis vi nå prøver å trekke fra, da er det 180 pluss 172. Ja. Det skulle bli 3... Ja, jeg kan... Det jeg ofte gjør når jeg skal regne, er bare å... Jeg har lagd et lite program som regner for meg. Så jeg slipper å gjøre hoderegning. 3.52, ja. Det var en som hadde fått med seg det. 3.52 ble det riktige. Så kan vi ta antall tics i use mode minus antall tics nei, antall tics i kernel mode minus antall tics i kernel mode, er 141. Og da ser vi... Dette stemmer med det som Time sier. Og det gjør det, for det er den... Det er liksom den samme informasjonen som Time bruker for å få opp. Så her... Dette er hundredels sekunder, så dette er 3,52. Så er det lite grann forskjell, og så er det 1,41. 3,52 i Use as Moved og 1,41 i System as Moved. Så alt i alt det dette betyr, det er at når vi kjører dette programmet... Så her gjør vi systemcall, og da ber vi systemkjernen gjøre dette her. Og da vil... I 1,41 sekunder så kjører vi i kernel mode.", "source": "lecture"}
{"lecture_id": "os9del3", "chunk_id": "os9del3_0005", "start": 863.88, "end": 1095.0, "token_count": 597, "text": "Så her... Dette er hundredels sekunder, så dette er 3,52. Så er det lite grann forskjell, og så er det 1,41. 3,52 i Use as Moved og 1,41 i System as Moved. Så alt i alt det dette betyr, det er at når vi kjører dette programmet... Så her gjør vi systemcall, og da ber vi systemkjernen gjøre dette her. Og da vil... I 1,41 sekunder så kjører vi i kernel mode. Og i 3.52 så kjører vi i use mode. Hvis jeg hadde gjort det tilsvarende her med en regnejobb, så ville man sett at man bare kjørte i... I rusebåt. Vi kunne jo teste det også. La meg da i stedet kjøre regn her. Da står vi og regner. Får håpe den ikke er altfor lang når mulig. Mulig den tar litt for lang tid. Den så ut til å ta litt lang tid, så jeg prøver på nytt med en kortere utgave. Og da ser vi... Da har det ikke skjedd noe i køllmod. Her er statistikken den samme. Ingen tics har blitt utført i køllmod. Mens her borte... Her er alle ticsene kjørt. Så da står han og kjører i jusemode heltid. Det er spørsmål om det blir samme tidsbruk hvis man kjører time alene. Det blir bitte lite grann forskjell siden du skriver ut prokk også, for det gjør også noen tics, men det er veldig få tics som går med til dette. Er dette fordi man må gå i curl-mode for å få gjort et suksessopphold? Ja, absolutt. Det er det. Så vi ser her når jeg kjører en regnejobb, sånn som dette, Da sier operativstemme at 'dette her er helt ufarlige greier'. 'Du trenger ikke noe disk eller noen ting', så du skal bare regne'. Så da kjører den prosessen i use mode hele tiden. Og dermed så ser vi at det er kun use mode tics som brukes. Og vi vil jo også se det samme... Det har vi sett tidligere når vi kjører regn sånn. Kun user mode som kjører. Mens når vi ser på denne get PPP-id, så er dette et systemkall. Og da går man inn i kjernen, og det er kjernen som utfører det.", "source": "lecture"}
