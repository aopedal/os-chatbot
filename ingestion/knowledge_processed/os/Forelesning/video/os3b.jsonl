{"lecture_id": "os3b", "chunk_id": "os3b_0000", "start": 0.0, "end": 157.2, "token_count": 596, "text": "Så forelesningen blir tatt opp. Aller først, før vi starter, så skal vi få et lite innslag om studentutveksling. Og det er en som dere kanskje kjenner fra... Eller dere som har hatt diskré matematikk, kjenner Eva derfra. Hun er faktisk min kone. Så... Så hun kommer nå fysisk inn på forelesningen og tar over i fem minutter. Ja, hei. Nå er jo ikke jeg her i rollen som lærer, men jeg er her som fagkoordinator for utvekslingsstudier. Og dere har mulighet til å dra til utlandet i femte semester, de av dere som ønsker det. Og hvis dere har lyst til det, så kan dere gjøre det. Dere kan sende meg en mail, og så kan vi ta et Zoom-møte og snakke om det. Men jeg tenkte også at vi skulle nå bare vise dere den siden som dere kan gå inn på. Her ser dere denne utvekslingssiden hvor dere kan gå inn på det studiet dere holder på med. F.eks. bachelor i ingeniørfag. Nei, det var biokjemi. Skal vi se om vi finner ingeniørfagdata. Der kan dere lete dere ned. Og se hvilke steder dere kan dra ut. Det er litt avhengig av hvilket semester dere er i. Så dere må kikke litt på det også. Men uansett så er det viktigste dere trenger å vite nå, er at fristen er 1.2. Så send meg en mail litt tid før det, hvis dere er interessert. Og så innen 1.2. må dere sende en søknad. Det står her på denne siden hvordan det gjøres. Og så sender dere også et motivasjonsbrev pluss en... Man vil kikke. Det er viktig at dere har de nødvendige studiepoengene for å reise ut, samtidig som dere noen steder krever en gjennomsnittskarakter på C eller bedre. Nå er det ikke 100 % sikkert at det blir noe av utvekslingsstudiene til høsten, nettopp fordi det er jo koronatider rundt om. Og hvordan denne pandemien vil se ut om et halvt år, det er noe usikkert. Det ble avlyst i fjor, men vi har et visst håp om at det skal skje. Det var alt jeg ville si. Gå inn på denne utvekslingssiden her.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0001", "start": 126.32, "end": 340.64, "token_count": 597, "text": "samtidig som dere noen steder krever en gjennomsnittskarakter på C eller bedre. Nå er det ikke 100 % sikkert at det blir noe av utvekslingsstudiene til høsten, nettopp fordi det er jo koronatider rundt om. Og hvordan denne pandemien vil se ut om et halvt år, det er noe usikkert. Det ble avlyst i fjor, men vi har et visst håp om at det skal skje. Det var alt jeg ville si. Gå inn på denne utvekslingssiden her. Se hvor dere kan dra, ut fra hvilket studiepoengprogram dere er på og hvilket semester det gjelder. Frist er 1.2. Flopp. Ha det bra. Unnskyld? Ja, kom igjen. Hører du meg? Ja. Jo, jeg lurte litt på hvordan er det med finansiering? Hjelper skolen deg med det? Nei, det er jo avvilga. Det er steder dere skal på. Noen er gratis, og andre steder er det studiepenger. I USA f.eks. så pleier det å koste penger. Men Lånekassen pleier å være behjelpelig med å kunne bidra og låne de. Det er noe man må se på i hvert enkelt tilfelle. Jeg vil oppfordre til de av dere som har tenkt å slukke, å sende meg en mail. Så kan vi ta et Zoom-møte og se på det aktuelle studiestedet dere er interessert i. Da overlater jeg ordet til Hårek igjen. Yes. Da skal vi fortsette med datamaskinarkitektur. Og da skal jeg først vise dere en liten krets. Denne her. Og så har jeg en poll med to spørsmål. Jeg skulle egentlig hatt to poller, men det første spørsmålet er til denne figuren. Så dere må se på den først, og så svare. Så skal jeg vise dere figur nummer to, og da kan dere svare på spørsmål nummer to. Så... denne figuren er da spørsmål én er til den figuren dere ser, med input D, og så er det en X og Q. Og spørsmålet er, hvis input D er lik 1, hva blir da den verdien X her inn til denne rapporten, og hva blir verdien...? Så se litt på den figuren, og så svar når dere har kommet frem til en løsning på det.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0002", "start": 296.48, "end": 635.12, "token_count": 595, "text": "Så dere må se på den først, og så svare. Så skal jeg vise dere figur nummer to, og da kan dere svare på spørsmål nummer to. Så... denne figuren er da spørsmål én er til den figuren dere ser, med input D, og så er det en X og Q. Og spørsmålet er, hvis input D er lik 1, hva blir da den verdien X her inn til denne rapporten, og hva blir verdien...? Så se litt på den figuren, og så svar når dere har kommet frem til en løsning på det. Når dere er ferdige på spørsmål 1, så ikke begynn å se på spørsmål 2. For da kommer det en annen figur. Her er en controller input. Hvis du ser en lignende, men litt annerledes figur, hvor du har kontroller... Men, ja... vi kan godt bruke et par minutter på hver av de, eller kanskje litt mer. Hvis dere trenger mer tid. Takk. Jeg ser... Ja. Kanskje du så det. Det er flere som har skrevet at du har litt dårlig nett. Men... vi kommer tilbake til det. Men til de som... Hos meg kommer ikke det opp, så... Nei, men til de som svarer, ikke svar på spørsmål nummer to, for der har dere ennå ikke fått oppgaven. Det er en annen figur til spørsmål nummer to. Så svar foreløpig bare på oppgave. Ja, tilbake til nettet. Jeg fikk en melding jeg sa om dårlig nett. Jeg kan kjøre en test og så se. Mens dere holdt på med quizen. Takk for møtet. Ha det bra! Ja, jeg ser opplastningen er litt opp og ned. 17 megabit per sekund, det er kanskje i underkant. Men jeg ser det er litt variasjon, det går litt opp og ned, så... Ja, si ifra hvis... Si ifra hvis problemene fortsetter, så kan jeg f.eks. stenge av videoen, det kan hjelpe. OK. Det ser ut som det var vanskelige spørsmål, dette her. Vi kan uansett gå gjennom, men vi kan nå ta... Vi kan uansett ta oppgave to. Nå ser dere forhåpentligvis en figur med en D og en C som input. Input og kontroller. Da er spørsmål to, hvis input er lik null og kontroller input er lik én,", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0003", "start": 580.04, "end": 891.0, "token_count": 591, "text": "Ja, si ifra hvis... Si ifra hvis problemene fortsetter, så kan jeg f.eks. stenge av videoen, det kan hjelpe. OK. Det ser ut som det var vanskelige spørsmål, dette her. Vi kan uansett gå gjennom, men vi kan nå ta... Vi kan uansett ta oppgave to. Nå ser dere forhåpentligvis en figur med en D og en C som input. Input og kontroller. Da er spørsmål to, hvis input er lik null og kontroller input er lik én, hva blir nå exo queue? Hvor x er da input på denne overporten. Så er det fint å innom, du ser litt på eller sier ifra hvis det er noen nettproblemer. Ja, det er ingen som har skrevet noe hos meg, så er det ikke noe problem. Men det er en del som har skrevet i stad. Men det gjelder alle, bare si ifra hvis... Men hos meg er det fint, så.  Ja, nå ser jeg antall svar begynner å ta seg opp litt der. Så det er bra. Vi kan gi dere litt mer tid. Takk for møtet. Ha en god kveld. . Jeg har 80 % svart, så jeg tenker vi stopper der og så ser vi på svarene. Sånn. Kan dere se svarene nå? Ser du dem, Ine? Jeg ser dem. Du ser dem? De kommer opp hos meg. Det er i hvert fall en som skriver ja her også. OK. Da skal vi se på det første... Det første spørsmålet. Hva blir X og Q? Først kan vi se på pollen at det er... 80 % omtrent har svart X lik 0 Q lik 1. Hvis det kommer en ener inn her, så... Hvis man går rett fram, så kommer det en null inn i en or-port. Det er det vanskelig å slutte noe av. Men hvis man tar den eneren og følger den inn til den andre or-porten, så kommer det en ener inn i en or-port, og da vil det alltid gå en ener inn ut. For i en or-port er det bare en 0-0 som er i null. Den blir til 0, og ganske riktig, da blir den X-en der lik 0. Og her kommer det 0 inn i en or-port. Og herfra så kommer det en ener som blir til en 0, så da kommer det 0-0 inn der. Da går det 0 inn i nattporten, og dermed så kommer det en ener hit.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0004", "start": 861.34, "end": 1070.76, "token_count": 588, "text": "så kommer det en ener inn i en or-port, og da vil det alltid gå en ener inn ut. For i en or-port er det bare en 0-0 som er i null. Den blir til 0, og ganske riktig, da blir den X-en der lik 0. Og her kommer det 0 inn i en or-port. Og herfra så kommer det en ener som blir til en 0, så da kommer det 0-0 inn der. Da går det 0 inn i nattporten, og dermed så kommer det en ener hit. Så veldig bra. Her ser vi at 71 av dere har funnet ut det. X er 0 og Kulik. Det var kjempebra. Da skal vi se på neste. Det er denne. Da har vi den latchen som vi har på en kontroller. Og da er spørsmålet hvis input d er lik null og controller input er lik én. Hva blir x og q? Ja, controller input én, det skal bety at da Da skal verdien settes til den innkomne. Så det bør bli kulik null. Men igjen så kan vi se... Hvis det er null, og så er jeg like enig. Hvis det er null, så kommer det en null inn her. Og da ser vi at X blir null. Men en null inn i en årport, da kan man ikke uten videre si hva som kommer ut. Men vi kan se på, det kommer en ener inn her. Og så kommer det null inn her. Da blir det to ener inn i den porten. Da kommer en ener inn i denne årporten. Og en ener i årporten, da kommer det alltid en ener ut, og den blir til null. Så q blir også null. Så igjen, veldig bra. 70 % av dere har svart x lik 0 q anlik 0. Og det er da det riktige svaret. Men dette er ganske komplisert, så kjempebra. Da har dere fått med mye. Ok. Da skal vi fortsette der vi slapp. Så nå tilbake til... Slidende... D-vippe. Dette er altså da en d-vippe, som er den endelige lagringsenheten for nullarenere i en CPU. Og den er satt sammen av to. D-låser, eller latcher. Måten vi har gjort det på, er at vi har én slave som hele tiden står og leser fra master. Og master er den som tar input utenfra. Så ser vi den stiplede linjen her.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0005", "start": 1029.3, "end": 1225.32, "token_count": 583, "text": "Slidende... D-vippe. Dette er altså da en d-vippe, som er den endelige lagringsenheten for nullarenere i en CPU. Og den er satt sammen av to. D-låser, eller latcher. Måten vi har gjort det på, er at vi har én slave som hele tiden står og leser fra master. Og master er den som tar input utenfra. Så ser vi den stiplede linjen her. Det er de to latchene som da er slått sammen til en D-vippe. Denne måten å gjøre det på, er at vi har en klokke som vi skrur av og på systematisk hele tiden, med en viss frekvens. Det er dette som er den berømte CPU-klokka. Som moderne CPU-er, fra en typisk frekvens mellom 1 og 3, ofte 4 GHz. Men noe særlig høyere enn det kommer man ikke pga. fysiske begrensninger. Da blir det altfor mye varmeutvikling. Derfor vet man at hvis man overklokker CPU-er, så må man begynne med vannavkjøling og i ekstreme tilfeller med flytende luft osv. for å få kjølt ned systemet. Men det er da mye mer effektivt og i stedet for høyere frekvens, da lager man flere CPU-er og fordeler de, sånn at man da har maskiner som har... Vi har fire, åtte... Og i servere 30 og 60 sånne CPU-er. Så helt uavhengige enheter som regner hver for seg. Men vi skal se på hvorfor dette her virker. Og i de simuleringene som vi gjorde i fjor med studenter på rekke osv., Jeg var klokke. Hvert andre sekund omtrent, så løftet jeg armen opp. Da er jeg celik 1, og da er det slavene som virker. Så tok jeg armen ned, og da blir det en ener som er sendt til master. Hele clouet er at disse her virker annenhver gang. Her har jeg satt opp systematisk, og vi ser på hver av de to fasene. I en CPU så deles tiden inn i små klokketick av CPU-klokken. Den går av og på hele tiden. Når klokken sender inn en null, da skal alle beregninger ferdigstilles.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0006", "start": 1180.42, "end": 1346.76, "token_count": 600, "text": "Da er jeg celik 1, og da er det slavene som virker. Så tok jeg armen ned, og da blir det en ener som er sendt til master. Hele clouet er at disse her virker annenhver gang. Her har jeg satt opp systematisk, og vi ser på hver av de to fasene. I en CPU så deles tiden inn i små klokketick av CPU-klokken. Den går av og på hele tiden. Når klokken sender inn en null, da skal alle beregninger ferdigstilles. Det kretsen gjør, sånn som har D-er osv., det... Det skal gjøres ferdig, og så lagres det hos Master. Den lagringen må være ferdig før klokken switcher til. Når klokka er null her, kan vi tenke oss at dette er et register vi skal lagre noe i. Da har vi kanskje en addisjon eller en subtraksjon eller noe som pågår. Og det tar tid. De må strømme fysisk gjennom den kretsen for å komme til et svar. Når klokka er null, så leser Master det som kommer inn. Altså kanskje sluttsvaret på den summen, dette bittet, blir da null. Og da lagres det hos Master. Og da er det viktig at før klokka ringer, før klokka skifter fra null til én, så må alle disse operasjonene være ferdige. Og det er det som gjør at noen komplekse operasjoner, som å dividere f.eks., Da må det tas med i beregningen at den blir ikke ferdig på én klokkesykkel. En addisjon kan typisk være ferdig på én klokkesyklus. Og da kommer resultatet inn med en gang. Dette må være ferdig før klokka switcher over til 1. For da skrus lesingen fra master av. Når klokka switcher 1, så er det Slaven som begynner å lese. Og da er det smarte her, at da leser slaven verdien fra master. Men da er master skrudd av, så da har slaven god tid på å lese denne verdien. Og da er den sikker på at denne verdien er den endelige verdien som er ferdig. Og så leser den seg inn, og da får du en... I dette tilfellet så får vi en null her hos slaven. Og det er denne som er verdien som registeret inneholder.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0007", "start": 1310.84, "end": 1486.88, "token_count": 579, "text": "For da skrus lesingen fra master av. Når klokka switcher 1, så er det Slaven som begynner å lese. Og da er det smarte her, at da leser slaven verdien fra master. Men da er master skrudd av, så da har slaven god tid på å lese denne verdien. Og da er den sikker på at denne verdien er den endelige verdien som er ferdig. Og så leser den seg inn, og da får du en... I dette tilfellet så får vi en null her hos slaven. Og det er denne som er verdien som registeret inneholder. Som totalt sett utgjør en vippe. Når klokken slår én, slaven leser verdien fra master og lagrer den. Men den begynner med en gang å sende ut dette resultatet. Som er det gjeldende resultatet ut i kretsen, som er koblet til utgang for nyberegninger. Og på denne måten så går klokka av og på, og... For hver klokkesyklus utføres det da én beregning. Denne CPU-klokken er helt essensiell for å synkronisere dataene. For hver tid av klokken kan man da utføre et nytt sett av beregninger. Det kan f.eks. hver dag å utføre en maskininstitusjon. En annen viktig ting som man trenger for å lage en hel CPU, nå har vi nesten fått med alt, det er tellere. Og det er da en enhet som er sånn her... Dette er et eksempel fra den simulatoren. Dette er da en teller som starter på 0, 0, og så teller den 0, 1, 1, 0, 1, 1. Så starter den på nytt igjen. Så blir det 0, 0, 1, 1, 0, 1, 1. Så fortsetter den sånn iduettelig. Denne teller fra 0 til 3. For å lage større tall, så kan du bare... Så kan man faktisk bruke denne tilsvarende konstruksjonen. Bare legge på flere sånne, så vil man kunne se at da kan man lage... Teller det med 64-bit, f.eks. Men igjen, for å lage denne konstruksjonen... Her er en X-år-port, som er en år-port med en not etter.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0008", "start": 1447.5, "end": 1639.42, "token_count": 593, "text": "Så fortsetter den sånn iduettelig. Denne teller fra 0 til 3. For å lage større tall, så kan du bare... Så kan man faktisk bruke denne tilsvarende konstruksjonen. Bare legge på flere sånne, så vil man kunne se at da kan man lage... Teller det med 64-bit, f.eks. Men igjen, for å lage denne konstruksjonen... Her er en X-år-port, som er en år-port med en not etter. For å lage denne konstruksjonen. Igjen så setter man opp Sann-Isabel, for man vet hvordan en klokke skal virke. Og så kommer man fram til denne logikken her. Som er relativt enkel. Og ut fra det også tilsvarende, så kan man lage vilkårlig store tellere. Så nå har vi med dette så har vi fått egentlig alle de viktigste bitene som skal til for å lage en hel SIPU. Og da skal vi se litt på... Generelt på datamaskinarkitektur. Spesielt på van Neumann-arkitektur. Von Neumann-arkitektur. Den aller vanligste datamaskinarkitekturen som brukes, ble definert av en matematiker som het John von Neumann. Han var virkelig et universalgeni og hadde... Sto bak veldig mye av konstruksjonen av en moderne datamaskin. Det vi har sett på nå, det er først og fremst aluen. Så dette er den sentrale beregningsenheten. I tillegg har vi registeret. Når man gjør beregninger, så kobler man registrene til input på aluen. Og så kommer man andre registeret til outputs, og så gjøres det beregninger. Og dette gjøres om og om igjen. Vi har en kontrollenhet som styrer alt dette. I tillegg så har man main memory, secondary memory, main memory, det er RAM, internminne. Og internminne går ut til en buss, en databuss, som sender data inn til kontrollenheten. Altså kommer data ut igjen til RAM. Og det som er spesielt med von Neumann-arkitektur, er at her i RAM så ligger De institusjonene som kontrollerer hva som skal gjøres. Og i tillegg så ligger data. Det er typisk variabler. Hvis du har en variabel i et program, så vil den variabelen lagres.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0009", "start": 1590.0, "end": 1781.46, "token_count": 599, "text": "I tillegg så har man main memory, secondary memory, main memory, det er RAM, internminne. Og internminne går ut til en buss, en databuss, som sender data inn til kontrollenheten. Altså kommer data ut igjen til RAM. Og det som er spesielt med von Neumann-arkitektur, er at her i RAM så ligger De institusjonene som kontrollerer hva som skal gjøres. Og i tillegg så ligger data. Det er typisk variabler. Hvis du har en variabel i et program, så vil den variabelen lagres. Og så gjør du beregninger, og så lagrer du dataene i den variabelen. De ligger da i ramm, og da må hele tiden trafikken gå inn og ut til Søppel. Og det som er spesielt med von Neumann-arkitekturen, er at samme buss brukes til både instruksjoner og data. I den såkalte Harvard... Hva heter den? Hardford... Arkitekturen. Harvard. Universitetet Harvard. Arkitekturen. Så er det litt annerledes, for da er det to busser. Én buss som sender institusjoner, og en atskilt buss som sender data. I virkeligheten, i moderne arkitektur, så brukes egentlig en slags blanding. Der har man Cash, som vi skal se på senere. Og LNCash, det har to... Én for data og én for instruksjoner. Så det er en sannhet med modifikasjoner, at alle bruker von Neumann-arkitektur, men i hovedsak så ligner det på denne arkitekturen. I tillegg så har man secondary memory, det er disk, og så har man en rekke forskjellige enheter som kommuniserer med dette. Men CPU og main memory er liksom hovedbiten som vi skal se på nå. De delene van Normann-arkitekturen består av, er som vi så på forrige figur, det er Ramm, så er det Alu, og så er det en kontrollenhet som henter inn instruksjoner fra Ramm. Så dekodes instruksjonene og sender signaler til Alun, sånn at riktige operasjoner blir utført. Sånn at Alun gjør en ad i det ene tilfellet og en sammenligning i det andre osv. Så er det registeret som vi har slitt med i dag og lagd.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0010", "start": 1740.0, "end": 1943.92, "token_count": 589, "text": "De delene van Normann-arkitekturen består av, er som vi så på forrige figur, det er Ramm, så er det Alu, og så er det en kontrollenhet som henter inn instruksjoner fra Ramm. Så dekodes instruksjonene og sender signaler til Alun, sånn at riktige operasjoner blir utført. Sånn at Alun gjør en ad i det ene tilfellet og en sammenligning i det andre osv. Så er det registeret som vi har slitt med i dag og lagd. Det er det et internlager som lagrer alle instruksjonene og lagrer alle dataene som kommer ut av Alun. I tillegg så har vi InputUpput. Som... Beregningsenheter. Her er det listet opp en rekke forskjellige beregningsenheter. I dag har vi sett på Aldun, som er CPU-ens hjerne. Og CPU, Central Processing Units. Det er da den viktigste biten. Så har vi noen andre varianter. FPU, floating point units. Vanligvis er det integrert i CPU. Det er bare en spesiell alu som også kan brukes i floating point. Da trenger man mer komplekse og kompliserte kretser som utfører det. Tar typisk litt lengre tid å dele to floating points på hverandre i forhold til helt annet. GPU, Graphics Processing Unit, som brukes til grafikk og rendregrafikk. Å tegne ut alt som du skal se på skjermen. Det trengs mye prosessorkraft, og veldig mye gjøres i parallell. Så da har man typisk tusenvis av små aluer som gjør beregninger samtidig i parallell. Og alt dette sitter vanligvis i vanlige datamaskiner. Det er programmerbar logikk, sånn at man kan... Hvis man har et logisk diagram, så kan man programmere det inn i en FPGA, og det går veldig hurtig. Men det fine med den er at den brennes ikke engang for alle, den kan da reprogrammeres. ASIC derimot, Application Specific Integrated Circuit, det er virkelig en integrert krets. Da tar du en logikk. Så sender du den til en fabrikk, og så lager du nøyaktig den kretsen som du har spesifisert. Det er da... det er da ekstremt hurtig. Hvis du har fulgt med på sånn som bitcoin, hvor man da...", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0011", "start": 1899.72, "end": 2119.2, "token_count": 594, "text": "så kan man programmere det inn i en FPGA, og det går veldig hurtig. Men det fine med den er at den brennes ikke engang for alle, den kan da reprogrammeres. ASIC derimot, Application Specific Integrated Circuit, det er virkelig en integrert krets. Da tar du en logikk. Så sender du den til en fabrikk, og så lager du nøyaktig den kretsen som du har spesifisert. Det er da... det er da ekstremt hurtig. Hvis du har fulgt med på sånn som bitcoin, hvor man da... Så starter man gjerne med CPU, men etter hvert gikk man over til GPU for å kunne gjøre dette raskere. Men nå går det for sakte med både CPU-er og GPU-er, så man gikk over til FBGA. Og helt til slutt har man lagd ASIC, altså helt spesifikke integrerte kretser, som regner ut bitcoins hurtigst mulig. Et spørsmål i chatten om... Når man snakker om flere kjerner i NCPU, er det da snakk om flere aluer? Ja, det er et godt spørsmål. Ja, man har da... Man må da ha minst... Eller man har én alu per kår. Så når vi snakker om flere cors, så er det uavhengig rene enheter. Det... Men det hender det varierer. F.eks. er det noen versjoner av IMD som har 40 course. Men da... I noen tilfeller har den 20 course som er hypertrening. Man har 40 aluer, men så har man bare 20 FPU-er. Så det varierer litt. Men stort sett så kan du si at hver kår er en alu, altså en uavhengig, rene enhet. OK. Da skal vi til slutt i dag se litt på en simulering av en CPU. Dette skal dere studere i detalj. Vi skal kjøre simuleringen i simuleringsmaskinen for Windows som vi har. Dette er arkitekturen til en komplett firebit CPU, som kan utføre programmet. Vi ser her... Her er Datapath. Det er den som inneholder Alun og registeret. Det som er på høyre side her, er registeret. R0 her står egentlig 0010, så det er tallet fire. Mens i R1 så står det tallet én. I tillegg har vi ram som er koblet til, sånn at man kan skrive ut resultater.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0012", "start": 2070.0, "end": 2263.76, "token_count": 598, "text": "Vi skal kjøre simuleringen i simuleringsmaskinen for Windows som vi har. Dette er arkitekturen til en komplett firebit CPU, som kan utføre programmet. Vi ser her... Her er Datapath. Det er den som inneholder Alun og registeret. Det som er på høyre side her, er registeret. R0 her står egentlig 0010, så det er tallet fire. Mens i R1 så står det tallet én. I tillegg har vi ram som er koblet til, sånn at man kan skrive ut resultater. Vi kommer ikke til å bruke den delen. Men det vi kommer til å bruke, er rom, som er her. Og inni her ligger instruksjonene. Det er maskinkode. Etter hvert skal vi se, når vi kompilerer høynivåkode, så får vi maskinkode. Og i vårt tilfelle så ligger den maskinkoden her i rom. Men her har vi ikke noen kompulator. Her må vi skrive maskinkode rett inn i rom. Som nuller og enere. Og det en maskininstruksjon gjør, det er å styre alle kontrollbitene til Datapath, sånn at operasjonen som den ønsker Vi ser det er... Vi ser det er masse nuller og enere som går inn her og styrer disse bitene. Med up-code, DR osv. Og spesielt up-code, den sier hvilken institusjon som skal utføres. Da kan vi f.eks. tenke oss at vi ønsker å ha dere to tall. Jobben instruksjonsdekoderen gjør, er at den dekoder instruksjonen, sånn at den skrur på de riktige bryterne her. F.eks. S0 og S1, det styrer Alun. Hvis den er der, så må S0 og S1 settes til de verdiene som gir en addisjon inne i Alun. Skal se på det i litt mer detalj etterpå. Her er vi inne i datapath. Det er noen mux-er, eller multiplexere, de er et system for å velge hvilken kanal man sender inn i aluen. Her er en mux som kommer inn i aluen. Den kan velge mellom å sende noe fra et register eller å sende inn en konstant. Jo, enten fra registeret her eller fra den konstanten her. Og det velges ved det valgbyttet her. Og det er noe av det instruksjonsdekoderne gjør.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0013", "start": 2211.48, "end": 2393.88, "token_count": 573, "text": "Skal se på det i litt mer detalj etterpå. Her er vi inne i datapath. Det er noen mux-er, eller multiplexere, de er et system for å velge hvilken kanal man sender inn i aluen. Her er en mux som kommer inn i aluen. Den kan velge mellom å sende noe fra et register eller å sende inn en konstant. Jo, enten fra registeret her eller fra den konstanten her. Og det velges ved det valgbyttet her. Og det er noe av det instruksjonsdekoderne gjør. Hvis det skal komme inn en konstant, så må den kanskje skrus på én. Hvis du skal få noe fra et register, så må den settes i null, sånn at det som kommer fra abusen, kommer inn. Til syvende og sist så kommer det da to tall inn i abusen. Det går ett resultat, det, ut. Og da ser vi at... her igjen så kan man velge enten å ha data inn her, som da kommer fra Ramm, eller så kan man ta resultatet fra Alun. Det som jeg har sett på tidligere i dag, er at man legger sammen to tall. At man tar to registre, la oss si R0 og R1, og så kobles verdien av de ved hjelp av de multiplexerne. De kobles sånn at R0 går inn i A, R1 går inn i B. Og så setter man en viktig bit her for å adere. Og så kommer resultatet i D. Og så kobles denne multiplexeren sånn at resultatet fra D sendes opp igjen i registerfilen. Avhengig av instruksjonen man gjør, kan man velge å legge resultatet i R0. Det man utfører da, er R0 er lik R0 pluss R1. Og på denne måten så... På denne måten så virker en datamaskin. Det er akkurat samme prinsippet i alle CPU-er. Ja. Da skal vi til slutt se på... Høynivåkode. For det er syvende og sist, når du skriver et program, så skriver du ikke maskinkode, men du skriver høynivåkode. Så det vi skal se litt på nå, er hvordan høynivåkode sånn som dette er... En liten forløkke som summerer. Den starter på I liker 1, så den går tre ganger.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0014", "start": 2357.52, "end": 2536.74, "token_count": 590, "text": "Det er akkurat samme prinsippet i alle CPU-er. Ja. Da skal vi til slutt se på... Høynivåkode. For det er syvende og sist, når du skriver et program, så skriver du ikke maskinkode, men du skriver høynivåkode. Så det vi skal se litt på nå, er hvordan høynivåkode sånn som dette er... En liten forløkke som summerer. Den starter på I liker 1, så den går tre ganger. Altså er S lik 0. Så når vi har en sånn høynivåkode... Det vi ønsker av programmet... Det er de følgende tre operasjonene. Først starter vi med i lik 1, summen er 0 pluss 1 er lik 1 osv. Så øker verdien i til 2. Så legger vi til den summen 3. Og så til slutt får vi ut tallet 6, som blir summen. I oppgavene senere i dag så skal du prøve å overbevise deg om... At denne simuleringsmaskinen utfører nøyaktig dette. Så skal du etter hvert endre den litt, sånn at den løkka går til tre. Og da må du faktisk skrive maskinkode. Du må endre på maskinkoden for å få den til å gjøre nøyaktig dette. Vanligvis har man en kopulator som oversetter høynivåkode til maskinkode. Men for å virkelig se hva som skjer... Så skal vi utføre dette selv. For å få til det, så trenger man å kjenne til instruksjonene for denne maskinen. Instruksjonssettet til maskinen utgjør arkitekturen, f.eks. Exo-86-arkitekturen, som er den vanligste arkitekturen i PC-reservere. Den har et gitt... Det er fastlåst, for det er definert av arkitekturen. Og det brennes fast i kretskortene som utgjør alu og CPU, og alle delene. Da har man bare bestemt, sånn som jeg bestemte for denne maskinen her, f.eks. addisjon. Den skal ha binært nummer 0100. Det er altså da fire. Institusjon nummer fire. Det skal være en add-institusjon. Og den skal addere operand 1. Og den skal legge til operand 2.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0015", "start": 2490.0, "end": 2688.56, "token_count": 581, "text": "Det er fastlåst, for det er definert av arkitekturen. Og det brennes fast i kretskortene som utgjør alu og CPU, og alle delene. Da har man bare bestemt, sånn som jeg bestemte for denne maskinen her, f.eks. addisjon. Den skal ha binært nummer 0100. Det er altså da fire. Institusjon nummer fire. Det skal være en add-institusjon. Og den skal addere operand 1. Og den skal legge til operand 2. Og det betyr at man da utfører DR er lik DR pluss SR. Og vi ser de fire første bitene her. Det er da de fire første bitene i institusjonen. Det definerer hvilken institusjon vi skal gjøre. De neste fire bitene definerer operand 1 og operand 2. Og det kan variere ut fra hvilken institusjon det er, nøyaktig hva disse operandene gjør. For å utføre en sånn oppgave som å kjøre den summen... Hvis man skal skrive maskinkode, så må man lage... Det enkleste før man skriver maskinkoden... Altså bruke et slags... Et språk som ligger tett opp mot maskinkoden, som er assemblykode. Det jeg har skrevet opp her, er assemblykode som utfører... Den utfører denne forløkken. Når man skriver maskinkode eller assemblykode, så må man tenke litt annerledes enn når man skriver høynivåkode. Men det viktigste man alltid må ha, det er enten en løkke eller en if-test.  Og for å utføre en Lucky eller Niff-test, så må man hoppe i koden. Vi kan se veldig raskt på hvordan denne maskinkoden her utføres. Så det vi gjør først i de fire første institusjonene, er bare å legge verdier i r0rnr2r3. r0rnr2r3, det er da registeret. Så første institusjon sier legg tallet tre i. Og så legg tallet 1 i R1. 0 i Auto og 0 i R3. Og så utfører jeg en addisjon, I pluss pluss. Jeg bestemmer meg da bare for at variabelen i, den lagres i Auto. Men det er noe jeg bestemmer når jeg skal skrive dette programmet.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0016", "start": 2652.96, "end": 2819.2, "token_count": 596, "text": "er bare å legge verdier i r0rnr2r3. r0rnr2r3, det er da registeret. Så første institusjon sier legg tallet tre i. Og så legg tallet 1 i R1. 0 i Auto og 0 i R3. Og så utfører jeg en addisjon, I pluss pluss. Jeg bestemmer meg da bare for at variabelen i, den lagres i Auto. Men det er noe jeg bestemmer når jeg skal skrive dette programmet. Og denne instruksjonen her, da, den tar verdien i Auto og så legger den til Auto. Tallet R1 vil alltid være 1, så dette vil da alltid bli en I++. Altså at man øker automen. Så utfører jeg summen. Jeg bare definerer da i hodet mitt at jeg velger da R3. Det vil jeg ha. Der vil jeg lagre S. Og det er derfor jeg legger 0 inn i det registeret først. Så denne institusjonen, det den utfører, den tar da... S, som er R3, og så legger den til I, som er R2, og så lagres det i R3. Og det vil da være S lik S pluss I. Og denne institusjonen, det kan datamaskinen min utføre. Så kommer et veldig viktig stepp. Jeg sammenligner. Og det jeg sammenligner, det er... R2 og R0. For R0, det er maks. Jeg ønsker at løkka skal bare gå opp til tre. Så dette er maks. Og da sammenligner jeg R2, som er da på en måte variabelen i, har den blitt så stor som tre. Men foreløpig er jeg ille i gen, så det har den ikke. Og når jeg da gjør neste institusjon, jump not equal, så hopper jeg opp til fire igjen. Og den består av at man øker i med én. Så får jeg i lik 2. Så får jeg summen lik 1 pluss 2 er lik 3. Så gjør jeg dette en gang til. Her er i lik 2. Jeg hopper opp. Øker i lik 3. S er lik 3... Det er 3 pluss 3, og da er summen 6. Og nå har i blitt 3, og da hopper jeg ikke opp igjen. Dermed er jeg ferdig, og jeg har fått resultatet 6. Programmet har blitt utført.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0017", "start": 2778.74, "end": 2940.82, "token_count": 592, "text": "så hopper jeg opp til fire igjen. Og den består av at man øker i med én. Så får jeg i lik 2. Så får jeg summen lik 1 pluss 2 er lik 3. Så gjør jeg dette en gang til. Her er i lik 2. Jeg hopper opp. Øker i lik 3. S er lik 3... Det er 3 pluss 3, og da er summen 6. Og nå har i blitt 3, og da hopper jeg ikke opp igjen. Dermed er jeg ferdig, og jeg har fått resultatet 6. Programmet har blitt utført. Og det er nøyaktig sånn man går fra høynivåkode til assemblerkode eller maskinkode. Neste steppe nå er at jeg må kode inn denne maskinkoden eller denne asemblyen inn i maskinkode. Og det er veldig rett frem, for det er bare å oversette instruksjon for instruksjon. Og... Ja, hvis jeg bruker mye tid her nå... Jeg går litt over tiden. Håper dere holder ut. Selv om det er litt tungt, så dere får jobbe dere gjennom dette ved å se på oppgavene. Men hele clouet er nå at vi oversetter disse institusjonene én for én. For eksempel den første linjen... Altså legg tallet 3 inn i r0. Da må vi move i, det er institusjon nummer to, så da må vi skrive 00... R0 er destination. Source er det tallet vi skal legge inn. Her ser vi 11, det er tallet 3. Det skal legges i register 0. På samme måte, samme instruksjon, men nå skal vi legge 1 i R1. Da må det stå 1 der og 1 der. Etter hvert kommer vi ned til add. Da skal vi add R2 lik R2 pluss R1. Da må vi skrive inn her er instruksjon nummer fire, og så... Destination register, det er da R2, og da ser vi det står et 2-tall der. Det gir da R2 og 1. Det betyr R1. Så dermed utføres R2 lik R2 pluss R1. Hvis jeg f.eks. hadde skrevet 3 her i stedet, ville jeg utført R3 lik R3 pluss R1. Så på denne måten programmerer jeg maskinen med akkurat den koden jeg ønsker.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0018", "start": 2905.76, "end": 3078.24, "token_count": 590, "text": "Da må vi skrive inn her er instruksjon nummer fire, og så... Destination register, det er da R2, og da ser vi det står et 2-tall der. Det gir da R2 og 1. Det betyr R1. Så dermed utføres R2 lik R2 pluss R1. Hvis jeg f.eks. hadde skrevet 3 her i stedet, ville jeg utført R3 lik R3 pluss R1. Så på denne måten programmerer jeg maskinen med akkurat den koden jeg ønsker. Vanligvis, hvis du f.eks. har høynivåkode iC, så har man en kompulator. Du kompilerer høynivåkoden, og så lager kompulatoren denne maskinkoden. Og så kjøres den. Men i vårt tilfelle så gjør vi dette for hold. Helt til slutt, den viktigste biten i LANESAPOON, det er bransjekontroll. Hvis man ikke hadde bransjekontroll, så... Om man hadde et program på ti linjer, så ville man bare kunne kjøre de ti linjene, og så var man ferdig. Bransjekontroll gjør at man kan hoppe i koden. Og det var det vi så vi gjorde hver gang vi kom til en test. Så hoppet vi som et resultat av resultatet av den testen. Hvis den var likt, så hoppet vi ikke. Hvis den var jump not equal, hvis det ikke var likt, så hoppet man. Dermed kan man konstruere for- og wirelucker og if-tester, og alle mulige slags konstruksjoner kan da konstrueres på den måten. Det helt avgjørende da er at man har en branch-kontroll her, som gjør at avhengig av resultatet... Ved en sammenligning så settes Z og C0 her nede. Så sendes det til branch-kontrollen. Og da ser vi at branch-kontrollen sender et signal opp til counteren. Program counter teller seg nedover hvilke institusjoner man gjør. Og da endres den program counteren, sånn at man hopper i koden. Og det er hele clouet for... For hvordan en CPU kan programmeres til if-tester, få løkker og wildløkker. Og egentlig alt man trenger i en CPU. OK. Så jeg har brukt mye tid her. Men jeg tenker det...", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0019", "start": 3026.52, "end": 3275.7, "token_count": 590, "text": "Så sendes det til branch-kontrollen. Og da ser vi at branch-kontrollen sender et signal opp til counteren. Program counter teller seg nedover hvilke institusjoner man gjør. Og da endres den program counteren, sånn at man hopper i koden. Og det er hele clouet for... For hvordan en CPU kan programmeres til if-tester, få løkker og wildløkker. Og egentlig alt man trenger i en CPU. OK. Så jeg har brukt mye tid her. Men jeg tenker det... For å kunne gjøre oppgavene, så er det veldig... Jo, det er veldig viktig at dere kan kjøre de institusjonene i simulatoren. Så jeg tenkte jeg veldig raskt skulle helt til slutt vise dere hvordan man kjører simuleringen, sånn at dere kan komme i gang med det. Forhåpentligvis ved å prøve og feile litt. Så vil dere kunne forstå i detalj hvordan en datamaskin virker. Skal vi se... Da skal jeg dele en annen side med dere. Sånn. Da starter... Digital works. Her ser vi de fire fulladerne som er satt sammen for bl.a. å kunne legge sammen. Det er en sånn binary fullader som vi forrige gang konstruerte. Vi ser at dette er et stort byggverk hvor man hele tiden abstraherer og lager bokser. Dette er register file. Denne inneholder da registrene. Det er de små registrene som vi har brukt mye tid på å konstruere i dag. Og dette er da logikken i registrene, men vi ser hovedbiten er vippene. D-vippene. Så her er det fire D-vipper som lager fire-bit i fire-bitsregisteret. Helt til slutt skal jeg bare vise hvordan maskinen kjører. Her inne i rom, hvis man høyre-klikker eller tar edit på den, så ser man det programmet. Dette er da maskinkode som viser det programmet som regner én få løkke. Og så kan man trykke på run og kjøre. Alternativet, som kanskje er bedre, er å trykke på step. Da tar man én instruksjon av gangen. Den første var å legge tallet tre i r0. Dette er en ener og det er en toer, så tallet tre har nå kommet i r0. Så trykker jeg på step en gang til.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0020", "start": 3240.2, "end": 3417.64, "token_count": 575, "text": "så ser man det programmet. Dette er da maskinkode som viser det programmet som regner én få løkke. Og så kan man trykke på run og kjøre. Alternativet, som kanskje er bedre, er å trykke på step. Da tar man én instruksjon av gangen. Den første var å legge tallet tre i r0. Dette er en ener og det er en toer, så tallet tre har nå kommet i r0. Så trykker jeg på step en gang til. Dvs. to ganger må man trykke, for klokka går av og så på. Og så utføres instruksjonen. Og det som ble gjort nå, det var at én ble lagt i r1. Og så blir null lagt i r2, og null i r3. Men så adderer man. Så det man skal gjøre nå, er å ta R2 lik 0 pluss R1. Og da får man en ener i R2. Og så gjør man en test. Eller man øker R3 med én, det er telleren. Og så sjekker man om den er lik R0. Nei, den er ikke lik R0. Og det er jump not equal, så da hopper man opp hit og gjør en ny addisjon. Og det man gjør nå, er R2 lik R2 pluss den telleren R3. Så da... Da ser man... Da får man to i R2. Ja, i telleren R2 så er det R3. Det er her summen ligger. En pluss to ble nå tre. Så går man og tester, er vi ferdig med løkka? Nei, det er vi ikke, så vi gjør det en gang til. Da skal vi til slutt ta... Da vi teller R2, blir det nå tre. Så skal vi legge R3 lik R3 pluss R2. Da ser vi vi får seks, som er sluttresultatet. Så når nå R2 sammenlignes med R0, så... Er den equal? Og da fortsetter den rett frem. Og da har vi kjørt hele programmet. Og så kan... Nå kjører jeg programmet bare hurtig gjennom. Og da, om og om igjen, så utføres hele den samme operasjonen ved at man legger sammen. Helt til slutt så kan... Det er en oppgave. Som går ut på at dere skal endre... litt på koden.", "source": "lecture"}
{"lecture_id": "os3b", "chunk_id": "os3b_0021", "start": 3374.36, "end": 3511.76, "token_count": 404, "text": "som er sluttresultatet. Så når nå R2 sammenlignes med R0, så... Er den equal? Og da fortsetter den rett frem. Og da har vi kjørt hele programmet. Og så kan... Nå kjører jeg programmet bare hurtig gjennom. Og da, om og om igjen, så utføres hele den samme operasjonen ved at man legger sammen. Helt til slutt så kan... Det er en oppgave. Som går ut på at dere skal endre... litt på koden. Og det dere må gjøre da, er å klikke her, og så kan man gå inn sånn, og så endre. Nå endret jeg verdi fra én til tre, og da vil programmet gjøre noe helt annet. Men etter at du har endret, så må du ikke bare trykke på OK. Du må endre først, og så trykke på neste. Og så kan programmet kjøre. Det enkleste er å krasje hele maskinen og ta ned simuleringen. Og så starte den på nytt, for da starter de et ferskt program. Sorry, jeg skal ikke gjøre til vannet og gå så mye over tiden. Men vi har la bedt på, så vi får... Dere kan jo slappe av litt før dere starter på laben. Lage breakout-rooms. Og så kan dere gå inn i breakout-rommene og snakke med meg eller med NA-studentpasientene og få hjelp til oppgavene. Men da stopper jeg der i hvert fall. Så får dere en liten pause. Men nok en gang takk for bra oppmøte. Så ses vi i laben, og i hvert fall neste uke. Takk for i dag.", "source": "lecture"}
