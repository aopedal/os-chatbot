{"lecture_id": "os12time1", "chunk_id": "os12time1_0000", "start": 0.0, "end": 256.56, "token_count": 590, "text": "Det var en dårlig start på opptaket. Vi må tilbake... Nei. Ja, dette blir kuttet fra opptaket. Som vi ser, så har vi ikke så mange uker igjen med kursinnhold. Det blir... Det er muligens at vi kommer til å fortsette... Skal vi se på det løpet. Tirsdag 27. Jeg tror det er litt kort tid med bare én forelesning til internminet, og så disker og filsystemer. Så det er mulig det forlenges inn til tirsdag 27. Men det kommer ikke til å bli så veldig mye mer på den praktiske delen. Jeg annonserte DockerHub før påske, men har i hvert fall utsatt det. Det er uansett ikke veldig mye mer vi skal snakke om... Snakke om dokker. Eller ekstra soff om dokker. Men det kommer en runde til med Powershell. Windows Powershell. Der var det en digital forelesning som ble lagt ut i påsken. Og så kommer det en til i løpet av morgendagen. Og det er en... Eller praktisk del. Om å skrive Powershell-script og å bruke Powershell fra kommandolinje. En ting som er fint med Powershell, er at den ligner veldig på Linux på bæsj selv. Så det er inspirert av det. Sånn at veldig mange kommandoene kan du faktisk bruke direkte. Sånn som CP og MV og mange andre kommandoer. Sånn at man i noen tilfeller kan ta Shellscript og bare paste inn og kjøre som på Shellscript. Så det er også da mange oppgaver denne uken som går på det med PowerShell. Oi. Nå ser jeg det henger her. Det var en som sa at det hadde vært noe trøbbel med... At nettsiden hadde vært nede. Det må jeg sjekke et øyeblikk. Nei... Er det noe trøbbel hos meg? Eller er det andre som har problemer med å se nettsiden også? Den fungerer fint her. Ja, det var bra. Du kommer inn. Ja, da er det et eller annet problem hos meg. Men det kan vi... Alle kommer rett inn, bortsett fra meg. Ja, ja. Vi kan... Ja, jeg kan se på det i pausen. Men i hvert fall, det er oppgaver denne uken... Oi. Der skjedde det noe. Nå kan jeg kanskje komme inn. Der, ja.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0001", "start": 220.36, "end": 416.32, "token_count": 589, "text": "Den fungerer fint her. Ja, det var bra. Du kommer inn. Ja, da er det et eller annet problem hos meg. Men det kan vi... Alle kommer rett inn, bortsett fra meg. Ja, ja. Vi kan... Ja, jeg kan se på det i pausen. Men i hvert fall, det er oppgaver denne uken... Oi. Der skjedde det noe. Nå kan jeg kanskje komme inn. Der, ja. Det er oppgaver denne uken som går på Windows PowerShell. Og for de av dere som kjører Windows-laptoper, så... Kan dere gjøre de aller fleste av oppgavene direkte. Men det er noen oppgaver med å lage nye brukere osv. Og så er det noen oppgaver med Windows Register. Da kan det være greit for å være sikker på ikke å ødelegge noe på eget oppsett, så kan det være greit å bruke en Virtual Box Windows VM. Men det står instruksjoner her også på hvordan den kan installeres og settes opp. Videre er det en... Etter de powercel-oppgavene så er det oppgaver om det vi snakker om i dag. Og her ser vi... Et skript som dette her kan kjøres omtrent direkte. Så veldig mye er likt, fordi det er lagd alias i PowerShell som gjør mange av de samme kommandoene. Så når vi først kan binde bæsjskrift, så kan du også mye PowerShell. Masse kan overføres direkte. Og så etter hvert så er det oppgaver. I dag så er det Javatrå-oppgaver og diverse oppgaver rundt synkronisering. Og serialisering. Så er det bl.a. noen litt mer vanskelige teoretiske oppgaver. Men det skal vi se på først i forløsningene. Så det... Temaet i dag er generell synkronisering. Vi skal spesielt se på Synchronized i Java for å se hvordan vi kan synkronisere den Java-koden som vi hadde før påske, som... Han talte opp en saldo, og to tråder ødela for hverandre. Når et program ikke synkroniserer riktig, ser vi ofte at det ikke er tread safe. Det betyr at trådene kan ødelegge for hverandre. Synchronized er en metode som kan brukes for å synkronisere og gjøre et trådprogram tread safe.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0002", "start": 379.1, "end": 551.24, "token_count": 595, "text": "Vi skal spesielt se på Synchronized i Java for å se hvordan vi kan synkronisere den Java-koden som vi hadde før påske, som... Han talte opp en saldo, og to tråder ødela for hverandre. Når et program ikke synkroniserer riktig, ser vi ofte at det ikke er tread safe. Det betyr at trådene kan ødelegge for hverandre. Synchronized er en metode som kan brukes for å synkronisere og gjøre et trådprogram tread safe. Så skal vi til slutt i dag se på deadlock. Det kan oppstå når man fortvilet prøver å synkronisere mange prosesser. Og det gjør man typisk alt ved at de venter på hverandre. Men hvis flere prosesser venter f.eks. i en ring, en sirkel, på hverandre, så kan det oppstå deadlock, og da kommer ingen videre. Og det er et problem man må være klar over når man begynner å programmere og synkronisere tråder eller prosesser. Så det er... Det er temaet i dag. Ja. Det er et godt spørsmål i chatten om... ... uke 14 er obligatorisk. Det var fint du spurte om, for det... Nei, uke 14 er ikke obligatorisk. Så Oblig3... Det kommer en mappe for å levere Oblig3 i dag. Og alt som skal inngå i Oblig3, det er akkurat... Altså fra før påske. Så det står her uke tolv. Denne ukens oppgaver. Det er de siste som skal være med i innleveringen. Derfor er det... Jeg har kanskje ikke skrevet noe om det, men vi... Jo. Her står det en kommentar om dette. Disse innleveringene er ikke obligatoriske, så de som har merket opplegg, bare betrakt dem som de viktigste. Og få med seg for å forberede seg til eksamen. Altså det som er mest eksamensrelevant. Så når det står oblig her, sånn som her, så betyr det ikke at det skal være med i noen oblig-innlevering. Men det skal... Det er det som er det viktigste. Og jeg snakket med studentene om det. Det kan godt være at vi kan få til... Vi kan legge opp en innlevering. Sånn at dere kan frivillig levere inn og få tilbakemeldinger på det som er anførselstegn-obliger.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0003", "start": 510.0, "end": 703.2, "token_count": 582, "text": "Og få med seg for å forberede seg til eksamen. Altså det som er mest eksamensrelevant. Så når det står oblig her, sånn som her, så betyr det ikke at det skal være med i noen oblig-innlevering. Men det skal... Det er det som er det viktigste. Og jeg snakket med studentene om det. Det kan godt være at vi kan få til... Vi kan legge opp en innlevering. Sånn at dere kan frivillig levere inn og få tilbakemeldinger på det som er anførselstegn-obliger. Så hvis det er noe interesse for det, så si gjerne ifra. Så kan vi prøve å få til en sånn ordning, så dere får tilbakemelding på en sånn måte som dere har fått på de virkelige obligatoriske oppgavene. Men altså opp til alt oppgaver til og med uke tolv. Og de er obligatoriske. Ja, der ser jeg Ine også har kommet seg opp etter ferien. Det kan være tungt for flere, det, Ine. Så det er veldig bra du er her. Da kan dere spørre Ine. Enten vi må spørre til alle eller bare til Ine. Eventuelt ting som er veldig viktig, tar vi i pausen. Ok. Da skal vi se på dagens MR. Så vi skal først snakke litt teoretisk, noen slider... Og en del litt sånn teoretiske slider om hvordan man kan løse Mutex-problemer. Vi så konkret på forrige gang. Og så... kommer vi kanskje litt tilbake til X86-instruksjonen Lock og se på det vi gjorde der. Det var et par ting vi ikke gjorde der som vi skal se på. Spesielt så vi ikke direkte på hva som skjer hvis det ikke bare er én instruksjon. Vi så på Lock før påske. Som var... som endret på en feltsvariabel. Og likevel så ble det problemer. Så vi skal se litt mer på det. Og så skal vi se på igjen noe generelt om synkronisering, med semaforer blant annet. Så semaforer skal vi se på i dag. Og så skal vi mot slutten synkronisere det Java-programmet vi hadde sist. Og helt til slutt i dag skal vi se på deadlock. Men vi starter... Vi starter med kritiske avsnitt.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0004", "start": 660.0, "end": 851.96, "token_count": 596, "text": "Som var... som endret på en feltsvariabel. Og likevel så ble det problemer. Så vi skal se litt mer på det. Og så skal vi se på igjen noe generelt om synkronisering, med semaforer blant annet. Så semaforer skal vi se på i dag. Og så skal vi mot slutten synkronisere det Java-programmet vi hadde sist. Og helt til slutt i dag skal vi se på deadlock. Men vi starter... Vi starter med kritiske avsnitt. Kritisk avsnitt er det avsnittet i koden som er helt avgjørende når det gjelder synkronisering. Og det er da typisk når man aksesserer en felles felles. Vi har sett på en problemstilling hvor vi har en felles variabel saldo, hvor vi hadde en felles variabel saldo som én prosess økte med 1 mill. og en annen prosess, P1, minket med 1 mill. Så så vi da på hvordan dette kunne gjøre at saldoen... at det forsvant 1 mill. Det er jo opplagt uheldig. Og akkurat den kodebiten hvor den milden forsvinner, det er når saldoen oppdateres. Og dette kalles kritisk avsnitt. Så det som er helt avgjørende, er at en prosess som er inni et kritisk avsnitt, den må kunne fullføre det helt alene, uten at da noen andre endrer på saldoen. Serialiseringen må da sørge for at det kritiske avsnittet gjøres bare av én prosess av gangen. Og vi begynte å se på metoder som kan gjøre dette her. Så vi hadde en lock-instruksjon som var sånn. Og den hindret da at andre prosesser endret på saldoen. Det gjorde vi med P-treads. Det som også var avgjørende da, var at vi låste minnebussen. Altså bussen ut til RAM. For det er det som er avgjørende når du har tråder som kjører på forskjellige CPU-er. Så er det ikke så lett å koordinere dem. For da opererer de totalt samtidig og helt uavhengig av hverandre. Hvis begge kjører på samme CPU, så har du tross alt en context switch. Selv om det kan bli trøbbel der òg. Men når du er på forskjellige CPU-er, så må minnebussen låses", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0005", "start": 818.12, "end": 1005.72, "token_count": 587, "text": "Altså bussen ut til RAM. For det er det som er avgjørende når du har tråder som kjører på forskjellige CPU-er. Så er det ikke så lett å koordinere dem. For da opererer de totalt samtidig og helt uavhengig av hverandre. Hvis begge kjører på samme CPU, så har du tross alt en context switch. Selv om det kan bli trøbbel der òg. Men når du er på forskjellige CPU-er, så må minnebussen låses for at ikke to prosesser skal hente ut en kode eller samtidig endre. Eller det vil si at ikke begge skal hente ut den nåværende verdien, og så skrive tilbake uten å koordinere med den andre. Men hvis du kjører selv, hvis du kjører på samme CPU, så har vi sett at én instruksjon sånn som dette her... Den fører faktisk til minst to instruksjoner på maskinnivå. På assembly-nivå. Og det er det operativsystemet ser. Så når operativsystemet skedulerer to prosesser... Selv på samme CPU så kan det da komme en context switch midt inne i denne oppdateringen. Og da kan det som Prosess 2 utfører av institusjoner, det kan da bli ødelagt av den andre fordi de ikke koordinerer. Og fordi det kan komme context switch midt inne i kritisk avsnitt. For da blir kritisk avsnitt større enn én linje. er en maskininstitusjon, så vil vi ikke få det problemet med context-witching på samme SPU. Men problemet kan likevel oppstå når vi har flere SPU. Nå skal jeg se på noen metoder for å... ... for å behandle kritiske avsnitt. Med disse metodene skal vi sikre oss at bare én prosess eller én tråd av gangen utfører sitt kritiske avsnitt før en annen prosess gjør det. I prinsippet kan det være ti tråder som samtidig ønsker å gå inn i et kritisk avsnitt, men det avgjørende her er bare én av gangen. En veldig direkte måte å sørge dette for, det er å skru av interrupts. Skrur jeg av interrupts, så er du sikker på at... Da er du sikker på at det ikke kommer noen context switch, i hvert fall på denne CPU-en.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0006", "start": 966.32, "end": 1138.4, "token_count": 589, "text": "av gangen utfører sitt kritiske avsnitt før en annen prosess gjør det. I prinsippet kan det være ti tråder som samtidig ønsker å gå inn i et kritisk avsnitt, men det avgjørende her er bare én av gangen. En veldig direkte måte å sørge dette for, det er å skru av interrupts. Skrur jeg av interrupts, så er du sikker på at... Da er du sikker på at det ikke kommer noen context switch, i hvert fall på denne CPU-en. Igjen så kan det være trøbbel med andre CPU-er. Men hvis vi er på samme CPU, så kan vi sikre et kritisk asynytt ved at først disse blir interrupts. Og så enable interrupts etterpå. For da er vi... Selv om dette kritiske avsynet da består av flere maskininstitusjoner, så er man likevel sikker på at ingen... Det kan ikke skje noe context-witch, for interrupt er skrudd av. Og husker interrupts det... Eller context-witcher... Det skjedde ved at det kommer en timer-interrupt. Så man ikke behandler det timer-interrupten med en gang, men venter til koden er ferdig. Så vil det ikke kunne skje... Da vil ingen kunne avbryte knyttet gassnett. Dette er OK for en OUS-kjerne. Det er kode i OUS-kjernen som skrur av interrupts for å være helt sikker på å fullføre et kritisk gassnett. Men det ville vært veldig kritisk hvis brukerprosesser kunne gjøre dette her, for da kunne de straks ta over styringen. Så dette... Dette er OK for en O-stjerne, men generelt kan man ikke gi en slik metode til en vanlig brukerprosess. Metode B, som man da må bruke på brukerprosesser, det er å lage en slags lås. Det er litt sånn som den lock-instruksjonen som vi har sett på. Man lager en lås, sånn at bare én prosess av gangen har tilgang til fellesdata. Generelt kalles en slik lås Mutex. Det står da for Mutual Exclusion. På norsk betyr det gjensidig utelukkelse. Man sørger for å utelukke hverandre. Dette er den mest brukte metoden generelt. Det fins mange implementasjoner av det, og vi skal se noen eksempler på implementasjoner.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0007", "start": 1099.4, "end": 1301.24, "token_count": 595, "text": "Det er litt sånn som den lock-instruksjonen som vi har sett på. Man lager en lås, sånn at bare én prosess av gangen har tilgang til fellesdata. Generelt kalles en slik lås Mutex. Det står da for Mutual Exclusion. På norsk betyr det gjensidig utelukkelse. Man sørger for å utelukke hverandre. Dette er den mest brukte metoden generelt. Det fins mange implementasjoner av det, og vi skal se noen eksempler på implementasjoner. Men... det som er viktig her, er at man må da utelukke alle andre. Og... Ja, en mutex... Den lockwool-funksjonen vi hadde, den gjelder bare for én institusjon. Men en mutex generelt, det er på en måte Så lenge man beholder den nøkkelen, er man inne i kritiske avsnitt, og da kan ingen andre komme inn i kritiske avsnitt og gjøre noe. Så det kan vare lenger enn en enkelt institusjon. Og dermed så kan det også brukes til å serialisere kode som har mer enn én institusjon i kritiske avsnitt. Her er et lite Linux-eksempel på... Som viser den i et annet tilfelle, hvor man bruker en lås. Og det ligner på lokk og Mutex, dette også. Og det er en teknikk man ofte bruker for å si fra at... ... nå bruker jeg denne filen. Ingen aner om å bruke den. Så gjøres det ved at man lager en lokk per bruker. Så hvis man driver og leser og skriver e-post til denne brukeren... For alle e-postene i Sendmail, det er bare en stor fil med e-poster. Og hvis man får e-post eller gjør noen endringer på den filen, så lager Linux-systemet en sånn lokk-fil. For at andre prosesser ikke endrer på innboksen. Da må alle prosesser som skal endre på denne filen... Altså på... ikke på lokkfilen, men på innholdet i mailen... Det er en annen fil, som kanskje heter Var Mail Haugerud. Så sjekker da bare prosessene. Finnes den filen her? Nei, hvis den ikke finnes, OK, da kan jeg gjøre endringer. Den kan gjøre å stå i en venteløkke og sjekke om filen gjøres, og så gå inn hvis den ikke finnes.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0008", "start": 1264.3, "end": 1448.56, "token_count": 588, "text": "Da må alle prosesser som skal endre på denne filen... Altså på... ikke på lokkfilen, men på innholdet i mailen... Det er en annen fil, som kanskje heter Var Mail Haugerud. Så sjekker da bare prosessene. Finnes den filen her? Nei, hvis den ikke finnes, OK, da kan jeg gjøre endringer. Den kan gjøre å stå i en venteløkke og sjekke om filen gjøres, og så gå inn hvis den ikke finnes. Det er et enkelt eksempel på en lokk. Men vi skal se at et sånt system er ikke helt bombesikkert. For igjen så kan du få trøbbel med contact switcher. I Windows så har vi akkurat den samme problemstillingen. Det har to funksjonskall, enter critical section og leave critical section, som er da igjen et tilbud til programmerere å lage kritiske avsnitt. Og disse funksjonskallene vil da sørge for at etter enter critical section, så vil ingen andre prosesser, heller ikke på andre CPU-er, vil endre på... Endre på de felles variablene. Det som typisk er felles, det ligger i ramm. Så igjen så vil disse funksjonskallene låse av bussen, sånn at man har enerett på å endre de områdene av ramm som man ser på. Det er klart, dette forsinker alle jobber som er... Som kjører i parallell. Vi kjører i parallell for å få det til å gå fortere. Hvis det er veldig mye synkronisering, så vil det gå saktere. Men dette er da opp til programmereren å lage et system som er smart nok, og som ikke bruker altfor mye tid i kritiske avsett. Ja, vi har allerede sett på LOC, på X86-institusjonen LOC. Og som vi skal se senere, så trenger man... For å lage en effektiv løsning, så trenger man hjelp fra hardware. Men det går også an å lage softwareløsninger som... Selv om de kjører på... Eller selv om det kan komme en context switch, som sørger for en mutex. Og hvis vi tenker at vi ønsker en softwareløsning, ja... Da... Vi ønsker oss gjerne å ha to funksjoner eller metoder sånn som dette - getmutex og release-mutex.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0009", "start": 1410.0, "end": 1608.36, "token_count": 599, "text": "Og som vi skal se senere, så trenger man... For å lage en effektiv løsning, så trenger man hjelp fra hardware. Men det går også an å lage softwareløsninger som... Selv om de kjører på... Eller selv om det kan komme en context switch, som sørger for en mutex. Og hvis vi tenker at vi ønsker en softwareløsning, ja... Da... Vi ønsker oss gjerne å ha to funksjoner eller metoder sånn som dette - getmutex og release-mutex. Og getmutex, den metoden ønsker vi skal hente en lokk. Vi skal hente en nøkkel. Og så sier vi da at nå har jeg denne nøkkelen. Ingen andre må ta den. Ingen andre kan ta den. Så da kan jeg utføre mitt kritiske avsnitt. Så... Etterpå kan jeg gi fra meg nøkkelen. Og dette virker jo enkelt og greit. Så da burde man egentlig ha løst hele problemet. Men vi skal se at det er ikke så enkelt som man skulle tro. Så dette er første forsøk på å lage en software musex. De andre forsøkene er det oppgaver om denne uken. Så se på de oppgavene senere. Men vi skal se på dette første forsøket, som er liksom det enkleste man kan få til, og som tilsvarer det å lage en maillock. Vi hadde et eksempel hvor vi lagde en fil, og så sjekker alle andre prosesser om den filen finnes. Det er egentlig det tilsvarende, men vi får det samme problemet. Vi tenker oss at vi har en static boolen lock. Det er da en felles variabel som er tru eller fals. Og den er static i betydning av at to eller flere prosesser kan aksessere den. Vi skal ha kode som sikrer denne lokken. Og da kan vi gjøre det på denne måten her. Vi kan si getmutex-lokk... Den kan være sånn at... Dette er en litt spesiell konstruksjon, men den funker i Java, f.eks. Og det er vile lock. Og så kommer det bare to parenteser. Og de to parentesene, de er... De gjør ingenting. Og det er faktisk en maskininstitusjon som gjør ingenting, og den heter NOP - No Operation. Så vild lock, og så ingenting. Det den gjør, det er at den bare tester om og om igjen", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0010", "start": 1567.2, "end": 1739.86, "token_count": 578, "text": "Vi kan si getmutex-lokk... Den kan være sånn at... Dette er en litt spesiell konstruksjon, men den funker i Java, f.eks. Og det er vile lock. Og så kommer det bare to parenteser. Og de to parentesene, de er... De gjør ingenting. Og det er faktisk en maskininstitusjon som gjør ingenting, og den heter NOP - No Operation. Så vild lock, og så ingenting. Det den gjør, det er at den bare tester om og om igjen om lock er true. Den tester om og om igjen om lock er true eller false. Hvis lock er true, så går den inn i løkka og gjør ingenting. Det den da gjør, er at den hele tiden sjekker om lock er true. Så den står her og gang på gang tester. Er lock true? Er lock true? Er lock true? Og hele tiden, hvis... Hvis lock er true, så står den og venter. Og da er det klart. Der vil den stå evig. Med mindre det er... Det er andre prosesser som aksepterer denne lokken og setter den til false. Så hvis ingen andre har satt denne til false før, så vil den første prosessen som gjør GetMuteX, den vil gå inn... Lock er false, så da hopper den over denne her og så setter den locklike true. Og da er det trygt, for da kan den gå inn i sitt kritiske avsnitt. For den har nå gått inn, satt locklike true. Det er som å skru på en lås. Det er som om man går inn på et toalett og vrir på låsen, for da er det et signal til alle andre. Da er det rødt. Ingen kan komme inn her. Da er det safe. Så hvis en annen prosess kommer inn og også prøver å gjøre get mutex før det kritiske avsnittet, så vil den komme inn og så se... Da må jeg stå her og vente. Og den står og venter og venter helt til den første prosessen som kom inn, har releaset Mutex. Først gjør man get Mutex, hente låsen, så Kritisk avsnitt, og så release Mutex. Så når da prosess nummer to er ferdig med å sette Kritisk avsnitt, så vil den release Mutex. Og det gjør den ved å sette locklick-folds. Og da vil de som måtte da", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0011", "start": 1703.32, "end": 1906.16, "token_count": 574, "text": "get mutex før det kritiske avsnittet, så vil den komme inn og så se... Da må jeg stå her og vente. Og den står og venter og venter helt til den første prosessen som kom inn, har releaset Mutex. Først gjør man get Mutex, hente låsen, så Kritisk avsnitt, og så release Mutex. Så når da prosess nummer to er ferdig med å sette Kritisk avsnitt, så vil den release Mutex. Og det gjør den ved å sette locklick-folds. Og da vil de som måtte da De vil da komme inn i Kritisk Asenytt, og så vil de sette lock-lick, tror jeg. Så dette ser ut som det perfekte opplegg. Men her er det et problem. Jeg har stilt et spørsmål her. Dette burde sikre at to prosesser ikke er i Kritisk Asenytt samtidig. Vi kan få et problem her, og det er hvis... Hva skjer hvis det kommer en context switch? Vi tenker oss at disse kjører på samme CPU. Hva om det kommer en context switch rett etter at denne prosessen har testet om... Om lock er false. Vi antar at lock er false. Og så vil jeg jo... En sånn test består av flere deler. Første del må hente inn verdien og legge et register. Og så må den, etter at den har hentet den inn, gjøre en compare, sammenligne den verdien med null, f.eks. Og så må den, etter en compare, hoppe, avhengig av verdien. Men det der utføres i minst to institusjoner. Så hva skjer om det kommer en context switch nøyaktig etter at den har hentet inn verdien? Jo, da fryser selv den prosessen. Det neste den vil gjøre, er å sette lock like through og gå inn i kritisk avsnitt. Men når denne første prosessen kommer i en fryser, og så kommer prosess nummer to inn, da er jo lokk fortsatt false. Så den prosess nummer to, den vil enkelt og greit bare hoppe over den løkka. Lock er false. Men da er det for sent, for da er P1 allerede inne i kritiske avsnitt. Og så kommer P2 etter, og den går også inn i kritiske avsnitt. Og da er vi tilbake til de gamle problemene.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0012", "start": 1872.88, "end": 2059.76, "token_count": 585, "text": "Men når denne første prosessen kommer i en fryser, og så kommer prosess nummer to inn, da er jo lokk fortsatt false. Så den prosess nummer to, den vil enkelt og greit bare hoppe over den løkka. Lock er false. Men da er det for sent, for da er P1 allerede inne i kritiske avsnitt. Og så kommer P2 etter, og den går også inn i kritiske avsnitt. Og da er vi tilbake til de gamle problemene. Hvis akkurat dette inntreffer, så kan begge to kjøre kritiske avsnitt samtidig. Så derfor så fungerer rett og slett ikke denne software-løsningen. Den vil fungere stort sett, bortsett fra hvis det kommer et kritisk avsnitt nøyaktig etter violet lock. Nøyaktig etter at verdien er hentet inn til registrene, men rett før den hopper på grunnlag av denne verdien. Så derfor er ikke denne god nok. Og i øvingsoppgavene så... Så kommer det et par andre nye forsøk som er litt... Og til slutt kommer man fram til Peterson-algoritmen, som kom i gang på 80-tallet, som er en perfekt software-mytex-løsning. Men den er litt tungvint, og du trenger litt kode. Men den kan man bruke. Men i praksis, sånn som med operativstemme og sånn som med Java Traws osv., Hvor man får hjelp fra hardware. Og det sikrer i tillegg at man lokker databussen. Så de metodene er da enda bedre. Ja, så... Harway støtter Mutex. I de softwareløsningene som vi har sett på, de krever litt kode. Og i tillegg bruker de alle sammen. Buzzy waiting. Buzzy waiting er dette med at man står og venter. Og da bruker man CPU-en. Man gjør NOP-institusjoner om og om igjen. Og det er en litt effektiv måte å vente på. Men det kalles da generelt buzzy waiting. Så i praksis så brukes... Blant annet pga. det så brukes som oftest Løsninger. Og de kan lages... En sånn hardway-støttet løsning kan lages hvis man har en institusjon som f.eks. TestAndSet TSL. Det er da en institusjon som gjør begge de to operasjonene", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0013", "start": 2017.68, "end": 2203.72, "token_count": 597, "text": "Og da bruker man CPU-en. Man gjør NOP-institusjoner om og om igjen. Og det er en litt effektiv måte å vente på. Men det kalles da generelt buzzy waiting. Så i praksis så brukes... Blant annet pga. det så brukes som oftest Løsninger. Og de kan lages... En sånn hardway-støttet løsning kan lages hvis man har en institusjon som f.eks. TestAndSet TSL. Det er da en institusjon som gjør begge de to operasjonene som vi snakket om på forrige slide, nemlig å teste verdien og endre den. I én og samme institusjon. Det er viktig at det er én og samme institusjon. For det gjør at det ikke kan komme... ... ikke kan komme en kontekst-switch mens dens institusjon utføres. Og en test-and-set vil i tillegg låse minnebussen ut i RAM, sånn at ikke andre CPU-er kan lese verdien. Da kan man implementere GetMuteX på følgende måte.  Man har da Vile test and set lock. Og denne operasjonen, det er bare da én institusjon. Og midt inni den institusjonen så kan det ikke komme en context switch. Og siden den i tillegg låser minnebussen, så er man da bombesikker på at bare denne end-prosessen kommer inn i kritisk avsnitt av gangen. Og dette er da en perfekt løsning. Vi så forrige gang på X86-institusjonen LOC. Og det... Den LOC-institusjonen, den utføres før en kritisk institusjon. Den koden vi hadde sist, var at vi først hadde LOC, og så hadde vi en ad, eller en ink. Og den gjør at man låser av minnebussen, sånn at ingen andre CPU-er heller. Får endre den verdien, den minneadressen, som man bruker. Alle andre minneadresser kan brukes, men ikke akkurat den. Det sikrer da at institusjonen etter lokk... Den vil være den eneste som kan endre på den variabelen som kommer etter lokkinstitusjonen. Sørger da for at det kritiske avsnittet fullføres uten at noen andre tråder kommer inn. Dette fungerer bare hvis det kritiske avsnittet kun er én enkel institusjon. Men det kan det ofte være.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0014", "start": 2156.92, "end": 2371.36, "token_count": 590, "text": "Får endre den verdien, den minneadressen, som man bruker. Alle andre minneadresser kan brukes, men ikke akkurat den. Det sikrer da at institusjonen etter lokk... Den vil være den eneste som kan endre på den variabelen som kommer etter lokkinstitusjonen. Sørger da for at det kritiske avsnittet fullføres uten at noen andre tråder kommer inn. Dette fungerer bare hvis det kritiske avsnittet kun er én enkel institusjon. Men det kan det ofte være. Man kunne i prinsippet bruke en sånn walkie-institusjon til å lage en mutex. Men da bruker man heller en test-and-set-institusjon. Og test-and-set-institusjon er også en X86-institusjon. Hvis man skal lese om dette, så kan man slå opp i Intels 86-manual. Der står det om hvordan denne lokkinstruksjonen låser av. Låser av bussen og hindrer at noen andre endrer på verdi. Som sagt så var det et par ting vi ikke gjorde da vi så på den forrige gang. Så jeg tenker vi skal gå tilbake til den. Repetere hva vi gjorde sist. Og så skal vi... Og så skal vi... gjøre en annen... Jo, vi skal gjøre noe som vi ikke så på sist. Et spørsmål i chatten her. Test1set funker også hvis det er snakk om prosess på forskjellige CPU-er. Den låser også minnebussen, sånn at da er det ingen andre som heller kan endre på den verdien i RAM, hvor lokkvariabelen er lagret. Så vi kan kjøpt repetere... Skal vi se... Vi kan raskt se på hva vi gjorde forrige gang. Først og fremst hadde vi ett program, to program, tred.c, som en rekke ganger, ti millioner ganger allerede... Hundre millioner ganger. Så utfører det én linje. Og den én-linje-operasjonen... ... det eneste den gjør, er at den øker verdien på en fellesvariabel svar med én. Og i dette Main-programmet så ser vi at vi har to tråder. Og de to trådene, de utfører den INK-operasjonen. Det blir to tråder som 100 mill. ganger øker trådverdien med 1.", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0015", "start": 2324.32, "end": 2558.28, "token_count": 596, "text": "som en rekke ganger, ti millioner ganger allerede... Hundre millioner ganger. Så utfører det én linje. Og den én-linje-operasjonen... ... det eneste den gjør, er at den øker verdien på en fellesvariabel svar med én. Og i dette Main-programmet så ser vi at vi har to tråder. Og de to trådene, de utfører den INK-operasjonen. Det blir to tråder som 100 mill. ganger øker trådverdien med 1. Og det man skulle tro da, det var at... De to trådene til slutt da skulle få den fellesvariabelen til å være 200 mill. Men vi kan se hvordan det ser ut. Hvis vi kompilerer... Og så kjører vi AdoptOut. Så ser vi at... Og dette så vi forrige gang. Resultatet blir aldri 200 000, sånn som vi ønsket det skulle bli. Og da... Det vi gjorde da, var at vi... Jo, vi var... For det første så var vi ikke sikre på om denne institusjonen ble utført bare som én linje. Fordi det var jo en sånn svar pluss, pluss. Så det kunne føre til flere linjer. Så for å være helt sikker på det, så kompilerte vi Tred.c Med denne assembly-koden, hvor du har én linje som øker svar med én. Så... Hvis vi gjør det om igjen, komplerer den sammen med minMoldatS, så så vi fortsatt at likevel... så ble svaret forskjellig hver gang. Men det er da vi kan komme inn med en... Med instruksjon lokk. Denne instruksjonen låser minnebussen, sånn at neste gang så er det kun én tråd som kan endre på den verdien. Så hvis vi da kompilerer den på nytt, og kjører... Så ser vi nå så tar det litt lengre tid. Og det er fordi det foregår noe synkronisering. Men heldigvis så blir svaret riktig hver eneste dag. Men... Det vi da ikke så på sist, varer hva skjer om vi kjører dette her på... Jo, vi så også på det sist. Hva skjer om vi setter disse her på samme SUPU? Den gjør nå at begge må kjøre på samme CPU. Da ser vi... Jo, det fungerer fortsatt som det skal,", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0016", "start": 2508.32, "end": 2725.88, "token_count": 594, "text": "Så ser vi nå så tar det litt lengre tid. Og det er fordi det foregår noe synkronisering. Men heldigvis så blir svaret riktig hver eneste dag. Men... Det vi da ikke så på sist, varer hva skjer om vi kjører dette her på... Jo, vi så også på det sist. Hva skjer om vi setter disse her på samme SUPU? Den gjør nå at begge må kjøre på samme CPU. Da ser vi... Jo, det fungerer fortsatt som det skal, selv om de kjører på samme CPU. Det at vi kjører på samme CPU, det kan vi også se med time. Hvis det tar time... Hvis det tar time når de kjører på hver sin... Så ser vi her... Her er det 189 % CPU-tid. Og det er et tydelig tegn på at... Jo, de kjører faktisk på hver sin CPU. Mens når jeg setter dem med Tasset, så ser vi at de kjører på samme CPU og får bare 100 %. Så... Men det med time... Det var bare for å vise eksplisitt at typisk... Hvis du setter i gang to tråder, så kjører de på hver sin CPU. De deler ikke på CPU-en til. Skal vi se... Men det vi skal se på nå, det er... Hva om vi skriver kode som... Denne endringen i to operasjoner. Så... Her er det... Dette er assembly-kode som er generert av GCC. Og det som var problemstillingen, var at vi vet ikke... Genererer GCC kode som utfører den økningen av svar? I én enkel institusjon, eller er det flere? Her har jeg skrevet kode som eksplisitt gjør dette her i tre operasjoner, sånn som man kan risikere. Så dette her er da tre operasjoner for å endre svar. Man flytter først svarvarabelen over eax, og så øker man eax, og så flytter man svaret ut igjen. Og hvis vi kjører denne koden, så skal vi se at... Da... Da kan man også få problemer hvis man... Hvis man har en context switch. Altså hvis man med tassett tvinger begge til å kjøre på samme SUP, men likevel kan man få problemer. Men jeg ser... Nå er vi godt over tiden. Så vi tar en... Vi tar en pause, så skal vi etter pausen se på... Skal vi sammenligne...", "source": "lecture"}
{"lecture_id": "os12time1", "chunk_id": "os12time1_0017", "start": 2688.12, "end": 2763.24, "token_count": 247, "text": "og så øker man eax, og så flytter man svaret ut igjen. Og hvis vi kjører denne koden, så skal vi se at... Da... Da kan man også få problemer hvis man... Hvis man har en context switch. Altså hvis man med tassett tvinger begge til å kjøre på samme SUP, men likevel kan man få problemer. Men jeg ser... Nå er vi godt over tiden. Så vi tar en... Vi tar en pause, så skal vi etter pausen se på... Skal vi sammenligne... Hva skjer når vi kjører kode hvor dette her er tre instruksjoner, og sammenligne med det vi har sett før, når vi bare har én enkelinstruksjon som endrer på verdien? Vil det da ha noe å si når du kjører med tasset og tvinger begge til å kjøre på samme super? Og det skal vi se at det er en forskjell. Men det kommer vi til etter pause. Hva er det som er så spesielt med denne filmen?", "source": "lecture"}
