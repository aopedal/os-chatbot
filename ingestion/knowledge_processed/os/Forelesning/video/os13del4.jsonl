{"lecture_id": "os13del4", "chunk_id": "os13del4_0000", "start": 0.0, "end": 179.96, "token_count": 581, "text": "Dining philosophers problem, det er et veldig kjent problem hvor deadlock da kan oppstå. Og dette er kjent fordi at det blir ofte brukt som et eksempelproblem. Så man trenger da... Eller man bruker semaforer og mutex. Og så skal man programmere disse filosofene til å siste å spise spagetti og tenke. Men så må man gjøre det på en sånn måte at man unngår deadlock. Så problemet, hvis dere kan se her, så er det... Den tegningen skal forestille et bord med fem porsjoner med spagetti. Og så ligger det mellom hver tallerken en gaffel. Og da tenker vi også at det er fem filosofer som sitter rundt her og skal spise. Og dette må da programmeres som filosofprosesser. Og de oppfører seg sånn at noen ganger så sitter de og tenker uten gafler. Men så er det noen ressurser de deler på, og det er gaflene. Hvis det sitter en over seg her... Så har han to gafler som han kan ta. Og systemet er sånn at for å spise så må man ha to gafler. Og da er det typisk sånn... Jo, det er programmet, dette her, så de må da ta opp gafler én av gangen. Og da må de med mutixer og så videre sjekke at gaflene er ledige. Så må de plukke opp først en gaffel, og så en til. Og så, når de kommer i gang, så kan de starte med å spise. Og da må disse programmere sånn at det er random tidsbruk. Altså de kan sitte og tenke en stund, og så bestemmer de seg. ... Nå skal jeg begynne å spise. Og så begynner de å spise. Problemstillingen er da å programmere dette sånn at alle sitter og spiser. Og så... må de da... Jo, programmet må være sånn at de når som helst kan ta en gaffel og komme i gang med å spise, og så må dette flyte. Og dette må gjelde i alle situasjoner. Og da kan det være sånn at dette fungerer veldig fint lenge, og så plutselig kommer du til deadlock. Og et eksempel på deadlock da, det vil typisk være at... Jo, tenk om...", "source": "lecture"}
{"lecture_id": "os13del4", "chunk_id": "os13del4_0001", "start": 150.0, "end": 305.0, "token_count": 595, "text": "Og så... må de da... Jo, programmet må være sånn at de når som helst kan ta en gaffel og komme i gang med å spise, og så må dette flyte. Og dette må gjelde i alle situasjoner. Og da kan det være sånn at dette fungerer veldig fint lenge, og så plutselig kommer du til deadlock. Og et eksempel på deadlock da, det vil typisk være at... Jo, tenk om... Hvis vi tenker oss disse fem trådene... Kjøre på én CPU... Så vil du gjøre én ting av gangen. I og for seg kan det akkurat det samme skje hvis vi kjører på fem forskjellige CPU-er. Men i hvert fall hvis man tenker seg at alle samtidig kommer til det steget at de har tatt én gaffel opp. Og så sitter de og holder på den ressursen. Og så gjør alle de andre det samme. For da... Alle tar opp høyre gaffel, og så venter de på at venstre gaffel skal bli ledig. Men hvis man ikke programmerer med høyde for deadlock på den måten, så vil det kunne skje at alle bare da sitter og venter med en gaffel i høyre hånd, og venter på at den venstre skal bli ledig. Og det skjer aldri. Og da har man en deadlock. Og det viser seg at det er ikke så enkelt å få til å programmere dette her. Ja, det er kommentarer med selvkjørende biler. Ja, og da vil du virkelig få en deadlock. Når selvkjørende biler blir så avanserte at de kjører ut i trafikken, så er absolutt det noe man må ta hensyn til og få til en deadlock-løsning. Og ja, en mulig løsning kan kanskje være at man... Ja, nei, det er ikke noe... Hvis du tenker på det med selvkjørende biler... Det er et godt eksempel. Det er ikke så enkelt å finne ut hvem som skal kjøre... Det må kanskje være noe sånn at en starter å begynne å kjøre, og så detektere, men da vil den andre si at... ja. Rangere med prioritet. Jo, det kunne være en mulighet. Alle biler har en prioritet. Så må de snakke sammen. Men det var et veldig godt eksempel på en virkelig deadlock som kan oppstå,", "source": "lecture"}
{"lecture_id": "os13del4", "chunk_id": "os13del4_0002", "start": 270.0, "end": 462.92, "token_count": 593, "text": "Ja, nei, det er ikke noe... Hvis du tenker på det med selvkjørende biler... Det er et godt eksempel. Det er ikke så enkelt å finne ut hvem som skal kjøre... Det må kanskje være noe sånn at en starter å begynne å kjøre, og så detektere, men da vil den andre si at... ja. Rangere med prioritet. Jo, det kunne være en mulighet. Alle biler har en prioritet. Så må de snakke sammen. Men det var et veldig godt eksempel på en virkelig deadlock som kan oppstå, og som rent praktisk må kunne løses. Ja. Men kunstig intelligens... Jo, det blir jo en kunstig intelligens, men det er ikke så lett å lære det heller. Kunstig intelligens lærer ofte av tidligere data. Men det er klart. Dette er virkelig... Det er jo kunstig nøkkelgjens. Men... Hovedpoenget her er at dette er noe som oppstår med en gang man deler på ressurser og prøver å synkronisere seg imellom. Og det er ikke så lett å unngå deadlock, men det er usedvanlig viktig å... Det kommer mange gode forslag her. Trafikklys, jo, det er jo en... Man trenger jo ikke engang å være synlig i trafikklys, men at man har... Man legger inn det i alle kryss. Man kan jo på en måte lage software-trafikklys som alle indirekte vet om. OK. Men... Ja, så... Så dette er deadlock-problemstillingen. Mulige løsninger for deadlock. Den første og viktigste løsningen er å prøve å forhindre det. F.eks. internt i operativsystemkjernen så er det utrolig viktig at deadlock forhindres, sånn at prosesser ikke står og venter på hverandre. Skrive kode som gjør da at det aldri oppstår deadlock. Og det kan være litt vanskelig å programmere, fordi du ofte må teste det ut. Men da kan det være sånn at deadlock oppstår bare i ekstremt sjeldne tilfeller. Og så oppdager man ikke før det skjer i kjørende kode. For vanlige brukerprosesser så er det vanskelig for operativsystemet. Å garantere at det ikke skjer en deadlock. Altså, la oss si at operativsystemet tilbyr sematforer sånn som dette", "source": "lecture"}
{"lecture_id": "os13del4", "chunk_id": "os13del4_0003", "start": 425.96, "end": 513.98, "token_count": 315, "text": "Og det kan være litt vanskelig å programmere, fordi du ofte må teste det ut. Men da kan det være sånn at deadlock oppstår bare i ekstremt sjeldne tilfeller. Og så oppdager man ikke før det skjer i kjørende kode. For vanlige brukerprosesser så er det vanskelig for operativsystemet. Å garantere at det ikke skjer en deadlock. Altså, la oss si at operativsystemet tilbyr sematforer sånn som dette med mate og signal, men hvis to programmer bruker det på denne måten her, så skjer det en deadlock. Og det er... Da er det vanskelig for operativsystemet å gjøre noe med det. Så metode to er altså å løse opp en deadlock, men det er generelt vanskelig. For ofte så holder en prosess på en ressurs av en grunn. Det er ikke bare tilfeldig at den har tatt den gaffelen. Den skal ha den. Så det er generelt vanskelig å løse opp deadlocker etter at det har skjedd. Så en vanlig måte å håndtere deadlock-problemer på er å stikke hodet i sanden, som strutser gjør. Og det er ofte sånn operativsystemet gjør. Så ignorerer operativstemme det problemet.", "source": "lecture"}
