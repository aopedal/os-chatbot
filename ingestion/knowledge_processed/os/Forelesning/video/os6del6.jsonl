{"lecture_id": "os6del6", "chunk_id": "os6del6_0000", "start": 0.0, "end": 220.1, "token_count": 592, "text": "Da skal vi se på en kode som ser ganske vanlig ut, men som har en veldig spesiell oppførsel. Og det er et C++-program. Vi kan ta det først. Vi ser det heter B.cpp. Og det er et C++-program. Det kopieres da ikke med GCC, men med B.cpp på den måten her. Og kjøres med.a.dot. Akkurat som for GCC. Så veldig forskjellig er det ikke. Men... Dette kunne også vært kjørt i C, men jeg gjør det i C pluss pluss. Eller å operere med Array der. Så et C-pluss-pluss-program ligner veldig på C. Den store forskjellen på C-pluss-pluss og C er at C-pluss-pluss er objektorientert, mens C ikke er objektorientert. Men det er ikke det som er fokus her. Fokus her er dette litt enkle... Men det er lagd for å illustrere dette med branch prediction. Og det er et ganske enkelt program. Vi har et stort RA som har 32 000 elementer. RA-sizen er her. Man deklarerer dette som et RA med 32 768 elementer. I første omgang er det bare en enkel forløkke som initialiserer alle disse 32 000 r-elementene. Variabelen c løper gjennom alle tall opp til 32 000. Og så er det kode her... Her står det RAND. Det er en funksjon som trekker ut... Et tilfeldig tall. Og så ser vi at det prosent, det er... Det er en heltallsdivisjon. Så... Og den prosent, den gir da resten, sånn at... Det eneste du trenger å vite, er at resultatet av denne her, det er et tilfeldig tall mellom 0 og 255. Det er da resten hvis du tar et tall og deler på 256. Enten går det opp, du får rest 0, eller så får du 1 i rest. Da blir tallet 1, eller så får du helt opp til 255 i rest. Hvis tallet er ett større, så går det opp igjen. Rad gir et tilfeldig svært heltall. Og dette gir da tilfeldige tall mellom 0 og 255. Så det er utgangspunktet. Vi har et sånt r-ei. Så går vi litt lenger ned. I programmet, så ser vi liksom hovedprogrammet, hva det utfører. Og det er her som det skjer rare ting.", "source": "lecture"}
{"lecture_id": "os6del6", "chunk_id": "os6del6_0001", "start": 185.56, "end": 362.76, "token_count": 598, "text": "Da blir tallet 1, eller så får du helt opp til 255 i rest. Hvis tallet er ett større, så går det opp igjen. Rad gir et tilfeldig svært heltall. Og dette gir da tilfeldige tall mellom 0 og 255. Så det er utgangspunktet. Vi har et sånt r-ei. Så går vi litt lenger ned. I programmet, så ser vi liksom hovedprogrammet, hva det utfører. Og det er her som det skjer rare ting. For det første så skriver vi bare ut de ti første verdiene for å se om R-øyet er sortert eller ikke. I utgangspunktet er det ikke sortert, men etterpå skal vi skru på sortering, og det er da rare ting skjer. Det det litt naive programmet gjør, er at det legger sammen alle tall større enn 127. Og det gjør vi inni den indre løkka her. Så ser vi at jeg har lagt på en ytre løkke. Ikke tenk så mye på den. Det er bare lagt til for at dette skal ta litt tid. CPU-er er utrolig kjappe, sånn at hvis vi bare hadde gjort én kjøring, så ville det å bare starte opp programmet tatt så mye tid. Se på forskjell i tiden det tar å kjøre. Det er den som er spesiell. Vi gjør dette 50 000 ganger, men hovedpoenget er hva vi gjør inni løkka her. Jo, der sier vi at hvis dette tilfeldige tallet mellom 0 og 255 er større enn 127, så skal det summeres. Så det betyr bare... Vi tar alle tall større enn 127 og legger seg an. Og så skrive ut summen. Foreløpig har det jo ikke noe merkelig skjedd med det. Vi kan ta det ut og kompliere det. Og så kan vi kjøre det. Men vi må da ta tiden på det når vi kjører. Og så ser vi... Dette er starten av æreiet. Så jeg har skrevet ut de ti første elementene. Det er ikke sortert. Det kommer helt tilfeldig. Og vi ser at dette programmet tok noe 20 sekunder. RIL her, det er hvor lang totaltid det tok. User, det er hvor mye CPU som ble brukt i use mode. Det skal vi snakke om i neste uke. Men kort sagt er det vanlige kommandoer som... ... brukerprogrammet utfører.", "source": "lecture"}
{"lecture_id": "os6del6", "chunk_id": "os6del6_0002", "start": 321.32, "end": 512.12, "token_count": 597, "text": "Og så ser vi... Dette er starten av æreiet. Så jeg har skrevet ut de ti første elementene. Det er ikke sortert. Det kommer helt tilfeldig. Og vi ser at dette programmet tok noe 20 sekunder. RIL her, det er hvor lang totaltid det tok. User, det er hvor mye CPU som ble brukt i use mode. Det skal vi snakke om i neste uke. Men kort sagt er det vanlige kommandoer som... ... brukerprogrammet utfører. System er hvor mye tid som ble brukt av dette programmet i current mode. Typisk for et regneprogram som dette her bruker man veldig lite operativsystemkjernen. Stort sett er det bare programmet selv som står og kjører. Men så skal vi se på det som er litt mystisk... Vi går nå inn i programmet igjen og så gjør jeg én liten endring, og det er at... Jeg sorterer... dataeie. Det er en sånn sort-metode som har den syntaksen der. Det eneste dere trenger å vite, er at dette funksjonsskallet sorterer ereie-data. Og da... Det er den eneste forskjellen jeg gjør. Ellers så skjer nøyaktig det samme her nede. Går gjennom like mange løkker. Det er ikke forskjell på summen, for summen bør bli den samme. Det er bare at her ligger tallene i rekkefølge i dataeriet. Så kompilerer jeg på nytt. Og så tar tiden på hvor lang tid det tar. Og nå ser vi at nå er de første elementene sortert, med null først. Alle elementene med null i kommer først. Og så kommer alle de andre elementene. Men da ser vi... Her gikk plutselig programmet veldig mye fortere. Du brukte 17 sekunder her oppe og 11 sekunder her nede. Og det er... Det er det som er det store spørsmålet. Er det noen som kan se hva dette kan komme av? Hvorfor i all verden går plutselig programmet fortere? Man sorterte RE. For... Nå må vi begynne å se på hva i all verden som skjer her. Random RE er det samme i begge tilfeller. Så sorterer man RE. Og så hopper man hit. Her skriver du ut de ti første. I det andre tilfellet var det bare nuller. Men den indre løkken her, den går... Her skjer jo akkurat det samme.", "source": "lecture"}
{"lecture_id": "os6del6", "chunk_id": "os6del6_0003", "start": 472.52, "end": 688.68, "token_count": 588, "text": "Er det noen som kan se hva dette kan komme av? Hvorfor i all verden går plutselig programmet fortere? Man sorterte RE. For... Nå må vi begynne å se på hva i all verden som skjer her. Random RE er det samme i begge tilfeller. Så sorterer man RE. Og så hopper man hit. Her skriver du ut de ti første. I det andre tilfellet var det bare nuller. Men den indre løkken her, den går... Her skjer jo akkurat det samme. Den eneste forskjellen er at data-r-et er sortert. Og hva vil det si i praksis? Jo, det... I praksis så vil... ... vil man først gå gjennom en masse elementer hvor data... Og etterpå går man gjennom en masse elementer, altså ca. 15 000, hvor dette slår til. Det kommer noen forslag... Mer effektiv pipelining? Ja, det... det k... Absolutt, det kan man si. At pipeliningen er mer effektiv. Men på hvilken måte? Går inn i if flere ganger, den som foreslår. Det gjør man ikke. Dette vil slå til akkurat like mange ganger. Så antallet institusjoner som utføres, er faktisk den samme. Kanskje den bare sjekker if-testen én gang? Nei, den vil måtte sjekke if-testen hver eneste gang. For selv om r-a-y er sortert, så vet ikke... Operativsystemet eller noen andre at det er sortert. Så det må sjekke hver gang. Er ikke dette speculative execution? Jo, nettopp! Dette er speculative execution. For når programmet kjøres, så lærer... CPU-en lærer da hva som har skjedd. Føre statistikk over hva som skjer når man kommer til denne if-testen i maskinkoden. Når arrayet er sortert, så vil systemet lære at denne testen her, den slår ikke til. Så her satser vi på at den ikke slår til. Da bruker man speculative execution, så man begynner å utføre... Da går det mye fortere, for da hopper man over når det ikke er større enn 127. Og etterpå kommer det masse RAI-data som er større enn 127. Og da gjetter systemet, eller CPU-en, på at nå skal vi legge sammen. Og da utføres den addisjonen hver gang.", "source": "lecture"}
{"lecture_id": "os6del6", "chunk_id": "os6del6_0004", "start": 638.08, "end": 798.3, "token_count": 529, "text": "Når arrayet er sortert, så vil systemet lære at denne testen her, den slår ikke til. Så her satser vi på at den ikke slår til. Da bruker man speculative execution, så man begynner å utføre... Da går det mye fortere, for da hopper man over når det ikke er større enn 127. Og etterpå kommer det masse RAI-data som er større enn 127. Og da gjetter systemet, eller CPU-en, på at nå skal vi legge sammen. Og da utføres den addisjonen hver gang. Den gjetter riktig hver gang, og det er ganske mange ganger. Det er 32 000 elementer, så hver eneste gang den kommer til gift-testen, så gjetter den riktig. Eller det vil si, de 15 000 første gangene, så blir det en bom, kanskje noen bommer, helt til den skjønner... OK, her, herfra og ut, så gjetter den riktig. Og dermed går det mye fortere. Derimot, når R1 er hulter til bulter, så vil det omtrent ca. annenhver gang... Og da er det typisk at branch prediction bare bommer hele tiden. Så... Ja, så det er riktig som oppsummert er. Branch prediction gjetter da veldig ofte korrekt. Og systemet går mye raskere. Det er et spørsmål om hvorfor det går så fort å sortere r-øyet. Ja, det kommer jo egentlig i tillegg. Det er et godt spørsmål. Men denne operasjonen her med å sortere... Hvor hadde jeg den? Her, ja. Sort data. Denne operasjonen er veldig rask. Og i tillegg ser vi at den utføres før løkkene. Så jeg sorterer ikke 50 000 ganger. Hvis jeg hadde lagt inn sorteringen der, hadde det ikke vært så stor... Men i forhold til å kjøre den løkka 50 000 ganger, hvor man går gjennom 32 000 RAI-biter, så er denne operasjonen veldig rask. Men det tar litt tid, men det har ikke noe særlig effekt for totaltiden.", "source": "lecture"}
