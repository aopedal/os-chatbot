{"lecture_id": "os8del13", "chunk_id": "os8del13_0000", "start": 0.0, "end": 141.0, "token_count": 483, "text": "Og det er denne Need resched. Det står altså trenger reschedulering. Og det skjer hvis det i løpet av epoken kommer inn et interrupt, så vil dette flagget bli satt. Det er en sånn 01-bit i CPU-en. Og hvis dette bitet blir satt, så vil scheduleren kjøres etter neste timetick. Husker du at hvis det var en prosess som hadde la oss si 20 tics, Sheduleren går inn og kontrollerer om det har skjedd noen interrupts. Nei, det har ikke det. Da bare kjører samme prosess videre. Så slipper den cotex-witchen. Men hvis det har kommet en interrupt, så er den bitte satt, og da kjøres scheduleren på nytt. Og da kan den gå inn og sag. Ok, da gir jeg den... Den prosessen som har høyst prioritet, den får nå kjøre. Interaktive prosesser som har bygd seg opp høy prioritet ved å ikke bruke CPU. Du får liksom goodwill. Når jeg kommer inn, så bruker jeg omtrent ikke CPU. Men da vil jeg ha høy prioritet. Og det er akkurat sånn skeduleren bygger opp systemet. Noe tilsvarende må alle andre skedulere gjøre også. Dette er en veldig viktig mekanisme når du skal kjøre både interaktive prosesser og regneprosesser samtidig på det samme systemet. Hvis vi ikke hadde sånn, så måtte man vente helt til den CPI-intensive prosessen var ferdig med sin del. Og hvis det tok flere tidelssekunder, så ville det oppleves som veldig tregt for en interaktiv prosess. Ok. Dette var de viktige prinsippene bak skredulering. De to viktigste prinsippene var user mode og cull mode. Og i tillegg systemkall og trap. Disse begrepene må dere ha... De må dere ha greie på. De er det viktigste når det gjelder operativsystem.", "source": "lecture"}
