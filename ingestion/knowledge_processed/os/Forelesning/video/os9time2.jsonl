{"lecture_id": "os9time2", "chunk_id": "os9time2_0000", "start": 0.0, "end": 203.08, "token_count": 593, "text": "Før pausen så vi på Nice, og vi kan fortsette å se på det. Der har vi Nice Vindu, og de jobbene står fortsatt og kjører. Jeg stilte noen spørsmål før pause, og det var i hvert fall... Christian hadde godt svar på begge deler. Nemlig... Så lenge det ikke er noen andre jobber som bruker SUPU, så vil jo ikke nice-verdien ha noe å si. Fordi da er det ingen andre som trenger SUPU. Og når det ikke er noen andre der, så trenger man ikke å være nice med de heller. Så dermed så kjører de med 100 % hele tiden. Men jeg spurte da også neste spørsmål... Hvordan kan man prøve å kjøre førerprosesser? Nei, hvordan kan man vise effekten? Da foreslo Christian å kjøre flere prosesser på samme CPU. Og bruke TASSET med ulike nice-verdier. Det er også et veldig godt forslag, for da vil du kunne se den effekten. En annen måte å se den samme effekten på, er jo å fylle hele serveren. Med regnejobber. Og... det... ja... Da vil du få den samme effekten, men da begynner serveren å fryse. Jeg kjører dette på laptopen min, og her kjører jeg også OBS, Studio og Zoom. Så jeg tror jeg foretrekker det forslaget til Christian, og så teste ut det. Hovedpoenget var at hvis man ser på Last Used CPU... Hvis jeg tar med den kolonnen... Så ser vi at... Ja, det er definitivt noen som flytter seg litt. Når jeg sa på én og to, så sa vi OBS og Zoom som også bruker mye. De kjører faktisk noen ganger på samme CPU. Men de kjører da typisk på andre CPU-er enn regnejobbene. Og dermed så vil ikke regnejobbene trenge å være nice. Men det kan likevel være fint å ha. Hvis du f.eks. skal kjøre masse videoer, sånn som jeg gjør noen ganger, da kan det være nyttig å ha på Nice. At ikke systemet fryser når jeg kjører 18 forskjellige videojobber som står og karner og rendrer videoer. Det er veldig tungt. Når jeg har sett på Nice, så vil de være nice med andre jobber. Sånn at systemet ikke blir så tungt.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0001", "start": 159.82, "end": 396.5, "token_count": 595, "text": "Og dermed så vil ikke regnejobbene trenge å være nice. Men det kan likevel være fint å ha. Hvis du f.eks. skal kjøre masse videoer, sånn som jeg gjør noen ganger, da kan det være nyttig å ha på Nice. At ikke systemet fryser når jeg kjører 18 forskjellige videojobber som står og karner og rendrer videoer. Det er veldig tungt. Når jeg har sett på Nice, så vil de være nice med andre jobber. Sånn at systemet ikke blir så tungt. Men først og fremst så ser vi på dette for å se hvordan prioritering fungerer. Da skal vi prøve å teste ut Christians forslag med å bruke Task Set. Nå står jo de jobbene der og hopper frem og tilbake. Så vi kan ta... kanskje og drepe regnejobbene først. Og så kan jeg i stedet si Task Set. La oss si vi setter de på prosessor 3. Så kan jeg ta nice minus 1,19 på regnjobben... regn. Sånn. Og da skal vi se om vi ser... Skulle gjerne hatt med Last Use To Poo... Og en litt større. Der. Da ser vi den ene jobben som jeg ba om, så står den på tre. Men hva om jeg nå... setter en jobb til der? Og så gir jeg den en bitte litt nice en. Ja, jeg får en effekt, men effekten er så stor at jeg nesten ikke så regnejobben. Men her nede kommer da den andre regnejobben. Den som har nice19, den kjører nå nesten ikke noe CPU. Den har 1,7 %, mens denne som er ganske... bare lite grann nice. Den får det aller meste. Hvis jeg nå kjører en default uten å bruke nice i det hele tatt, så vil den få enda litt mer. Da ser vi... Da kommer zoom-obs høyere, men her har vi nå regnejobbene. Og den jobben som har nice null, sånn standard, den får 55 %. Du ser den er litt nice med den andre regnejobben. Og vi gir litt mindre. Mens den som er 19, den er supernice. Så på denne måten fungerer nice. Men vi hadde et annet problem før pause også. Jeg prøvde å sette nice til 18 på en som hadde nice verdi 19. La oss si... Jeg er lei av at denne her... Nei, hva var det den var...", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0002", "start": 348.82, "end": 569.92, "token_count": 591, "text": "Da kommer zoom-obs høyere, men her har vi nå regnejobbene. Og den jobben som har nice null, sånn standard, den får 55 %. Du ser den er litt nice med den andre regnejobben. Og vi gir litt mindre. Mens den som er 19, den er supernice. Så på denne måten fungerer nice. Men vi hadde et annet problem før pause også. Jeg prøvde å sette nice til 18 på en som hadde nice verdi 19. La oss si... Jeg er lei av at denne her... Nei, hva var det den var... Denne her har så lav nice-verdi, så jeg skal prøve å renaise. La oss si til pluss fem. Men da får jeg permisjonen her, og som en påpekte i chatten... Kanskje det ikke er lov. Og det ser vi også at... I man-sidene så står det at... Skal vi se om vi finner det... Ja...... så en vanlig bruker kan bare øke nice-verdiene. Så hvis du først har sagt at du skal være nice, så kan du ikke gå tilbake til det. Så det er derfor man får permission denied. Mens som sagt så kan Ruth sette nice verdier. Så jeg gjør det med sudo. Sudo re-nice, den setter da nice-verdien til 5. Det er egentlig litt rart. Skulle tro man kunne sette den til 0, men sånn er det. Og med sudo så kan jeg også da sette nice-verdien til noe negativt. Den der har nå minus 5. Men det ser faktisk ikke ut som den... Likevel for noe mer slippu? Jo, i forhold til regnejobbene... Så ser vi nå for den som har minus 5 her... Den får 63 %, mens de andre regneobnene er 2016. Dette gir da en prioritet som er enda høyere enn 0, som er default. Og vi snakket om 140 prioritetsklasser. Det er disse 40 fra nice verdi minus 20, som er det høyeste, Det er de 40 prioritetsklassene som er for vanlige gyserprosesser. Vanlige brukerprosesser. Men i tillegg har man 100 prioritetsklasser som er for realtime-prioritering. Og det types av kjerneprosesser som skal gå veldig fort. Og her står det RT, og ikke noen nice-verdi. Det betyr at den hører til de 100 prosessene som har", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0003", "start": 527.2, "end": 758.86, "token_count": 600, "text": "Og vi snakket om 140 prioritetsklasser. Det er disse 40 fra nice verdi minus 20, som er det høyeste, Det er de 40 prioritetsklassene som er for vanlige gyserprosesser. Vanlige brukerprosesser. Men i tillegg har man 100 prioritetsklasser som er for realtime-prioritering. Og det types av kjerneprosesser som skal gå veldig fort. Og her står det RT, og ikke noen nice-verdi. Det betyr at den hører til de 100 prosessene som har Migration og watchdog... Det er typisk noen systemprosesser. De har en annen prioritetsklasse. RealTime er typisk en... Generelt som en prosess som må kunne utføres innen en viss frist. Du kan ha en realtime-prosess som i løpet av et hundredeles sekund må bli ferdig. Så det er en annen prioritetsklasse. Så de går over disse jusprosessene. De har da 40 prioritetsklasser. Og med Nice og Re-Nice kan man flytte seg opp og ned i de prioritetsklassene. Yes... Det tror jeg var det meste om Nice. Så... Da skal vi gå tilbake til sleidene. Dette var hvordan man kan endre på prioritet på et Linux-system. Prioritet i Windows... På helt samme måte så kan man prioritere jobber i Windows. Windows har også dynamisk prioritet, som endres på noe av den samme måten. Med admin-rettigheter... Hvis man administrerer to vinduer, så kan man endre prioriteten fra Task Manager. Men man kan ikke gjøre det som vanlig bruker, sånn som i Linux. Hvis man tester ut det, vil man se at det er veldig hard prioritering. Det er enorme forskjeller når du gjør disse prioritetene. Den vil dynamisk prioritere prosesser etter mye av de samme prinsippene. Skal vi se lite grann på prosessforløpet? Vi har jo vært mye inne på dette her, tilsvarende som i den vaffelsimuleringen. Jo, et par ting... noen begreper som vi kan ta med. Et prosessforløp så starter det som en ny prosess. Det er sånn alle prosesser starter. Og så legges det i reddelist. I vaffelsimuleringen så var forelesning og vaffelprosessen helt inne i reddelist og ønsket å kjøre. En dispatcher er den delen av skredderen som velger hvilken prosess som skal kjøre.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0004", "start": 709.52, "end": 917.78, "token_count": 592, "text": "Vi har jo vært mye inne på dette her, tilsvarende som i den vaffelsimuleringen. Jo, et par ting... noen begreper som vi kan ta med. Et prosessforløp så starter det som en ny prosess. Det er sånn alle prosesser starter. Og så legges det i reddelist. I vaffelsimuleringen så var forelesning og vaffelprosessen helt inne i reddelist og ønsket å kjøre. En dispatcher er den delen av skredderen som velger hvilken prosess som skal kjøre. Dispatcheren setter i gang og kjører prosessen. Når den er i rødningstilstand, kan den få et interrupt. Det typiske interruptet er timer interrupt. Hvert hundrede sekund vil man kunne bli avbrutt. Man kan velge å gi flere tics til samme prosess, sånn at den kjører litt lenger enn minste tidsenhet. Men så kan man også få IO. Det er sånn man venter på melkemannen. Eller noe fra disk, eller noe som tar lang tid. Så blir den tatt ut fra rønning og satt i en waiting-kø. Da er den heller ikke i ready-list. Etter de prosessene som er klare til å kjøre. Det er de som får tid. Det var også derfor de to jobbene som var nicet, fikk stå i rønning hele tiden. Fordi det ikke var noen andre i ready-list på den CPU-en. Dette er én CPU. Dette er en enkel CPU. Hvis vi har flere CPU-er, så vil vi ha én kø for CPU-en. Jeg har en liten demo av dette her også, som ligger på... ... kan jeg eventuelt se i Freero, som ligger på kurssiden. Det er en liten demo som viser hele det forløpet. Med at du har prosesser som står i redelist. Som tar jobber fra readylist og ut til running. Igjen så er denne simuleringen her, eller denne illustrasjonen, den har bare én CPU. Så da er det bare én readylist. Men med en gang du har flere CPU-er, så kan kjernetråder også kjøres på mange CPU-er samtidig. Så dermed kan du få en enda mer... En effektiv utnyttelse av de CPU-ene du har. Og brukerprogrammet vil da kunne kjøre hele tiden. Så kan scheduler kjøre på en annen CPU, og så skritulere dette.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0005", "start": 877.18, "end": 1106.86, "token_count": 600, "text": "Igjen så er denne simuleringen her, eller denne illustrasjonen, den har bare én CPU. Så da er det bare én readylist. Men med en gang du har flere CPU-er, så kan kjernetråder også kjøres på mange CPU-er samtidig. Så dermed kan du få en enda mer... En effektiv utnyttelse av de CPU-ene du har. Og brukerprogrammet vil da kunne kjøre hele tiden. Så kan scheduler kjøre på en annen CPU, og så skritulere dette. Men dette bildet er tenkt én CPU som snart kjører. Og da ser vi her... En som måtte vente, og da kommer han tilbake i Redelist når han er ferdig med å vente. Det er herfra at scheduleren og ledddispatcheren fra Redelist hele tiden plukker jobber. Ja... Det var vel egentlig det meste om den prosess... Prosessforløpet... Vi så et par nye sheddling-begreper. En queuer er den delen av scheduleren som legger i kø og beregner prioriteten skal få dynamisk. Dispatcher er den delen som velger prosesser fra redelist. Den velger ut hvilken av de som skal kjøre. Og det kan være en ganske komplisert affære hvis du har hundrevis av prosesser. Det gjorde altså at den 2.6-kjerneskeduleren som vi har sett på, ble oppgradert til en skeduleren som heter Completely Fair Scheduler - CFS. Bedre og bedre schedulere. Nå skal vi se litt på dette med å lage nye prosesser. I alle OS må man ha en eller annen mekanisme for å lage prosesser. I Unix og nå i Linux så er det en litt spesiell måte å... Så er det en litt spesiell måte å starte opp prosesser på. Prosesser lages f.eks. ved systemoppstart. Da er det en første prosess inngitt. Den aller første prosessen som starter opp. Man kan også lage prosesser. Hvis du har en kjørende prosess, så kan den utføre et systemkall og så starte en ny prosess. Som ber om at en prosess startes. F.eks. hvis du er i en bærsell, og så vil du starte enda en bærsell, skriver du vers, og da initierer du at det starter opp en ny prosess. I Linux-verdenen, i Linux-kjernen, så er det alltid én prosess som lager en annen.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0006", "start": 1067.88, "end": 1257.16, "token_count": 600, "text": "Man kan også lage prosesser. Hvis du har en kjørende prosess, så kan den utføre et systemkall og så starte en ny prosess. Som ber om at en prosess startes. F.eks. hvis du er i en bærsell, og så vil du starte enda en bærsell, skriver du vers, og da initierer du at det starter opp en ny prosess. I Linux-verdenen, i Linux-kjernen, så er det alltid én prosess som lager en annen. Et såkalt folk-systemkall. Det som er spesielt med folk, er at det kloner seg selv. Når man gjør et formsystemkall, så får man en kloning av den eksisterende prosessen. Det høres litt rart ut, men det er ikke verre enn at du får en kloning, og så setter du i gang og kjører et annet program i den kloningen. En helt ny prosess som kan være helt forskjellig fra foreldreprosessen. Men det er alltid én prosess som starter en annen. Og den som starter, er naturlig nok foreldreprosessen. Og så får den et barn. En child-prosess. I prosessverdenen så er det bare én forelder til hvert barn. Her ser vi et eksempel på det. PID er prosess-ID. En parent med payday 17.12. Så gjør den en fock. Så får man en child der nede med en ny payday. Typisk at det blir en høyere payday, for paydayene øker hele veien. Også den vil ha en parent-payday på 17.12. Så kan den her gjøre en fock igjen og lage et barnebarn til den her oppe. Så får du den type hierarkier. Det fins eksempler på at man kan drepe en parenprosess med alle barn. Så hender det at det skjer noe galt der, og da kan man få zombieprosesser. Som er sånne halvdøde prosesser. De gjør ikke noe, men det er typisk hvis... Hvis en skjellent har blitt drept uten at skjellet er blitt drept, så blir det hengende igjen en sånn zombieprosess. Det kan være vanskelig å bli kvitt, du kan se det i topp noen ganger. Men stort sett så fungerer det ryddig, så det er bare med feil at det blir zombieprosesser. Linux Fork er et systemkall for å lage en skjellprosess.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0007", "start": 1225.06, "end": 1437.78, "token_count": 591, "text": "De gjør ikke noe, men det er typisk hvis... Hvis en skjellent har blitt drept uten at skjellet er blitt drept, så blir det hengende igjen en sånn zombieprosess. Det kan være vanskelig å bli kvitt, du kan se det i topp noen ganger. Men stort sett så fungerer det ryddig, så det er bare med feil at det blir zombieprosesser. Linux Fork er et systemkall for å lage en skjellprosess. Det er en identisk prosess med kopi av alt, med PCB, data osv. Her ser dere parent-dataene. Når man gir dem folk, så lages en kopi av alt dette her. Det høres jo veldig tungt ut. Og det er ikke helt riktig, for det som egentlig skjer... Den tar ikke og kopierer alt dette minnet. Det er mer en copy on demand. Sånn at hvis den trenger noen av de dataene fra parent, så kopieres de over. Det er ikke sånn at du tar en absolutt kopi av alt. Det meste av strukturen kopieres, men av effektivitetshensyn tar man ikke Dere må bare ha en link til de delene av minnet som man trenger. Så kan man starte opp en... Som vi skal se på etterpå... Her i Child så kan det være en if-test. If I'm a child, if I'm a child, so... Start et annet program. I Windows så er det en litt annen måte å starte prosesser på. Det er hard støtte for folk, men ikke den vanlige måten å starte prosesser på. Den vanlige standardmetoden er å gjøre det kalt i Crate Process. Da sender du med ti forskjellige parametere som definerer den prosessen. Og da lages et nytt prosessobjekt. Windows er skrevet fra scratch som et objektorientert program. Det skal vi se på senere også når vi begynner med PowerShell. Så er også alltid PowerShell objekter. Så Windows er i veldig stor grad objektorientert. Ja... Bindingen mellom pant og time er ikke like sterk som den er under Linux. Det er altså create process. Da blir det... Da kan man lage en helt uavhengig prosess som ikke har noen kobling til parent. I utgangspunktet kan man også ha en sånn kobling, men den er ikke like sterk. Avslutte prosesser... Det er mange måter å stoppe prosesser på.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0008", "start": 1386.02, "end": 1583.54, "token_count": 585, "text": "Så er også alltid PowerShell objekter. Så Windows er i veldig stor grad objektorientert. Ja... Bindingen mellom pant og time er ikke like sterk som den er under Linux. Det er altså create process. Da blir det... Da kan man lage en helt uavhengig prosess som ikke har noen kobling til parent. I utgangspunktet kan man også ha en sånn kobling, men den er ikke like sterk. Avslutte prosesser... Det er mange måter å stoppe prosesser på. En normal avslutning - frivillig. I et skjell kan vi skrive 'exit'... Da stopper vi, eller i 'c' 'exit'. Så kan vi ha en avslutning med feil. Det er også frivillig. Programmet sier 'fire not found', og så 'exit'. Men så kan man ha fatal feil. At det er en ufrivillig situasjon hvor det er vanskelig for operativstøtten å gå videre. Deling med null. Hvordan skal du kunne gå videre? Da kan hele programmet krasje. Også hvis et program prøver å skrive til en del av minnene som en ikke har lov til, eller gjøre noe virkelig galt. Så kan hele programmet krasje. Da får du gjerne en sånn segmentation fault. Og det betyr at det er et eller annet minneprogram. Og at det da vil avsluttes. Så kan du bli drept av andre prosesser. I Linux har vi sett en kjørekill, eller terminert prosess i Windows. Det er et godt spørsmål i chatten. Windows er objektidentitet i motsetning til Unix, som er hva? Jo... Unix er så mangt mens vi ser på Linux. Så er Linux stort sett skrevet i C. Det er noen ganger denne uken man skal se på alle kodelinjene i Linux-kildekoden. Dere vil da se at de aller fleste linjene er C. Og programmet C er i utgangspunktet ikke objektorientert. Det vil si at Linus-stjernen er da ikke bygd opp av... Men den er jo veldig modulær. Hvis man har et objektorientert språk, så er man fullstendig tvunget til å skrive objekter og gjøre det modulært med objekter og metoder osv. Og det er veldig nyttig, for da sikrer man at man gjør det.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0009", "start": 1542.76, "end": 1756.98, "token_count": 600, "text": "Dere vil da se at de aller fleste linjene er C. Og programmet C er i utgangspunktet ikke objektorientert. Det vil si at Linus-stjernen er da ikke bygd opp av... Men den er jo veldig modulær. Hvis man har et objektorientert språk, så er man fullstendig tvunget til å skrive objekter og gjøre det modulært med objekter og metoder osv. Og det er veldig nyttig, for da sikrer man at man gjør det. Men det går også an å skrive programmer i programmingsspråk som ikke er objektorienterte. På en veldig ryddig, modulær og systematisk måte. Det kan da si Linux er. Men i utgangspunktet er da Linux ikke objektorientert. Rett og slett fordi C i programmeringsspråket det er skrevet i, ikke er objektorientert. Men at det ikke er objektorientert, betyr ikke at det er... Metoder og funksjoner og så videre... Det har det, så det er veldig systematisk oppbygging. Men det har ikke eksplisitt objektorientering. Signaler... Ja, det har vi sett på tidligere. Jeg hadde et script som jeg kjørte, og som brukte... En kommando som heter 'trapp til å fange opp signaler'. Det er ikke den trappen man har i kjernen, men den... En shell-kommando som kan ta imot et kill-signal. F.eks. kontroll-C er vel kill-signalet 2. Og så kan den behandle det. Så alle prosesser kan ta imot signaler og behandle det. Et unntak er kill-minus-9. Så den vil drepe prosessen. Jeg kjørte en liten demo av den i en tidligere forelesning, så jeg kan legge inn en link tilbake dit. Så kan man studere hvordan man kan sende signaler til prosesser, og hvordan de kan behandle det. Men det er måten prosesser kommuniserer på. Skal vi se litt på Linux-arkitektur... Ja... Hovedprinsippet bak denne tegningen er at dette som er inni boksen her, det er Linux-kjernen. Og så ser vi alle applikasjoner og verktøy. Og så gjør de systemcall til Linux-kjernen. Linux-kjernen er delt opp i fem moduler. Som sagt er det ikke objektorientert, men det er modulært.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0010", "start": 1703.16, "end": 1926.54, "token_count": 590, "text": "Men det er måten prosesser kommuniserer på. Skal vi se litt på Linux-arkitektur... Ja... Hovedprinsippet bak denne tegningen er at dette som er inni boksen her, det er Linux-kjernen. Og så ser vi alle applikasjoner og verktøy. Og så gjør de systemcall til Linux-kjernen. Linux-kjernen er delt opp i fem moduler. Som sagt er det ikke objektorientert, men det er modulært. Så det er veldig systematisk satt opp. Men i prinsippet så kan skeduleren der borte endre på ting... I filene her... Hvis man skrev koden som var skikkelig hårete, så ville det bli ekstremt komplekst og aldri funke. Det er et enormt svært program. Konklusjonen på oppgaven denne uken, så er det noe sånt som at hvis man... Skriver ned kildekoden til lynkjernen som dere skal se på, i bøker, og stabler dem oppå hverandre, så får man en stabel som er 25 meter høy. Så det er enormt mye kode. Så dette må være veldig modulært og bygd systematisk opp. Det er fem viktige hovedmoduler. Det første som vi har sett på veldig mye nå, er alt som har med prosessmanagement å gjøre. Skeduler, multitasking osv. Neste punkt vi skal se på, er ram. Vi har vært innom det, ram og cash. Cash styres ikke av operativsystemet direkte. Det er hardware-styrt, men alt som har med ram å gjøre, det styres av operativsystemet. Det skal vi se på i detalj senere. Vi kommer også til å se på filsystemet. Directories, mapper... og hvordan de... Alt dette er lagret på harddisk. Så det er de tre viktige komponentene. I tillegg har vi alle mulige deviser. Sånn som... Tastatur og terminaler og... Nettverkskort kommer under nettverk, men alle mulige andre devices. Her er det masse kode. De er i prinsippet ganske enkle ting. Men det som gjør det vanskelig, er at det er hardware. Så det er veldig mye jobb å skrive drivere til alle mulige typer hardware. Det kom vi ikke så veldig mye inn på. Vi kommer heller ikke inn på nettverk. Mange av dere har nettverk med Alfred, så i det kurset...", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0011", "start": 1877.08, "end": 2090.14, "token_count": 595, "text": "Tastatur og terminaler og... Nettverkskort kommer under nettverk, men alle mulige andre devices. Her er det masse kode. De er i prinsippet ganske enkle ting. Men det som gjør det vanskelig, er at det er hardware. Så det er veldig mye jobb å skrive drivere til alle mulige typer hardware. Det kom vi ikke så veldig mye inn på. Vi kommer heller ikke inn på nettverk. Mange av dere har nettverk med Alfred, så i det kurset... Iallfall for dataingeniører og IT, så er det det kurset hvor vi ser på nettverk. Tidligere var nettverk en del av OS-kurset, men nå er det et eget kurs. Windows-arkitektur... I prinsippet er det mye som ligner, men noen forskjeller. Her igjen er denne nederste boksen kjernen. Så vi kjører YSMOD her oppe med brukerapplikasjoner. Alt dette kjører YSMOD og ber da operativsystemskjernen om hjelp gjennom API-et, gjennom systemkallet. Med liten skrift Ntoskurnal.exe. Den vil du finne på en Windows-maskin. Hele dette programmet er LTOS-kernel.xe. Windows har også en såkalt monolittisk kjerne. Det vil si at du har én stor kodeenhet, hvor i prinsippet man kan... Her borte fra devices og filsystemer kan det ødelegge for grafikken. Fra såkalt mikrokjerne, hvor du da har en veldig liten mikrokjerne... Og da typisk disse delene er helt uavhengige... Og snakker med hverandre via signaler. Altså det kommuniserer med mikrokjernen og seg imellom. Mens i mononettiske kjerner, som både Linux og Minus er... Kan alle deler av kjernen snakke med alle deler av kjernen? Det betyr også at kompleksiteten blir veldig stor, og det øker sjansen for feil. En viktig forskjell på Windows og Linux er at grafikken er en del av kjernen. Det er noen forskjeller på det, har man tatt ut i noen sølveversjoner. Så er alt med grafikk en del av vinduets kjerne. Sånn er det ikke i Linux. Som vi ser her, har vi ikke noen direkte del av kjernen som styrer med grafikk. Det som skjer der, er at grafikk kjøres i user mode.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0012", "start": 2044.86, "end": 2290.22, "token_count": 587, "text": "Det betyr også at kompleksiteten blir veldig stor, og det øker sjansen for feil. En viktig forskjell på Windows og Linux er at grafikken er en del av kjernen. Det er noen forskjeller på det, har man tatt ut i noen sølveversjoner. Så er alt med grafikk en del av vinduets kjerne. Sånn er det ikke i Linux. Som vi ser her, har vi ikke noen direkte del av kjernen som styrer med grafikk. Det som skjer der, er at grafikk kjøres i user mode. Så er det sånn... X vindussystemer kjøres i user space.  Og det gjør også at det ikke er like effektivt. Spesielt har det tradisjonelt vært en del problemer med spill på Linux. Iallfall tradisjonelt, nettopp pga. pilene der. I tillegg har vi denne mikrokernen her som styrer alle disse underdelene, sånn som... Objektmanager, fyllsystem osv. Men det er ikke en ekte microcarnal i den for sånn at den bare kommuniserer med signaler med de andre modulene. Men det er en liten del av kjernen som styrer alt det andre. I tillegg har man HAL, som skal gjøre at kjernen her... Får et uniforms grensesnitt mot hardware. Så hvis man endrer hardware her nede, så tar HAL det av seg. Sånn at Colonel får det samme grensesnittet. Uansett hva slags hardware som ligger under. Ok, det var litt om arkitektur. Og da tenkte jeg helt til slutt at vi skulle se på folk. En demo her oppe, så da skal vi se på... Fock. Da skal vi gå tilbake hit. Og så... Da skal vi se på en folk-demo. Folk er litt merkelige. Det er ikke så lett med en gang å skjønne hvordan det fungerer. Men det som skjer når jeg gjør et folk-kall... Og jeg trenger disse bibliotekene her for å kunne bruke folk. Det første programmet skriver ut folk dem òg, en linje. Og så gjør man et system kalt 'folk'. Så skriver man ut en linje til. Og det som skjer da, når du gjør 'folk', er at fra og med neste linje... Den fortsetter å kjøre og skriver ut den linjen. Men så startes det også opp en Child. Og Child er en kopi av Parent.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0013", "start": 2240.96, "end": 2449.38, "token_count": 591, "text": "Men det som skjer når jeg gjør et folk-kall... Og jeg trenger disse bibliotekene her for å kunne bruke folk. Det første programmet skriver ut folk dem òg, en linje. Og så gjør man et system kalt 'folk'. Så skriver man ut en linje til. Og det som skjer da, når du gjør 'folk', er at fra og med neste linje... Den fortsetter å kjøre og skriver ut den linjen. Men så startes det også opp en Child. Og Child er en kopi av Parent. Så siden den er en kopi av Parent, så vil den fortsette der Parent slapp. Og så vil den også skrive ut folk de må. Så vi kan prøve å kjøre den. Og så se hva som skjer. Men da får vi ut tre folk-demoer. Det ser jeg liksom... Jeg ble alltid litt overrasket første gang. Oi, jeg skriver jo bare to ganger. Men den første folk-demoen her... For å gjøre det helt klart... Folk-demo... Vi kan kalle den én. Og så kan jeg skrive folk-demo to. Så den første, det er den første. Og så kommer det to som er folk demo to. For den ene er da parent, og den andre er sire. Så vi kan gjøre det eksplisitt. Komplimerer å kjøre i. Folk demo én skrives ut av den første. Og så folk demo to av den andre. Og sånn kan man jo fortsette. De som gjør det sånn... Hvor mange får ikke det må skrives ut, sånt totalt antall linjer? Hva tror dere? Det er et forslag om sju stykker. Ja, det høres fornuftig ut, fordi man kunne kanskje tenke at det bare ble fem. Men... Her har jeg en fork, og da er det allerede... Den ville også childgjøre, så den vil lage et barnebarn, så her vil jeg doble igjen. Så jeg får liksom først én prosess, så er jeg to, og så er jeg fire. Så da burde det bli syv stykker. Yes. Dere er altfor gode. Dere svarer riktig med en gang. Mye bedre om noen av dere feiler først, men veldig bra. Så skal vi prøve å se på litt... Ja, hvor da? Hvordan kan man egentlig bruke dette her? Det ville jo ikke være så veldig hensiktsmessig hvis...", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0014", "start": 2402.56, "end": 2628.5, "token_count": 584, "text": "Den ville også childgjøre, så den vil lage et barnebarn, så her vil jeg doble igjen. Så jeg får liksom først én prosess, så er jeg to, og så er jeg fire. Så da burde det bli syv stykker. Yes. Dere er altfor gode. Dere svarer riktig med en gang. Mye bedre om noen av dere feiler først, men veldig bra. Så skal vi prøve å se på litt... Ja, hvor da? Hvordan kan man egentlig bruke dette her? Det ville jo ikke være så veldig hensiktsmessig hvis... Hvis man bare... kjørte videre akkurat det samme programmet. Så skal vi prøve å se på litt hva... Hva er det... Hva er det denne folk returnerer int. payday? Så kan jeg ta... Skal vi se... Kan jeg ta en printf...? Ja, det er spørsmål om hvorfor det skrives nummer tre ut fire ganger. La oss se litt nærmere på det. Jo, det er fordi... Her startes en shale. Og dermed er det to programmer som skriver et Folk-demo 2. Og da vil det første... Parent som skriver et Folk-demo 2 her... Det vil gjøre folk... Og da vil du få... Da vil Terence selv skrive ut demo 3, og den charten som lagde, skrive ut demo 3. Det samme skjer da med den demo 2 her, som ble startet. Den skriver ut demo 2, og så lager den chart. Og så selv skriver den ut demo 3, og så er det charten dens igjen som skriver ut enda en demo 3. Så dermed blir det fire ganger utskrift med Demo 3. Men det er ganske forvirrende når man driver og setter det opp. Det er ikke så opplagt at det blir syv. Men det er noen oppgaver denne uken som går på dette her, så prøv og feil litt med folk. Men hovedpoenget var at man kan... Hvis jeg husker riktig syntaks... Så kan man skrive ut... PiD er lik... Skal vi se... 1,5 % D. Kan få ha noe sånt. Og så er det payday lik 0. Akkurat dette kan vi bruke til noe. Det er en kommentar at dette er nesten som rekvisjon. Ja. Det er rekvisjon, men ikke helt som når en metode kaller seg selv.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0015", "start": 2566.54, "end": 2858.54, "token_count": 598, "text": "så prøv og feil litt med folk. Men hovedpoenget var at man kan... Hvis jeg husker riktig syntaks... Så kan man skrive ut... PiD er lik... Skal vi se... 1,5 % D. Kan få ha noe sånt. Og så er det payday lik 0. Akkurat dette kan vi bruke til noe. Det er en kommentar at dette er nesten som rekvisjon. Ja. Det er rekvisjon, men ikke helt som når en metode kaller seg selv. For når en metode kaller seg selv, så starter den alltid fra starten. Men her er en slags rekvisjon hvor du... Eller... Man kunne tenke seg at når du gjør en fork... At du starter programmet på nytt. Men da må man huske på at dette er en kopi av det programmet som kjører. Så det er en kopi som fortsetter å kjøre derfra parent-prosessen er. Det er akkurat det samme programmet, og dermed vil ikke... Child vil ikke sette i gang og kjøre den første printen. Den vil bare fortsette derfra. Det er derfor jeg aldri får noen førsteprint fra skjerm. Så det er et slags rekkerskiftkall, men det rekkerskiftkallet starter fra nøyaktig der parent er, og fortsetter derfra. Så det er rett og slett en kopi. Man kopierer alt ved prosessen... Og så kjører den videre derfra den forrige slapp, som en eksakt kopi. Men det er en forskjell, og det er nemlig den payday-en. For da er det sånn at i Child så returnerer forkallet null. Mens i Parents så returneres paydayen til Child. Så dermed så kan man utnytte dette, og så kan man si... If payday er lik null... Hva skjer da? Jo, da kan man si... Jeg er child. Folk ga PD... Og da bør det bli PD-lignende. Sånn. Og så kan vi si Elds. Jeg er ferdig... Skrives denne siste linjen ut her... Jo, det som forhåpentligvis skjer nå, er at for Child så kjører jeg denne. Og så for Parent så kjører jeg bare den der. Så vi skal få to utskrifter. Men hvor mange ganger kjører den? Får ikke det noe avsluttet på? Jo... To ganger, ja. Flere som sier to. Helt riktig. Dette er bare en if-test.", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0016", "start": 2787.46, "end": 3049.48, "token_count": 593, "text": "Jeg er ferdig... Skrives denne siste linjen ut her... Jo, det som forhåpentligvis skjer nå, er at for Child så kjører jeg denne. Og så for Parent så kjører jeg bare den der. Så vi skal få to utskrifter. Men hvor mange ganger kjører den? Får ikke det noe avsluttet på? Jo... To ganger, ja. Flere som sier to. Helt riktig. Dette er bare en if-test. Hvis den er skjelt, så kjører du den der. Men etter den if-testen så vil den ikke gå inn her, men den vil faktisk fortsatt kjøre den der. Så rekker den akkurat å skrive ut folk de har måttet avslutte før Shield kommer inn. Shield er nå light og skriver ut 'jeg er Shield, folk har payday' eller knull. Det vanlige er at du har en sånn test, og så kjører du ikke noe mer felles kode. Man kan også kjøre felleskode sånn som det. Og da kan man få litt mer avanserte måter å bruke folk på. Sånn som dette her... Hvor man har parent og shield. Vi skal ikke se på det i detalj... Men bare for å gi et inntrykk, så kan det se sånn ut. Med prosess-paydate 2697. Og så sier den jeg er shield. I dette tilfellet venter parent ikke på at shield er avsluttet. Da ser vi den bare fortsetter. Siden det er en kloning, så har den samme terminal output også, så den skriver default output. Child-prosess har ikke null i payday, men forkalle returnerer null. Så payday-entershield-prosessen, det er den som parent får. Dette vil da være payday-entershield-prosessen. Men... nei, dette er payday-entershield-prosessen. Child får en payday, men variabelen payday er ikke null inni child. Dette er kommunikasjon mellom de to prosessene. Vi kan gjøre en wait-pay-idé. Her er jeg nå i parent. Og den sier ok, jeg skal vente på... Jeg skal vente på shard. Så... Så burde det stått sånn. Her ser vi parents står og venter. Skjærprosess avslutter. Og så avslutter parents også. På den måten kan man starte nye prosesser, og så kan de kommunisere med hverandre. Og siden man har en sånn if-test, så kan den nye skjærprosessen", "source": "lecture"}
{"lecture_id": "os9time2", "chunk_id": "os9time2_0017", "start": 3002.92, "end": 3185.2, "token_count": 515, "text": "Vi kan gjøre en wait-pay-idé. Her er jeg nå i parent. Og den sier ok, jeg skal vente på... Jeg skal vente på shard. Så... Så burde det stått sånn. Her ser vi parents står og venter. Skjærprosess avslutter. Og så avslutter parents også. På den måten kan man starte nye prosesser, og så kan de kommunisere med hverandre. Og siden man har en sånn if-test, så kan den nye skjærprosessen gjøre hva som helst. F.eks. så kan man lage en skjærprosess, og så kan man be den... Og dermed har man en helt ny, uavhengig prosess som kjører et annet program. Ok... Oi! Nå har jeg brukt masse tid her. Nå er det sikkert rimelig utslett. Hvis dere er her, så skal jeg vel lage breakout-rooms med en gang. Så er vi... Forhåpentligvis så er vi fire stykker i dag. Med studenter og studenter. Så da blir det masse anledning til å gå inn i breakout rooms og spørre og grave og komme med alle mulige spørsmål og problemer dere har. Så utnytt den sjansen. Det tror jeg kan være veldig nyttig. Så hvis det ikke er noen kommentarer eller spørsmål inne... Er du der fortsatt? Du er der. Supert. Jeg måtte bare få på mikrofonen. Er det noe du har lyst til å legge til eller kommentere om? For eksempel om... Hvordan er situasjonen med første opplegg? Er den...? En ferdig...? Det er ferdig retta, men det er vel gitt nye flister og sånt noe. Så det har vært noen spørsmål om løsningsforslag skal legges ut, men det vil jo ikke da bli lagt ut før det har fått sin sjanse til å levere på nytt. Nei, det er sånn vi pleier å ha det. Men forhåpentligvis så blir det ganske snart. Da kommer vi til å legge ut løsningsforslag.", "source": "lecture"}
