{"lecture_id": "os14time1", "chunk_id": "os14time1_0000", "start": 0.0, "end": 232.72, "token_count": 586, "text": "Så nå er opptak startet. Skal vi se... Dette er planen for i dag. Vi skal snakke mer om internminne. Forrige gang så snakket vi ganske mye teoretisk om internminne, om hvordan MMU virker spesielt. I dag skal vi se... I større grad på det praktiske. Vi skal kjøre ganske mange forskjellige eksempler på minnebruk og hva som skjer når man kjører programmer som bruker mye minne. Og også hvordan man kan se på detaljene av minnebruken i topp. Skal vi se... Som dere ser, så er det... Vi nærmer oss slutten med stormskritt. Neste uke er siste forelesning. Det kommer til å være om disker og filsystemer. Vi håper å få begynt på det i dag. Så ser vi også at vi har rotet litt ned med mengden stoff her. De siste to ukene så er det ikke digitale forelesninger i tillegg, som det har vært tidligere, med Linux-shell og med power-shell. Så de to siste ukene blir litt roligere, og dere kan også se at det er litt færre oppgaver. Det kommer nok én til om disker, eventuelt så kommer de neste uke. Litt avhengig av hvor langt vi kommer. Men oppgavene går ut på å teste ut noe av det jeg skal se på nå i dag, på Linux-VM. Er tilgjengelig i chatten, så still gjerne spørsmål i chatten. Du kan gjerne stille til alle. Men det går også an å stille direkte til Ine, så kan hun svare direkte. Eventuelt så kan vi ta det i pausen. Ja, hvor var jeg? Jo, neste uke er siste runde. Det kommer noen flere disk-oppgaver de siste ukene. Det er ikke noen oblig 4. Oblig 3 var den siste. Men oppgavene som er merket med oblig, er ment som de som det er viktigst å få med seg i forhold til pensum og i forhold til eksamen. Ordinære forelesning, men jeg tenker å få til en prøveeksamen. Kanskje jeg kan få til to også, for jeg har... I hvert fall så har jeg... Det som var prøveeksamen i fjor, det har jeg på en måte... Et opptak av hvor jeg går gjennom alle oppgavene én for én.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0001", "start": 193.18, "end": 403.9, "token_count": 590, "text": "Men oppgavene som er merket med oblig, er ment som de som det er viktigst å få med seg i forhold til pensum og i forhold til eksamen. Ordinære forelesning, men jeg tenker å få til en prøveeksamen. Kanskje jeg kan få til to også, for jeg har... I hvert fall så har jeg... Det som var prøveeksamen i fjor, det har jeg på en måte... Et opptak av hvor jeg går gjennom alle oppgavene én for én. Så det kan være en fin test. En prøveeksamentest. Hvor dere da... Dere får en full eksamensoppgave og så går dere gjennom den på egen hånd. Og så kan dere i ettertid, hvis det er noen spørsmål dere står fast ved, så kan dere gå inn og se på hvordan jeg mente den skulle løses. Tilsvarende kommer dere til å bli for prøveeksamen. Da kan vi først ha en prøveeksamen, og så, dagen etter eller litt senere, så går vi gjennom den prøveeksamen i plenum. Altså felles. Kanskje det til og med kunne være fysisk... Nå tør jeg i hvert fall ikke å love noe. Det har vært mye kanskje tidligere. Så hvis det ikke er noen spørsmål til noe rundt kurset, så begynner vi med dagens pensum. Ja... Jeg går hakket tilbake. Før vi begynner... Det kan være lurt å ta en liten kikk på det vi holdt på med sist. Spesielt internminedelen. Det aller viktigste å ha med seg, er at internmelding eller RAM det er da bare en rekke med bite som ligger etter hverandre. Og RAM... Random Access Memory... Det er random fordi det skal ta like lang tid å hente et hvilket som helst bitt. I så syst at det er ikke helt sant, spesielt pga.... ... cash, så vi ser at det tar forskjellig tid å hente forskjellig bit. Det skal vi se på i detalj i dag, i praksis. Videre så vi mye på MMU, Memory Management Unit. Og det er da en hardware-enhet som oversetter adresser. For alle prosesser har sitt eget adresserom. Den starter fra null og går oppover. Og dette kalles da virtuelle adresser. Og de virtuelle adressene oversettes til fysiske adresser av MMU.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0002", "start": 355.56, "end": 557.88, "token_count": 597, "text": "I så syst at det er ikke helt sant, spesielt pga.... ... cash, så vi ser at det tar forskjellig tid å hente forskjellig bit. Det skal vi se på i detalj i dag, i praksis. Videre så vi mye på MMU, Memory Management Unit. Og det er da en hardware-enhet som oversetter adresser. For alle prosesser har sitt eget adresserom. Den starter fra null og går oppover. Og dette kalles da virtuelle adresser. Og de virtuelle adressene oversettes til fysiske adresser av MMU. Så inni selve prosessen tenker den bare på adresser fra 0 til 1 GB. Men de oversettes til fysiske adresser i RAM. Og da kan minneadressering nummer 1000, for eksempel, den kan... Den ligger i 14 367 millioner i ram. Og dette gjør at operativsystemet da dynamisk kan laste inn og ut sider av ram, og ikke minst laste inn og ut prosesser etter hvert som det kommer nye prosesser. Og dette er helt nødvendig for et moderne operativsystem for å kunne håndtere minnet på en ordentlig måte. Så vi så mye på det. Page table entres... Som var da den minste enheten som viser hvor en side ligger. Så det man gjorde, var istedenfor bare å se på bite for bite, så lagde man sider. Typisk 4K, 4000 bite. En sånn passe side, som er da den minste enheten som man tar inn og ut av. I tillegg så så vi på TLB fra en slite. Det er da cash for minneadressering, og som også har en stor effekt på hvor fort ting går. Heldigvis ligger stort sett minneofflag i TLB. Man får mye treffe-cash, og dermed så går det veldig mye raskere enn det ellers ville gjort. Da kan vi hoppe til dagens program, og da fortsetter vi der vi sluttet. Der. Dynamisk allokering. Som dere sikkert har prøvd selv, så kan man be om mer ram mens man kjører et program. Altså, man kan deklarere alt som er av variabler osv. i starten av programmet. Og så bare bruke det. Men man kan også, sånn som Java... Det man typisk gjør, er å ha statements om dette her. PCB er en ny prosess midt inn i programmet. Og da vet jo ikke operativsystemet eller noen andre", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0003", "start": 510.0, "end": 694.08, "token_count": 588, "text": "Der. Dynamisk allokering. Som dere sikkert har prøvd selv, så kan man be om mer ram mens man kjører et program. Altså, man kan deklarere alt som er av variabler osv. i starten av programmet. Og så bare bruke det. Men man kan også, sånn som Java... Det man typisk gjør, er å ha statements om dette her. PCB er en ny prosess midt inn i programmet. Og da vet jo ikke operativsystemet eller noen andre om at dette her kommer til å skje. F.eks. så kan man gi input underveis til et RA hvor langt det skal være. Og da må det lages underfly. Det må sette seg plass i minnet. Da er det veldig fint å ha paging, for da kan operativsømme sette av nye sider til denne prosessen dynamisk. Og da får prosessen, når den gjør noe sånt som dette, page for page med minne. Det kan jo være en sånn... Det kan jo være... Dette krever... Mange megabyte med minne og lag et nytt objekt, så... Men da får prosessen tillagt så mange sider som den trenger. I CAs C pluss pluss så må man... Når man allokerer minnet på den måten her... Vi skal se et seeksempel etterpå. Så må man etterpå slette sånne objekter som er i bruk. Hvis man hele tiden allokerer mer og mer minne uten å frigjøre det... Så får man det som man kaller en minnelekkasje. Det er et vanlig problem i programmering, altså i store servere osv. Det er et eller annet som gjør at når du kjører programmet lenger og lenger, så bruker det mer og mer minne. Og så går det tregere og tregere. Og det er en typisk minnelekkasje. Det vil bare si at man allokerer mer og mer minne. Som ikke blir frigjort. Så det må programmereren sørge for, at man frigjør mine hele tiden. Det er en av de store fordelene med mange nyere programmeringsspråk, sånn som Java. Dere tenker kanskje ikke på Java som supernytt, men i forhold til COC pluss pluss så er det relativt nytt. Og det utfører da denne oppryddingen automatisk. Såkalt garbage collection. Som skjer hele tiden bak kulissene.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0004", "start": 660.0, "end": 866.12, "token_count": 589, "text": "Som ikke blir frigjort. Så det må programmereren sørge for, at man frigjør mine hele tiden. Det er en av de store fordelene med mange nyere programmeringsspråk, sånn som Java. Dere tenker kanskje ikke på Java som supernytt, men i forhold til COC pluss pluss så er det relativt nytt. Og det utfører da denne oppryddingen automatisk. Såkalt garbage collection. Som skjer hele tiden bak kulissene. Så hvis dere har et RAI eller noen objekter som ikke brukes lenger, så fjernes det fra minnet, sånn at minnet blir frigjort til andre programmer eller andre variabler i samme program. Den delen av ramm som dynamisk kan øke og minke i størrelse, det kalles heap. Forrige gang så vi et minnekart i Linux, der dere hadde én del som var heapen. Her legges alt som er av ri og sånn, som øker og minsker i størrelse. Mens vi har stacken også. Den inneholder f.eks. alt som har med å hoppe til og fra metoder å gjøre. En organisering av ramm som operativstemme sørger for. Ok. Da... Før vi ser på noen minnebegreper, så skal vi se litt sånn i praksis på... Vi skal se litt i praksis på ramm og kjøring av ramm. Se et konkret eksempel på litt av det jeg snakket om her med dynamisk allokering. Hvis jeg klarer å finne det... Der, ja. Her har jeg et lite oppsett for å kjøre en demo. Det jeg skal se på, er et se-program. Men det vi aller først ser her, er at vi definerer et stort RA. Og da har jeg definert et tall S, som er 1024 ganger 1024. Dette er bare fordi jeg skal få én megabyte, eller det er et int RA. Så én int er fire bytes. Derfor blir dette fire mer. Dette er da et RA som tar... Hvis størrelsen er 4 MB... Før vi gjør det, så kan du... Altså... Det første vi skal gjøre, er bare å se på hva som skjer når vi deklarerer dette RA-et, og så begynne å kjøre. Og så ser vi nedover i programmet her... Så ser vi at det stopper ved første linje og skriver ut størrelse kolon.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0005", "start": 833.96, "end": 1021.28, "token_count": 586, "text": "Så én int er fire bytes. Derfor blir dette fire mer. Dette er da et RA som tar... Hvis størrelsen er 4 MB... Før vi gjør det, så kan du... Altså... Det første vi skal gjøre, er bare å se på hva som skjer når vi deklarerer dette RA-et, og så begynne å kjøre. Og så ser vi nedover i programmet her... Så ser vi at det stopper ved første linje og skriver ut størrelse kolon. Og Scanf leser inn den variabelen. Så... Det programmet vil skrive størrelse, og så vil det stoppe der. Etterpå skal vi se hvordan vi da kan lese inn størrelsen på et RAI, og så allokere det med Mallock. Men vi ser først bare på starten, og da trenger vi bare å bry oss om de tre første linjene her. Så kanskje det vi kan gjøre aller først, er også bare å lage et bitte lite RAI med én bite. For det vi skal se på nå, er hvordan... Hvordan ser det ut i topp når vi kjører dette programmet? Og programmet heter RES, så jeg kompilerer det sånn. Og så kjører jeg det med Adopt Out. Da ser vi jeg blir bedt om størrelse. Men det jeg ønsker å gjøre nå, er å se på det i topp. Den sier Topp minus P... For nå ønsker jeg å se på akkurat... bare topp for dette programmet. Når jeg gjør Topp minus P, kan jeg spesifisere hvilken payday jeg vil se på. Og så i tillegg payday of adots. Jeg kan gjøre det eksplosivt. Dermed kan jeg starte Topp på den måten her. Og så får jeg se bare info om Adolthout. Det er denne infoen her om minnene som vi skal se på nå. Tidligere har vi sett på Payday og Priority og Nice osv. Men nå skal vi se på de tre bitene der - Hvirt, Dress og Sjel.  Og kortversjonen er at hvitt, det er på en måte det virtuelle adresserommet. Det er så mye som er definert for denne prosessen. Altså så mye ram. Og ram her er definert i K. Så dette betyr at det er 4516 K med virtuelt adresserom. Så det er det som det lages plass til for hele prosessen. Alt den inneholder.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0006", "start": 974.56, "end": 1184.24, "token_count": 593, "text": "Tidligere har vi sett på Payday og Priority og Nice osv. Men nå skal vi se på de tre bitene der - Hvirt, Dress og Sjel.  Og kortversjonen er at hvitt, det er på en måte det virtuelle adresserommet. Det er så mye som er definert for denne prosessen. Altså så mye ram. Og ram her er definert i K. Så dette betyr at det er 4516 K med virtuelt adresserom. Så det er det som det lages plass til for hele prosessen. Alt den inneholder. Og så kommer det en kolonne som heter Ress. Der ser vi det er 748K. Og Ress, det er det som er resident. Altså det som ligger i Ramm nå, og som er i bruk. Her i Hvirt så ligger alt, men det er ikke alt som er i bruk. Og det kommer ikke nødvendigvis i bruk. Det spørs hvordan programmet kjøres. Men hvis mer tas inn i RAM, så skal vi se... Da vil RS øke. Men det vi først kan se, er... VIRT gir 4516 K. Og så kan vi prøve å se... Ja... Da kan vi prøve å lage det R-et. Men denne gangen lage en 4MB RA. Så da stopper jeg programmet igjen, og så går jeg inn her, og så bruker jeg den opprinnelige S-faktoren. Og da... For å se hva som skjer, så kan jeg regne litt her nede. Jeg kan regne ut 1024 ganger 1024. Ja, det blir omtrent én million, men det jeg egentlig er interessert i, det er hvor mye vil... Hvor mye vil VIRT øke når jeg legger på et R-øy? Da må jeg kanskje ta med og... Skal vi se hva vi hadde her. Vi hadde VIRT er lik 4516. Sånn. Og så skal jeg nå øke... Nå burde jo den VIRT-adresserommet øke med fire ganger 1024 ganger 1024. Og det vil si... Den burde da øke med fire ganger 1024. Eller... Ja, jeg kan skrive det. Fire ganger 1024. For det er K vi snakker om. Da burde det komme 8612 K. Så skal vi se hva som skjer her, da, om vi får til det. Jeg kompilerer nå på nytt med det store re-eiet med 1 mill. integer.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0007", "start": 1133.4, "end": 1355.48, "token_count": 593, "text": "Sånn. Og så skal jeg nå øke... Nå burde jo den VIRT-adresserommet øke med fire ganger 1024 ganger 1024. Og det vil si... Den burde da øke med fire ganger 1024. Eller... Ja, jeg kan skrive det. Fire ganger 1024. For det er K vi snakker om. Da burde det komme 8612 K. Så skal vi se hva som skjer her, da, om vi får til det. Jeg kompilerer nå på nytt med det store re-eiet med 1 mill. integer. Så må jeg starte Topp på nytt for å få med den riktige add-out. Og da ser vi... Jo, det fungerer faktisk akkurat. Da står det 8612 her, som er da... ... det opprinnelige adresserommet vi hadde. Så har vi i tillegg definert fire... Hva blir det? Fire megabyte. Og det er da fire ganger 1024 K. Den størrelsen der i hvitt. Men vi ser... Så det passet akkurat med teorien. Men vi ser... Ress her er fortsatt 748. Så kan man spørre seg hvorfor... Hvorfor ble ikke den endret? Jo, det er fordi... Hvis vi ser i koden her, så har vi bare kommet hit. Ikke begynt å bruke det static-eriet i det hele tatt. Så etter hvert som man begynner å bruke det, så vil da res kunne øke. Men i stedet for å bruke det, så skal vi se nå på hvordan vi kan legge til statisk minne. Så nå glemmer vi den... Da glemmer vi den første. Og så... skal vi se på statusen min. Det er ett spørsmål i chatten her. Kjempebra. Stopp og spør. Vi... Spørsmålet va. Hvorfor ble det fire ganger 1024? Jo, da må vi for det første vite at... En jente er fire bite. Så for det første så ble... En jente er fire bite. Og så i tillegg... Så dette... Dette teller jo opp antall elementer. 1024 ganger 1024. Det er én mega. Men det vil også si at når vi regner i K, så er dette 1024 K. 1024 bite, det er 1 K. Så dermed ble totalstørrelsen på dette ærøyet, dette her, det ble fire ganger 1024 K.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0008", "start": 1313.4, "end": 1530.24, "token_count": 584, "text": "En jente er fire bite. Så for det første så ble... En jente er fire bite. Og så i tillegg... Så dette... Dette teller jo opp antall elementer. 1024 ganger 1024. Det er én mega. Men det vil også si at når vi regner i K, så er dette 1024 K. 1024 bite, det er 1 K. Så dermed ble totalstørrelsen på dette ærøyet, dette her, det ble fire ganger 1024 K. Eller fire ganger 1024 ganger 1024 bite. Så derfor ble det fire ganger 1024. Så... fire ganger 1024... Ganger 1024 er lik 4096 K. Så det er det som var de fire ganger 1024 her nede. Ok. Da skal vi gå tilbake. Nå skrur jeg av det er-eiet her. Et like stort RI dynamisk. Da stopper jeg Adataut igjen. Sånn. Og så ser vi... Ja, da kan vi egentlig bare kompilere det programmet her. Og starte det. Så kan vi gå og se på topp hva som skjer. Da har vi igjen... Så er det 4516. Det er da... det vi starter med i utgangspunktet. Og så kan vi jo prøve å regne ut... Vi kan prøve oss å lage nå ett r-e som er like stort. Som har så mange elementer. Og når vi ser i koden her... Scanf, den leser inn... Med prosent d, så leser den inn et heltall. Det som skjer i programmet når jeg skriver inn noe her, det blir lest inn, skriver ut lager interrøy med det antallet elementer. Og her er det en kommando mallock. Mallock er opplagt en... Må opplagt gjøre et kall til kjernen, et systemkall, for å be operativstemme om å allokere minner. Og da ser vi... Det jeg sender med, er size. Det er den størrelsen i det tallet jeg sender inn, ganger size of int. Size of int pleier å være 4. Det kan også i prinsippet endres. Men dette gir da... størrelsen i bite som jeg ønsker å lokkere til her. Jeg ser det er en liten stjerne her. Jeg skal ikke gå for mye inn på det, men dette er da en... ... en adresse. Når du definerer et r-øye,", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0009", "start": 1490.64, "end": 1658.92, "token_count": 593, "text": "Og da ser vi... Det jeg sender med, er size. Det er den størrelsen i det tallet jeg sender inn, ganger size of int. Size of int pleier å være 4. Det kan også i prinsippet endres. Men dette gir da... størrelsen i bite som jeg ønsker å lokkere til her. Jeg ser det er en liten stjerne her. Jeg skal ikke gå for mye inn på det, men dette er da en... ... en adresse. Når du definerer et r-øye, så definerer du adressen til første punkt i r-øyet i minnet. Så det er da en minneadresse. Men etterpå bruker vi r-øye, akkurat som med Java. Nå står det 'klar til å bruke r-øyet'. Og så har jeg en løkke her hvor jeg går gjennom alle elementene og skriver til det. Og så stopper jeg bare med å vente på å avslutte. Men da ser vi... Her går jeg i gang og faktisk bruker R-øyet. Og det skal vi se på hvordan det funker i S. Men aller først... Vi har virtuelt 4516. Og så sier jeg... OK, jeg ønsker et så stort ære. Og da så vi... Da spratt den der opp til 8616. Litt mer enn forrige gang, hvis du husker det regnestykket der. 8-6-12. Det ser ut som det er 4K som bør brukes av ramm til å administrere et eller annet rundt... Sannsynligvis bruker Mallock noe ekstra ram i tillegg til akkurat det som settes av til Herøye. Men foreløpig er det bare i Virt. Det er bare den biten som har endret seg. Men nå klarte jeg å bruke r-øyet, så da kan jeg sende med hva som helst. Den bare leses, egentlig bare for at det skal stoppe. Så begynner jeg å bruke r-øyet, og da så vi at det tok lite grann tid. Og så spratt den opp i 5384. Og da jeg så at det var kanskje noe sånt som... Hva var det som sto her? 700 og noe. Det ble ikke helt riktig... Altså, eller... riktig... Det skulle blitt noe sånt som 700 pluss 1466. Men vi ser at det ble en del mer. Og det er tydeligvis en del mer som hentes inn i RAM og brukes aktivt.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0010", "start": 1620.68, "end": 1853.56, "token_count": 594, "text": "Så begynner jeg å bruke r-øyet, og da så vi at det tok lite grann tid. Og så spratt den opp i 5384. Og da jeg så at det var kanskje noe sånt som... Hva var det som sto her? 700 og noe. Det ble ikke helt riktig... Altså, eller... riktig... Det skulle blitt noe sånt som 700 pluss 1466. Men vi ser at det ble en del mer. Og det er tydeligvis en del mer som hentes inn i RAM og brukes aktivt. Men vi ser i hvert fall... Med en gang man da bruker dette her, så kommer det i bruk som i RAM. Registreres i MMU osv. og da... Og når man kjører programmer og kanskje har mine problemer, så er det veldig viktig å se hvite forskjeller på dette her. Du kan ha et kjempestort virt, men så lenge det ikke er i bruk i RES, så er det ikke tungt for systemet. Så det er den viktige forskjellen på de to målene her. Veldig kort til slutt om SHR, eller Shared. Det er da minnet som deles med andre programmer. F.eks. så kan det være dynamisk bibliotek. Stort sett så fins det noen dynamiske bibliotek som brukes. F.eks. C-bibliotek som da deles. Det så vi på sist, at vi kunne lage statisk bibliotek. Det var litt om... Det var litt mer om ram. Vi kan gå videre og se litt mer på noen praktiske eksempler. Da kan vi hoppe hit. Her tenkte jeg å kjøre en Vram-test. Dette er også en av oppgavene denne uken. Å kjøre et Ram... Ram SMP. Hvis vi kjører det uten argumenter, sånn som dette er, så ser vi at vi får bare litt info om programmet. Men vi ser vi trenger å ha en minus-b id. Sånn generelt når... Hvis opsjoner står i parenteser, så er det opsjoner man kan velge å la ikke ta dem med, men opsjoner som ikke står i parenteser, Så vi ser her... For å få dette til å kjøre, må vi bruke den minus B. Og minus B1... Den gjør da en test hvor man skriver til ramm. Vi kan teste og lese etterpå. Så dette er da min Linus-desktop som står nede på Oslo Nett. Som jeg kjører denne testen i. Det er at vi...", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0011", "start": 1808.44, "end": 1993.72, "token_count": 585, "text": "Hvis opsjoner står i parenteser, så er det opsjoner man kan velge å la ikke ta dem med, men opsjoner som ikke står i parenteser, Så vi ser her... For å få dette til å kjøre, må vi bruke den minus B. Og minus B1... Den gjør da en test hvor man skriver til ramm. Vi kan teste og lese etterpå. Så dette er da min Linus-desktop som står nede på Oslo Nett. Som jeg kjører denne testen i. Det er at vi... Typisk det Ramspeed gjør, er å skrive til ram akkurat på samme måte som vi gjorde i det forrige programmet. Vi har et svært array, og så skriver vi bite for bite til det arrayet. Det er noe sånt som 8 gigabyte med ram som skrives. Størrelsen på blokkene som skrives. I førstelinja her så skriver man bare 1 kB av gangen. Altså man har en løkke som går gjennom... Da blir det 250 bite, sånn at det blir 1 kB totalt. Og så skrives det veldig hurtig til ramm. Og så måles hastigheten. Det går veldig fort. 26 000 MB per sekund. 27, eller 30 gigabyte i sekundet. Så... Det går unna. Hvis du skal streame noe, for eksempel, så kan du... Ja... Du kan streame kanskje 4 megabit per sekund, og det er bare bit. Dette er en bite, og så er det giga. Så det er 30 gigabyte per sekund. Veldig hurtig. Men litt av poenget her med denne testen er at vi ser at det går veldig hurtig til å begynne med. Men så begynner det å gå litt saktere. Her er det 29 000, så går den ned til 28 000, 27 000 her... 25 000. Og så dropper det enda mer. Og her nede så ser vi at vi er nede i en fjerdedel av denne opprinnelige hastigheten. Og dette er da pga. cash. Dette er cash-størrelsene. Fordi når vi skriver en liten blokk, så får den plass i LN-cash. Og hvis vi skriver en litt større blokk, så får den plass i L2-cash. Og så må vi kanskje ut i L3-cash her ute.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0012", "start": 1958.88, "end": 2143.72, "token_count": 594, "text": "Og så dropper det enda mer. Og her nede så ser vi at vi er nede i en fjerdedel av denne opprinnelige hastigheten. Og dette er da pga. cash. Dette er cash-størrelsene. Fordi når vi skriver en liten blokk, så får den plass i LN-cash. Og hvis vi skriver en litt større blokk, så får den plass i L2-cash. Og så må vi kanskje ut i L3-cash her ute. Men det vi trenger å vite da, er hvor stor er cash på denne maskinen her. Det jeg gjorde nå, var kommandoen LSCPU. Og den gir cash-størrelsene. Og da ser vi... LN-cash er 32K for data og instruksjoner. Det er data. I er instruksjoner. Og dette vil jo være typisk... Her skriver vi, så dette vil typisk være data. Så da har vi 32K i LN og 256K i L2. Så da kan vi prøve å se om det er noen forskjell på... Er det noen stor forskjell ved 32K og 256K? Det er ikke så veldig stor forskjell. Vi kan se at det begynner å droppe litt ved 32K, for da må den over på L2. Men det ser ut som... Når du skriver de store mengdene her, Det er veldig effektivt. Så vi kan kanskje se det faller litt her. Og så... Men så begynner det å bli større enn L2. Nå i dag faller det litt i hastighet. Men så ser vi her mellom 4 og 8. Der begynner det å bli en stor forskjell. Og det... Da ser vi... Da begynner vi å komme over 8K. Her har vi 8K-blokk. Da ser vi at hastigheten har blitt halvert. Og det er da fordi da får ikke de blokkene plass i... Ikke engang i L3. Så da må du begynne å lese direkte fra disken... Nei, direkte fra ram, og da begynner man å komme ned på det som du kan kalle den ekte rammehastigheten. Altså at du må helt ut i ram og hente dataene. Da faller hastigheten med i hvert fall en faktor på 4. Muligens enda mer hvis vi hadde skrevet enda større blokker. Så vi kan prøve å lese også.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0013", "start": 2104.12, "end": 2317.4, "token_count": 599, "text": "Ikke engang i L3. Så da må du begynne å lese direkte fra disken... Nei, direkte fra ram, og da begynner man å komme ned på det som du kan kalle den ekte rammehastigheten. Altså at du må helt ut i ram og hente dataene. Da faller hastigheten med i hvert fall en faktor på 4. Muligens enda mer hvis vi hadde skrevet enda større blokker. Så vi kan prøve å lese også. Minus B2. Da leser vi fra ram. Enda fortere. Men vi ser igjen så vi får 1 KB. Den er kanskje for liten igjen til at det skal gå fort nok. Når det kommer opp i 2, så ser vi det kommer opp i 60 GB per stykke. Men igjen så ser vi den samme effekten. Det faller litt... ... litt etter 32K, eller den cash-størrelsen. Veldig mye etter 8K. Her faller det fra 50 og ned til 20 omtrent. Så der er det en stor faktor. OK. Da... tenkte jeg vi kan se på noen flere... Minnekommandor. Kan gå til laptopen min, og så kan jeg prøve å se på \"-free\". Hvis jeg bare taster -free, så får jeg ut en del minneinfo. Stort sett så kan du se dette i toppen også, men her får vi konsentrert oss om minnet. Dette er i... Dette er i utgangspunktet K. Så jeg kan be om free minus M. Så kan jeg be om free minus G. For å se i gigabyte. Så vi kan kanskje først se på den siste her. Free minus G. Her får vi de store tollene. 31 betyr at det er... 31, eller det er vel rundt av. Denne laptopen har 32 gigabyte internt inne. Og det er det vi ser her totalt. Og så ser vi... Used er tre. Så hvis vi går opp her og ser på megabytes, så ser du at det er 32 000 megabytes og 3000 er used. 3500 er brukt. Så det bestyrer at du bruker ca. 3 GB. Så det betyr igjen at det er veldig mye som er ledig. Og... Men... Så ser vi... Ja, og skjer. Det er også da delt i libraries, som ikke er... Som er fordelt mellom flere prosesser. Men her er det en bit som er interessant. Bufcash.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0014", "start": 2277.12, "end": 2472.6, "token_count": 589, "text": "Så hvis vi går opp her og ser på megabytes, så ser du at det er 32 000 megabytes og 3000 er used. 3500 er brukt. Så det bestyrer at du bruker ca. 3 GB. Så det betyr igjen at det er veldig mye som er ledig. Og... Men... Så ser vi... Ja, og skjer. Det er også da delt i libraries, som ikke er... Som er fordelt mellom flere prosesser. Men her er det en bit som er interessant. Bufcash. Vi ser at det er 4G. Den kan ofte være enda større. Det har ikke noe med L1 og L2Cash å gjøre. Det er filcash. Så... så dette er filcash. Og det som skjer da, er når Linux ser at her er det masse minne, mange gigabyte med minne, som er ledig. Som ikke brukes av noen prosesser. Da tar Linux operativstemkjernen og cacher filer. Fra filsystemet. Så når man da leser inn filer, så lagres det i RAM i et område som er da satt av av operativsystemet. Sånn at etterpå, når man leser fra en fil... Så i stedet for å bruke veldig lang tid på å lese på disken, så leser man direkte fra RAM. Da går det 100 000 ganger så fort. Så dette er en veldig effektiv måte å bruke RAM på for å få systemer til å gå fortere. Men så kan det være at man smører opp et svært RA som trenger masse ram. Da vil man se at Bufcash-andelen vil gå ned. Hvis programmet bruker opp alt ram, så droppes Fillcash. Vi kan... Vi har sett mange ganger på topp.  Vi ser her, så... rapporterer TopIG. Og den størrelsen man rapporterer på, den kan endres ved å taste... Ved å taste E. Skal vi se om jeg får til det. Jo, der. Nå var det... Nå er det oppe i terabyte. Petabyte. Det er litt stort. Men... Hvis jeg taster E én gang, så blir det... Nå ser vi det står M, bortsett fra de som er veldig store. Nå så ser vi det står G. Og da ser vi... Det er et par programmer her som er... Kjempestore. OBS. Det er det systemet som... sørger for alle vinduene og streamer og tar opp osv. Den har...", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0015", "start": 2427.32, "end": 2644.28, "token_count": 597, "text": "Ved å taste E. Skal vi se om jeg får til det. Jo, der. Nå var det... Nå er det oppe i terabyte. Petabyte. Det er litt stort. Men... Hvis jeg taster E én gang, så blir det... Nå ser vi det står M, bortsett fra de som er veldig store. Nå så ser vi det står G. Og da ser vi... Det er et par programmer her som er... Kjempestore. OBS. Det er det systemet som... sørger for alle vinduene og streamer og tar opp osv. Den har... Virt på 47 G. Så da ville det vært et problem hvis alle de sidene skulle inn samtidig. Tilsvarende Zoom, som jeg også kjører, den har 6 G. Men heldigvis så brukes ikke alle de sidene her samtidig. Det er liksom alt som er mulig å gjøre i det programmet, OBS, det er definert i de sidene. Men det er ikke i bruk. Vi ser bare 0,6 G er i bruk nå. Og tilsvarende for Zoom - 1,2 G er i bruk. Så det er de som bruker det meste av ram. Så hvis jeg taler stor E, så ser vi at jeg får samme effekten her oppe. Nå står det GIB. Og da får jeg ut noe av det samme som jeg fikk med fri. Det står 31 GIB her. Og \".used\": 3,4. Og 4 giga er brukt av feel cash, eller buffer cash. Så på denne måten kan man kontrollere og se hva som er i bruk av minne. Og så er det viktig å huske at det feltet her, det som er resident, det som faktisk er i ramm, og som MMU har definert alle sider for... Som er den viktigste delen. Men da ser jeg... Klokka er 9.17, så vi trenger en pause. Jeg ser det er noen spørsmål i chatten. Ja, vi kan godt ta de før vi går til pause. Et spørsmål til når vi kjørte... Ops... her... når vi kjørte dette programmet... Hvordan hvitt kan være 4516 før man har sagt hva størrelsen per eske er? Det er et godt spørsmål. Men vi kan da se på... Bare selve programmet. Og vi ser... Det er i utgangspunktet ganske stort. Så hvis jeg... Skal vi se... Her har jeg ikke noe. Nei.", "source": "lecture"}
{"lecture_id": "os14time1", "chunk_id": "os14time1_0016", "start": 2580.2, "end": 2802.2, "token_count": 551, "text": "Ja, vi kan godt ta de før vi går til pause. Et spørsmål til når vi kjørte... Ops... her... når vi kjørte dette programmet... Hvordan hvitt kan være 4516 før man har sagt hva størrelsen per eske er? Det er et godt spørsmål. Men vi kan da se på... Bare selve programmet. Og vi ser... Det er i utgangspunktet ganske stort. Så hvis jeg... Skal vi se... Her har jeg ikke noe. Nei. Her er det helt tomt. Så hvis jeg nå kjører programmet før jeg begynner å... Så spørsmålet er hvordan kan det være 4500 K før vi i det hele tatt begynner å kjøre? Og da kan vi jo først se på det jeg prøvde å gjøre. Vi ser på størrelsen på A.out. Og vi ser... Størrelsen på A.out er i utgangspunktet 8,3 K. Sånn at... Sånn at det begynner å kjøre, så er det ikke så rart at... ... at det virtuelle adresserommet er 4516. Skulle nesten tro det var større, siden det er 8K her oppe. For her har jeg jo ikke begynt å definere noe ennå. Men i hvert fall... Uten at jeg kan si detalj om hver eneste bite der, så er hovedpoenget at Adopt-Out er et stort program. Det linker sammen en masse biblioteker osv., bl.a. for å kunne skrive ut. Og selv om man selv bare... Hello world ic... tar mange kilobite med plass. Så alt dette er all infrastrukturen som skal til for å sette opp et program i det hele tatt. Den biten vil også ta mye ram, og det er utgangspunktet. Men så ser vi etterpå. Det vi gjorde, var når vi legger på 4K. Så ser vi i et RA, så blir den biten bare skjøtet direkte på det eksisterende. OK. Da tar vi en pause. Og da tenker jeg vi kan starte igjen... 9.21. Vi kan starte da blir det 9.36. Da tar vi et kvarters pause der. Kom gjerne med spørsmål i chatten i pausen også. Da stopper jeg recordingen.", "source": "lecture"}
