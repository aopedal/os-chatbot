{"lecture_id": "os10del3", "chunk_id": "os10del3_0000", "start": 0.0, "end": 207.28, "token_count": 589, "text": "Og så skal vi se på dette i praksis. Da skal jeg gjøre en demo hvor jeg kjører på de følgende fem plattformer her. For det første så har jeg laptopen min, som er en Linux ubundet til 1804. Den har en Intel Zeon-prosessor, som er den vi har kjørt eksempler på i hele vår. Det er viktig å ha klart for seg. Intel og IMD, de CPU-ene, begge de har X86-institusjoner. Så har jeg noen forskjellige Java-versjoner. Java 11 og Python 36 på denne. Det er et viktig poeng etter hvert, når vi kjører på andre Java-versjoner, at Java er til dels avhengig av versjoner. Spesielt så er det noen ganger gamle Java-programmer ikke virker på... Eller... Eldre Java-programmer virker på nyere, men hvis man kompilerer på en nyere Java-versjon, så virker de ikke alltid på de gamle. Men det skal vi se på. Så neste plattform jeg har, er en gammel Mac, en gammel Macbook Pro. Den kjører Mac Macclus T med Darwin-kjerne. Det er en Unix av art, men det er en variant av Unix. Derfra har man typisk et bachel i pointback. Men det er samtidig en del forskjeller. Men CPU-en er en Intel core-duo som også kjører X86-institusjoner. Python er forskjell på Python 3 og Python 2. Men jeg skal se at Python er i større grad uavhengig av versjoner. Og så har jeg en Del-server med en AMD CPU. Det er en svær server med 48 CPU-er. Altså kjøre på X86. I tillegg er jeg valgt av Python 2.7. Så kom vi nå som er faktisk en nyhet av året. Selv om den ikke er helt nytt. Og det er... Dette er en Linux ubundet til 2004, men den kjører på en Arm CPU. Vanligvis brukes Arm i mobiler, og derfor er de konstruert sånn at de bruker mindre strøm og er ganske sånn lettvekt når det gjelder drift. Men tradisjonelt så har man alltid kjørt Exo-86... Ikke alltid. De siste 10-15 årene så har Exo-86 vært dominerende i serverrommet, men nå har det også begynt å komme arm-baserte servere.", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0001", "start": 168.56, "end": 382.84, "token_count": 595, "text": "Dette er en Linux ubundet til 2004, men den kjører på en Arm CPU. Vanligvis brukes Arm i mobiler, og derfor er de konstruert sånn at de bruker mindre strøm og er ganske sånn lettvekt når det gjelder drift. Men tradisjonelt så har man alltid kjørt Exo-86... Ikke alltid. De siste 10-15 årene så har Exo-86 vært dominerende i serverrommet, men nå har det også begynt å komme arm-baserte servere. Så dette er en sånn arm-basert server. Jeg kjører i Amazon Elastic Cloud, så dette er en cloudserver som jeg har kjøpt en VM på. Så dette er da VM-er som man betaler per måned. Koster ikke veldig mye for én. Kjøper du en stor en, så koster det en del. Den siste plattformen er en Windows Server 2019, som er også SE2. Også Amazon Cloud. Men den kjører på en Intel Seon Sippu. Altså den samme Sippuen som her oppe. Ikke helt samme, men samme Sippu-familie. Og igjen X86, Java 8 og Python 39. Så dette er de forskjellige plattformene. Og så skal jeg nå prøve å gå inn på de... Hvis jeg kompilerer alt på denne... Hello.c, hello.java, hello.python og hello.bash. Så kopierer jeg de til alle fire plattformene. Og så skal vi se hva som fungerer hvor. Jeg håper du etter pause har fått til en liten poll på dette her. Så det er viktig å følge godt med hva som skjer. Men da skal vi gå over og se på... Ja... Håper dere er i stand til å se dette. Her er jeg nå i en mappe som heter Hello. Og i denne mappen så har jeg... For det første så har jeg de fire programmene. Skal ta de først. Hello.c. Det er da et C-program. Hello.java. Det er et Java Hello World. Og så har jeg hello.python. Og til slutt hello.person. Så tanken er nå å kopiere disse over til de andre plattformene. Et skjedskrift som heter dysts.shell. Og det det gjør, er å kopiere hele denne mappen som jeg nå står i, den hello, til de andre plattformene. Dette er AMD-serveren. Dette er MacWiston.", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0002", "start": 330.0, "end": 565.88, "token_count": 591, "text": "Hello.c. Det er da et C-program. Hello.java. Det er et Java Hello World. Og så har jeg hello.python. Og til slutt hello.person. Så tanken er nå å kopiere disse over til de andre plattformene. Et skjedskrift som heter dysts.shell. Og det det gjør, er å kopiere hele denne mappen som jeg nå står i, den hello, til de andre plattformene. Dette er AMD-serveren. Dette er MacWiston. Dette er Arm-serveren. Og dette er Windows-serveren. Og Amazon Cloud. Men før jeg gjør det, så er da hele ideen at jeg skal kompilere... Kompilere og kjøre programmene her. Og da har jeg et lite skript som heter Compile. Jeg vil bare se programmet og Java-programmet som må kopieres først. GCCHL.c har vi sett mange ganger. Og så JavaCHL.java. Javafiler på Linux. Og når man gjør det, så lages det en hello.class. Så det er den vi da sender over. Så hvis jeg kjører compile, så komplerer jeg altså hello.c. Så jeg får en ny versjon av det. Og tanken nå er at nå skal jeg kopiere alle disse over til de andre plattformene. Der har jeg satt opp SSO-nøkler, sånn at vi ser at de kopierer over til alle plattformene. Og så på Windows har jeg satt opp SSO-nøkler. Det går an å gå inn på Windows med SSO også. Vi skal se på det senere. Og det er litt mer knot å sette opp SOS-nøkler på Windows, men det er mulig å få til. Og så kan vi gå rundt på de andre plattformene og se hvordan det ser ut å kjøre de fire programmene. Da hopper vi først ned hit til AMD-serveren. Kjøre Linux bunt til 1604 på en AMD Oppdron. Ops... Skal vi prøve å få det vinduet? Å, nei. Ikke gjøre noe helt galt, det. Oi. Jeg får klare meg med det lille vinduet. Jeg trodde jeg skulle ha fått det litt større, men der, kanskje. Jeg kan ta det én av gangen. Jeg kan først starte med Adopt. Nå har jeg kompilert her oppe... På Linux med Intel har jeg kompilert Adopt. Så kopierer jeg over hit, og så kjører jeg det her på AMD-serveren.", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0003", "start": 517.6, "end": 716.68, "token_count": 586, "text": "Ops... Skal vi prøve å få det vinduet? Å, nei. Ikke gjøre noe helt galt, det. Oi. Jeg får klare meg med det lille vinduet. Jeg trodde jeg skulle ha fått det litt større, men der, kanskje. Jeg kan ta det én av gangen. Jeg kan først starte med Adopt. Nå har jeg kompilert her oppe... På Linux med Intel har jeg kompilert Adopt. Så kopierer jeg over hit, og så kjører jeg det her på AMD-serveren. Ja... Dette var ikke så rart. For her kjører jeg oddotout. Men jeg har ikke gått inn i mappen, så jeg må inn i hello. Så dette beviser ikke så veldig mye. Men nå er jeg inne i mappen. Og du kan se jeg har alle de samme... Alt er kopiert over hit. Så nå kan jeg prøve å kjøre oddotout. Og da så vi faktisk... Det fungerer. Det betyr ikke at C er plattform uavhengig, for hele poenget er at dette er samme plattform. Det er Linux på Exo-86. Så selv om det er en annen ubundet versjon og det er en annen prosessor, AMD, i stedet for Intel, så har begge Exo-86 institusjoner, og da fungerer det å bare kopiere over all date out på den måten. Ja, jeg kan kjøre eksplisitt, så vi kan ta Java hello også. Når jeg kjører Java hello, så ser vi at jeg får noen feilmeldinger. Og det... Man skulle tro dette fungerte, men det er en sånn... Hvis man leser feilmelding i øyet, så er det en sånn versjons... Problemet her er at jeg har kompilert Hello.ThatWorld med Java11. Og så prøver jeg å kjøre det på Java8. Og det er ikke backover-compatible, så da fungerer ikke det. Så sånn sett kan man si at Java ikke er fullstendig plattformuavhengig. Litt plattformavhengighet ser vi at det er. Men jeg kan kjøres og teste Python. Det fungerer fint. Og... og bæsj fungerer også fint. Det er ikke så overraskende. Så oppsummert, hvis jeg kjører, Python og bæsj og Adopt-out fungerer, men ikke Ikiyawa.", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0004", "start": 670.12, "end": 899.6, "token_count": 596, "text": "Og det er ikke backover-compatible, så da fungerer ikke det. Så sånn sett kan man si at Java ikke er fullstendig plattformuavhengig. Litt plattformavhengighet ser vi at det er. Men jeg kan kjøres og teste Python. Det fungerer fint. Og... og bæsj fungerer også fint. Det er ikke så overraskende. Så oppsummert, hvis jeg kjører, Python og bæsj og Adopt-out fungerer, men ikke Ikiyawa. Til MacOS. Så kan jeg prøve å huske å gå inn her. Nå er jeg inne i riktig mappe i MacOS. Jeg har kopiert over alle de samme filene. Så kan jeg prøve å kjøre Adataut her. Og det går dårlig. Jeg får Cannot Execute Binot. Og det er ikke så rart når man tenker seg om, fordi selv om dette er en Intel-CPU med X86-institusjoner, så er det et annet operativstem. Det er MacOST. Og A.out prøver å snakke med Linux-stjernen. Og dermed så går dette dårlig. Med Java så har vi samme problemet. Dette er Java 6, en eldre Java-versjon, så den kjenner ikke igjen den nyere Java 11-klasse-filmen. Python derimot... Den går fint. Men hva så med bæsj? Ikke så helt opplagt. Det er bare en standard kommandolinje. Jo, Macbook har bæsj installert, Ok. Da skal vi over på ARM. Etter pausen kan vi se litt mer på det. Men poenget er at de underleggende maskininstruksjonene her, CPU-ene som vi kjører på, den er helt forskjellig. Har et helt annet instruksjonssett. Hvis jeg prøver å kjøre adatatet, så ser vi at jeg får en... ... exec format error. Til tross for at det er akkurat samme operatise, Linux i bunter, mer eller mindre samme kjerne, men i motsetning til her nede på AMD server, så kjører ikke adatatet. Det er rett og slett fordi her er det arm-instruksjoner. Det er helt binary. Jeg har et eksempel på hvordan disse gjør ut... I mappen over her. En sum.s som er kompilert her. Og her er en instruksjon... Den er ikke så veldig forskjellig, men...", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0005", "start": 846.08, "end": 1090.0, "token_count": 595, "text": "... exec format error. Til tross for at det er akkurat samme operatise, Linux i bunter, mer eller mindre samme kjerne, men i motsetning til her nede på AMD server, så kjører ikke adatatet. Det er rett og slett fordi her er det arm-instruksjoner. Det er helt binary. Jeg har et eksempel på hvordan disse gjør ut... I mappen over her. En sum.s som er kompilert her. Og her er en instruksjon... Den er ikke så veldig forskjellig, men... Dette er bare én institusjon, men vi har andre navn på registeret. Og det er andre institusjoner. Dermed er det umulig å ta en av-og-tat-fill, eller hvilke som helst andre programmer som er komplimert med CSI. Det kan man ikke bare kopiere over og kjøre på en maskin som har en armplattform. Og Java funker fint her. Og det er fordi at her er det Java 14. Så den er såpass ny at den... Den er faktisk nyere enn Java 11. Så den tolker fint. Hetten kjører også fint. Og det er jo ubuntu, så... Og bæsjkrittet kjører også fint. Så til slutt så skal vi over på vindos. Og her har vi også kopiert over alle fillene. Dere har kanskje merket at jeg har kjørt LS, og det er fordi dette er vindos påforskjell. Her finnes det alias for veldig mange Linux-kommandoer. Sånn at man kan bruke Linux-kommandoer når man jobber med PowerShed. Så her har vi sammen med HelloOz og andre. Alt er kopiert over, men da kan jeg prøve å kjøre adopt-out. Det er ikke prikk-bakslasj, er det selvfølgelig prikk-slasj. Jeg får ingenting, men jeg får i hvert fall ikke ut Hello World. Jeg kunne prøvd å gjøre noe sånt som å kalle ad.exe. For Windows er veldig sånn institusjonsnett... Nei, avhengig av extension på fillene. Men... Det eneste jeg får beskjed om, er at ad.exe gikk feil. Man kan ikke kjøre den... Man klarer ikke å kjøre den filen. Det er da fordi AdoDot snakker med Linux-operativsystemet. Så da er det ikke så rart at den ikke kjører. At dette ikke fungerer?", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0006", "start": 1028.24, "end": 1270.2, "token_count": 598, "text": "Jeg kunne prøvd å gjøre noe sånt som å kalle ad.exe. For Windows er veldig sånn institusjonsnett... Nei, avhengig av extension på fillene. Men... Det eneste jeg får beskjed om, er at ad.exe gikk feil. Man kan ikke kjøre den... Man klarer ikke å kjøre den filen. Det er da fordi AdoDot snakker med Linux-operativsystemet. Så da er det ikke så rart at den ikke kjører. At dette ikke fungerer? Og det er til tross for at det er akkurat samme CPU. Det er en Intel CON CPU, akkurat som vi har komplert for her. Så maskininstitusjonene er i grunnen riktige, men her er problemet igjen at... Så treffer den Windows-server, og da fungerer ingenting. Så dermed vil det ikke fungere. Java, derimot, kunne man i prinsippet tenke fungerte. Men igjen så er det rundtime-problemet. Når du går fra versjon 11 ned til versjon 8, så fungerer det ikke. Den fungerer fint. Den kjører på... ja, det er Pyton 3936, så det er ikke så rart at den kjører, men den oppfører seg fint. Så helt til slutt... Hva med LOD-bæsj? Det skjer ikke noe der, men hvis jeg eksplisitt kjører sånn som før... LOD-bæsj, så ser vi at det faktisk fungerer. Men det er fordi her har jeg isolert bæsj. Dvs. jeg har isolert den Linux-modulen sånn at jeg har... Så at jeg har et bæsjer, så jeg kan starte bæsjeret og kjøre Linux-kommandoer som LS-l. Om jeg prøver å kjøre A.alt her... Inne i Linux-submodulen. Jo. Det fungerer faktisk. Her er det på en måte native Linux som kjører direkte på X86. For når jeg starter perset her inne, så får jeg opp et ekte... Det er faktisk en Linux-kjerne som kjører... Det er vel en... Jeg er ikke sikker på detaljene, om det er en virtuell maskin, men det er iallfall en ekte Linux-kjerne som kjører, sånn at man kan kjøre native Linux-programmer på denne vindussurferen. Håper ingen har savnet her. Spørsmål i slutten. Ja. Spørsmål i slutten.", "source": "lecture"}
{"lecture_id": "os10del3", "chunk_id": "os10del3_0007", "start": 1222.92, "end": 1392.0, "token_count": 434, "text": "For når jeg starter perset her inne, så får jeg opp et ekte... Det er faktisk en Linux-kjerne som kjører... Det er vel en... Jeg er ikke sikker på detaljene, om det er en virtuell maskin, men det er iallfall en ekte Linux-kjerne som kjører, sånn at man kan kjøre native Linux-programmer på denne vindussurferen. Håper ingen har savnet her. Spørsmål i slutten. Ja. Spørsmål i slutten. Flott. Hvorfor funket bæsj på den ene Linux-en og ikke den andre Linux-serveren? Skal vi se... Den fungerte vel på begge Linux-serverne. Jo, hvis vi oppsummerer, så... Den fungerte her. Og... og her. Og også på Mac fungerte den. Ja, her kjørte jeg òg. Så... Ine, forstod du spørsmålet? Nei... Jeg trodde jeg skulle si fra. Flott. Nei, det var denne her... Det var bare at jeg skrev feil. Så det var ikke Linux sin feil. Det var min feil som skrev noe feil. Kjørte Adoptat på Linux-serveren mellom det? Nå skal vi se. Ja, faktisk. Og det var jeg litt... Det er ikke helt opplagt. Men her har vi bare tatt en adotat, så kopiert rett over fra Linux-sipput på Intel, komplert for Intel-sippu, og så kopiert over hit. Og det er da fordi alt er likt. Det er samme operativstemme, og så er instruksjonssettet det samme. Så om du komplerer... Her kopiert tilbake så får du også den samme effekten. Ja, det er riktig konkludert. Begge er X86-prosesser.", "source": "lecture"}
