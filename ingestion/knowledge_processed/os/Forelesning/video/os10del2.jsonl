{"lecture_id": "os10del2", "chunk_id": "os10del2_0000", "start": 0.0, "end": 187.2, "token_count": 592, "text": "I dag så skal vi... I første omgang så tenkte jeg bare å vise hvordan det ser ut når man mer teoretisk kjører JavaC og Bæsj-programmer under forskjellige OS. Og de eksemplene jeg har i utgangspunktet, er da Linux på vanlig PC, eller en laptop som kjører X86-institusjoner. Den kjører... Det er kanskje ikke en Pentium jeg kjører, det er vel en Seon som jeg har på laptopen nå. Men uansett, den kjører og forstår Exo 86-instruksjoner. Akkurat som det vi har sett på hele tiden. I dag skal vi se på noen andre instruksjonssett. Men i tillegg så har jeg en vindusmaskin som kjører på i dette tenkte eksperimentet. Der kjører den på akkurat den samme Intel-PC-en. Det er bare sånn dual-boot, så en booter opp på den helt samme Intel-PC-en, og har de samme X86-instruksjonene sånn underliggende. Men det tredje eksempelet er operativsystemet Solaris. Og det er et Sun operativsystem. Et Unix-firma som da, som typisk Unix-firmaer flest på 90-tallet og 2000-tallet... De bygde sin egen hardware og hadde sitt eget operativsystem som de kjørte alle institusjonene på. Og da kjørte Sunt på en Spark-prosessor, og den maskinen hadde da bare... Som var helt forskjellige fra X86-maskininstruksjoner. Like forskjellige som X86 er fra de maskininstruksjonene som vi hadde i det simulerte ZPU-en. Etterpå, når vi skal kjøre en demo av plattformen Uavhengighet, så skal vi da se på et tredje instruksjonssett, nemlig ARM-instruksjonssettet. Det er det som kjører på alle mobiltelefoner. Men det kan også brukes på servere. Vi skal kjøre på noen servere og sammenligne med hvordan det ser ut i forhold til Intel. Men det viktigste å ha med her i denne sammenhengen er at dette er institusjoner som er helt forskjellige fra X86-institusjoner, som er det vi er vant til. Stort sett overalt. Hvis du logger inn på laptoper eller servere, Men det kan da være forskjellig operativstemme på toppen av det.", "source": "lecture"}
{"lecture_id": "os10del2", "chunk_id": "os10del2_0001", "start": 155.3, "end": 370.64, "token_count": 598, "text": "Men det kan også brukes på servere. Vi skal kjøre på noen servere og sammenligne med hvordan det ser ut i forhold til Intel. Men det viktigste å ha med her i denne sammenhengen er at dette er institusjoner som er helt forskjellige fra X86-institusjoner, som er det vi er vant til. Stort sett overalt. Hvis du logger inn på laptoper eller servere, Men det kan da være forskjellig operativstemme på toppen av det. Og den sammenkoblingen, det kaller vi en plattform. Så... Dette er det samme eksemplet som vi skal bruke senere. Hello.java. Det er bare et javaprogram som skriver ut Hello World. Og som vi også skal se når vi kompilerer det på Linux. Så kompilerer vi sånn. Java.chello.java. Og da lages en Java classfile. Og den inneholder da Java bite-kode. Og det er kode som er for en JVM eller en Java-virtuell maskin. Så vi kan se på bildet her nede. Det ser ut som noe sånt som dette her. Og så får vi en hello.class-fil. Og da er det helt essensielt at dette er helt forskjellig fra A.out, som vi har sett på tidligere, som inneholder maskinkode. Som er da instruksjoner for X86. X86-instruksjoner. A.out kjører på en måte direkte på X86. Men Hello.class, det kjører inne i... I en JVM, en Java virtuell maskin. Og da er hele poenget som gjør Java plattform uavhengig, at på Linux er det en egen Linux-JVM. På Windows er det en annen Windows-JVM, og på Solaris er det en Solaris-JVM. Så på den måten så kan hello.class kjøres på alle disse plattformene. Og man kan til og med ta hello.class herfra, kopiere opp en Windows-maskin, Og så kan den kopiere Overs på en sparkmaskin. Og så kjører den likevel fordi den har en JVM som tolker instruksjonene. Det blir litt overhead. Ting går litt saktere. Men Java er veldig god på overhead, altså den... Opp gjennom årene så har Java klart å optimalisere veldig, sånn at det faktisk går nesten like bra. Men igjen, det vesentlige her er hello the class. Det er en helt egen... Man kan si at det er et maskinspråk, dette også,", "source": "lecture"}
{"lecture_id": "os10del2", "chunk_id": "os10del2_0002", "start": 300.0, "end": 528.12, "token_count": 597, "text": "Og så kan den kopiere Overs på en sparkmaskin. Og så kjører den likevel fordi den har en JVM som tolker instruksjonene. Det blir litt overhead. Ting går litt saktere. Men Java er veldig god på overhead, altså den... Opp gjennom årene så har Java klart å optimalisere veldig, sånn at det faktisk går nesten like bra. Men igjen, det vesentlige her er hello the class. Det er en helt egen... Man kan si at det er et maskinspråk, dette også, men det er for en virtuell maskin. Så vi skal se på det i detalj senere, hvordan instruksjonene i bite-koden til Java ser ut. Og det er faktisk mulig å lage hardware-Java-virtuell maskin. Det har blitt laget reell hardware som kjører Class-kode direkte. Og med prinsippet er det samme. Og dette med virtuelle maskiner, det gjelder også sånn som Python og Csharp og Pearl. Veldig mange av de nye språkene, de kjører på virtuell maskin på denne måten. En tradisjonell, sånn som C og C pluss pluss, kompileres det, så kjører man direkte på hardway. Så plattformuavhengighet, det er at man kan ta hello.class-filer og kopiere over til andre plattformer og kjøre dem der som om ingenting skulle ha skjedd. Så kom vi til hello.c. Og dette er da... Et program som er i høyeste grad plattform avhengig av. For når vi komplerer Hello.dat.se, sånn som vi har gjort mange ganger, så ser vi at så får vi en adopt-out, og den vil inneholde X86-instruksjoner, sånn som denne her. Move X til EBX. Og det er klart... De instruksjonene forstås bare av en X86-CPU. Altså en CPU som har innebygd, brent inn X86-instruksjoner fra bunnen av. Den kan ikke få se spark-instruksjoner, f.eks. Så her, med object dump fra en adopt-out, så kan du se hvilke instruksjoner som adopt-out inneholder. Det object dump gjør her, er på en måte mot... I tillegg har vi sett på en assembly hvor vi går fra assembly-kode til maskinkode. Men denne her på en måte viser hva maskinkoden inneholder. Og hvis vi gjør dette her på Solaris...", "source": "lecture"}
{"lecture_id": "os10del2", "chunk_id": "os10del2_0003", "start": 480.0, "end": 653.74, "token_count": 594, "text": "Altså en CPU som har innebygd, brent inn X86-instruksjoner fra bunnen av. Den kan ikke få se spark-instruksjoner, f.eks. Så her, med object dump fra en adopt-out, så kan du se hvilke instruksjoner som adopt-out inneholder. Det object dump gjør her, er på en måte mot... I tillegg har vi sett på en assembly hvor vi går fra assembly-kode til maskinkode. Men denne her på en måte viser hva maskinkoden inneholder. Og hvis vi gjør dette her på Solaris... Dette er et eksperiment hvor vi har gjort det på Solaris. Så vil vi rett og slett se at her er det andre institusjoner. De har faktisk ad og sub. Ad har tre argumenter. Her oppe er det to. Så fins det en del andre... Det fins noen andre instruksjoner også, sånn som TST og Load. Så dette er helt fundamentalt forskjellige maskininstruksjoner. Og når vi da skal prøve å flytte rundt på a.not.out, så fungerer det... Dårlig. Så hvis jeg tar AdoptOut, som er komplert for en Linux-maskin, og flytter over på Windows og prøver å kjøre det, så enten så skjer det ingenting, eller så får man en feilmelding om wrong binary eller et eller annet sånt. Men det fungerer ikke. Og det til tross for at X86-institusjonene i bunnen er akkurat de samme. Så her er det Move A, XB, X osv. X86-institusjoner. Men et program må også snakke med operativsystemet. Hvis du flytter over adopt-out hit, så kommer du inn på Windows, og så begynner du å snakke med Linux-biblioteket for å printe ut noe. Da er det klart at det fungerer dårlig. Da vil programmet ikke virke. Hvis vi tar adopt-out og så flytter over hit på Solaris, så vil det dobbelt ikke fungere. Å snakke med Linux-operativsystemet. Det går veldig dårlig. I tillegg så prøver du å utføre X86-institusjoner på en helt annen arkitektur. Så det er dømt til å mislykkes å prøve å kjøre ADAT-out på en plattform som både har et annet operativsystem og et annet instruksjonssett.", "source": "lecture"}
{"lecture_id": "os10del2", "chunk_id": "os10del2_0004", "start": 620.48, "end": 801.9, "token_count": 590, "text": "Hvis vi tar adopt-out og så flytter over hit på Solaris, så vil det dobbelt ikke fungere. Å snakke med Linux-operativsystemet. Det går veldig dårlig. I tillegg så prøver du å utføre X86-institusjoner på en helt annen arkitektur. Så det er dømt til å mislykkes å prøve å kjøre ADAT-out på en plattform som både har et annet operativsystem og et annet instruksjonssett. Men det vi så over, var at man kan oppnå plattform-uavhengighet ved å bruke... Virtuelle maskiner som da tolker koden her. Men det har også en pris, at ting går litt saktere. Men veldig mange programmeringsspråk har valgt det. Men hvordan kan man da kjøre et C-program på Windows eller Solaris? Jo, det som da er clouet, er at da må du gjøre ett step til. Du må kompilere. Du må ha en kompilator for den plattformen. Og da kan vi kompilere Og få en A.xe, og så kan den kjøre på Windows. Eller en S.out, som man fikk til folk med GCC på Spark. På Solaris. Og da kan man kjøre C-programmet på denne plattformen. Men da er hele forskjellen at du må kompilere og laste inn maskinkoden, og så kan du kjøre den. Og dermed er det da... Og dermed sier vi da at C-kode er ikke plattformavhengig. Nei, hva sa jeg nå? C-kode ER plattformavhengig. Viktig forskjell. Ikke der. Ja... Solais og Spark, den maskinen her finnes ikke lenger. Det kjører sikkert en del sånne rundt omkring, akkurat som det fortsatt kjører IBM-stormaskiner, men de blir færre og færre. Det meste nå går på Exo26, men som vi skal se, det fins også servere som kjører på Arm. Til slutt i denne oversikten så tar vi altså med HelloDotBæsj. Et bæsjprogram på de forskjellige plattformene her. Det går... Det går fint på Linux og Spark, som... Men da igjen, da må du installere bæsj, og så kjøre det. Det ligner jo litt på en virtuell maskin, det også, for da må du tolke det.", "source": "lecture"}
{"lecture_id": "os10del2", "chunk_id": "os10del2_0005", "start": 759.2, "end": 832.0, "token_count": 221, "text": "Det meste nå går på Exo26, men som vi skal se, det fins også servere som kjører på Arm. Til slutt i denne oversikten så tar vi altså med HelloDotBæsj. Et bæsjprogram på de forskjellige plattformene her. Det går... Det går fint på Linux og Spark, som... Men da igjen, da må du installere bæsj, og så kjøre det. Det ligner jo litt på en virtuell maskin, det også, for da må du tolke det. På Window går det ikke i utgangspunktet, men hvis du f.eks. installerer... Du kan installere Linux på Windows. Og da kjører Linux rett på X86. Og i tillegg så kan du da installere et bæsjel. Det kan du på andre måter òg. Så det er mulig å installere Vers på Windows. Sånn at du kan kjøre skript der.", "source": "lecture"}
