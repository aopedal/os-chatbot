{"lecture_id": "os5del3", "chunk_id": "os5del3_0000", "start": 0.0, "end": 215.12, "token_count": 586, "text": "Maskinkode. Så... Og det aller første jeg tenkte å se på, var optimalisering av maskinkode. Og da skal jeg gå til et eksempel på det. Skal vi se... Her har jeg laget en liten... Her har jeg laget en liten rutine. Denne som... Ja, det er ikke så viktig hva eksempelet er, men dette er da eksempel på kode som... Som går i en loop, og som logisk bygger på hverandre. Så den... Vi skal se senere. Denne koden kan ikke utføres i parallell. Men det viktigste nå er å se på hvordan kode utføres effektivt i en CPU. Det vi skal ha fokus på, er at vi har sett... I simuleringen forrige gang så vi at noen instruksjoner utføres bare på registrene. Og da står man inne i CPU-en, hvor man har registeret tilgjengelig. R0 ellik R0 pluss R1, som vi gjorde i simuleringen. Det er en operasjon som utføres kun på registeret. Men så så vi at vi også kan legge verdier ut i ramm. Og det er det man typisk gjør når man har en variabel, sånn som int A lik 1. Når vi kjører programmer som dette, så er det typiske som skjer da... En variabel har en egenplass i ram. En integer er på fire bite, så da settes det av fire bite i ram til integeren. Eller, fire bite er 32 bit, så det settes av i ram. Ram deler seg inn i bites, åtte bit av gangen, så det er den minste enheten i ram. Men da tar det mye lengre tid å lagre ting i ram. Så ca. ti ganger så lang tid tar det å lagre et tall i ram enn å lagre det i registeret. Så derfor lønner det seg stort sett å gjøre så mye som mulig med registeret, og så laste ut resultatene etterpå til ram. Så det vi skal se på nå, er hvordan... En kompilator lager maskinkode av denne koden her. Og da kan vi aller først så kan vi se på hvordan... Hvordan denne koden kjøres. Så... Da har jeg en... En kode som heter main sånn, som jeg skal kompilere. Og linke sammen med den fibokoden. Så her ser vi at vi definerer en ekstern int-fibo.", "source": "lecture"}
{"lecture_id": "os5del3", "chunk_id": "os5del3_0001", "start": 167.84, "end": 385.36, "token_count": 599, "text": "og så laste ut resultatene etterpå til ram. Så det vi skal se på nå, er hvordan... En kompilator lager maskinkode av denne koden her. Og da kan vi aller først så kan vi se på hvordan... Hvordan denne koden kjøres. Så... Da har jeg en... En kode som heter main sånn, som jeg skal kompilere. Og linke sammen med den fibokoden. Så her ser vi at vi definerer en ekstern int-fibo. Det er den assembly-metoden som... som jeg skal bruke. Eller nei - ikke assembly-metode. Dette er den C-metoden som jeg skal bruke. C-funksjonen som vi så på. Nemlig fibo.c. Vi ser den må hete det samme. Det som er litt forskjellig fra forrige gang, er at nå sender vi med en parameter til Fibo. Så vi kaller den Fibo med Last. Så ser vi i Main her, så setter jeg inn Last Alec 10. Og så kjører jeg metoden Fibo på Last. Så Fibo er 10. Den skal gi da Fibonacci-tall nummer 10 i rekken. Vi kan først se hvordan det ser ut når jeg kompilerer de to og kjører. De kan jeg kompilere rett sammen på samme linje. Sånn. Da får jeg ett program adatat. En kjørbar fil. Og så ser vi... Her kommer resultatet 55 ut. Så den funker som den skal. Men det vi skal se på nå, er... Hvordan ser egentlig den maskinkoden ut som det kompileres til, når man kompilerer den høynivåkoden Fibo? Og da kan vi som sist spørre... ... GCC, hvordan ser assembly-koden du lager, ut? Og det gjør man med minus S. Når jeg kjører den, så... Skal vi se... Er det stor S, kanskje? Ja. Man gjør det ikke med minst liten S, men med stor S. Med stor S så ber jeg GCC om å lage assemblerkode. Og da ser vi. Da har jeg fått en fil her som heter fibo.s. Det er den vi skal se på nå. Oi. Og den ser vi, den er ganske stor. Det ser jo litt gresk ut, det som skjer her. Jeg skal ikke gå inn på dette i detalj, men vi ser... Den linjen her oppe er viktig. Den definerer da den rutinen Fibo. Men det eneste vi skal se på... som vi må få med oss...", "source": "lecture"}
{"lecture_id": "os5del3", "chunk_id": "os5del3_0002", "start": 340.24, "end": 550.8, "token_count": 585, "text": "Med stor S så ber jeg GCC om å lage assemblerkode. Og da ser vi. Da har jeg fått en fil her som heter fibo.s. Det er den vi skal se på nå. Oi. Og den ser vi, den er ganske stor. Det ser jo litt gresk ut, det som skjer her. Jeg skal ikke gå inn på dette i detalj, men vi ser... Den linjen her oppe er viktig. Den definerer da den rutinen Fibo. Men det eneste vi skal se på... som vi må få med oss... Det er at her brukes hele tiden ram. For det vi har sett tidligere, det er at... En sånn konstruksjon som dette her, det er en peker til en integri-ram. Det som er inne i parentesen, det er et register. Så adressen i ram ligger i dette registeret. Og minus 12 er en sånn relativ adresse som sier at... Akkurat den integeren som vi skal hente ut, ligger minus 12 bite unna starten på det området. Så det eneste vi trenger å huske, er at dette er en variabel. Og dette er en variabel. Så det vi kan konkludere med, er at alle de operasjonene som utføres her... Sånn som den her, for eksempel. Den utføres på integer, som ligger i ram. Så hvis jeg tar adel, denne her... Den sier legg tallet én til denne variabelen som ligger i ram. Og denne variabelen her er typisk den tellevariabelen i løkken. For den ser vi øker med én hver gang i runden. Så det vi kan konkludere med her, er at når GCC lager kode her, så skriver den inn og ut av Ram hele tiden. Vi kan også legge merke til at i alle ad-operasjoner så er det ett register og ett element fra Ram. Så når jeg tar eax og legger til den verdien som ligger der ute i Ram... I prinsippet kunne man tenke seg at man... Hvis jeg går ut til koden igjen... I prinsippet kunne man tenke seg at man utførte en operasjon som dette her direkte i RAM. Altså man tok en referanse fra RAM og la den til. Spørsmå. Hva betyr prosent-eax? AIX er et register. Alle sånne referanser er til registeret. AIX er et Extended AX-register. Dette er et 32-bitsregister.", "source": "lecture"}
{"lecture_id": "os5del3", "chunk_id": "os5del3_0003", "start": 506.36, "end": 697.7, "token_count": 596, "text": "I prinsippet kunne man tenke seg at man... Hvis jeg går ut til koden igjen... I prinsippet kunne man tenke seg at man utførte en operasjon som dette her direkte i RAM. Altså man tok en referanse fra RAM og la den til. Spørsmå. Hva betyr prosent-eax? AIX er et register. Alle sånne referanser er til registeret. AIX er et Extended AX-register. Dette er et 32-bitsregister. Det vi brukte forrige gang, var 64-bitsregisteret da vi skrev kode. Da heter de... Registrene starter opp på R. Mens GCC kompilerer her, så lager den 32-bitskode. Det kan man endre ved kompileringen, og man kan forlange å få 64-bitskode. Men det viktige er at %dax, det er et register. Kjempebra dere spør. Bare stopp og spør mer. Så... Det vi så nå, var at... Når vi kompilerer denne koden her, så lager kompilatoren kode som går ut i minnet, og lagrer hele ting i minnet. Og det er litt merkelig. Og det jeg begynte å si, var at A lik A pluss B... Man kunne tenke seg at man gjorde en sånn operasjon med minnet også. At man tok det som ligger i A, legger til B... På en eller annen måte så må det jo hentes inn i registrene før man legger sammen, men det er det hardwaren som gjør. Men så er det sånn at i Exo86 Hardware så er det ikke lov eller deilig. Det er ikke definert operasjoner som bruker to minneadresser samtidig. Så i Exo86 så kan du f.eks. legge til et tall til en variabel direkte med en instruksjon. Du kan... Ta et register og legge til i en variabel. Direkte ram. Det er det lagd instruksjoner for, men det er ikke lagd instruksjoner som gjør dette. Det skal vi se på etterpå. Det vil bety at en sånn linse som dette her kan aldri oversettes av én linje maskinkode. Ok. Men det er jo litt merkelig at GCC lager kode som ikke bruker register. Det er jo det mest effektive. Da er det viktig å vite at GCC default lager den maskinkoden som det er raskest mulig å kompilere. Så hvis du har et stort program og driver og utvikler,", "source": "lecture"}
{"lecture_id": "os5del3", "chunk_id": "os5del3_0004", "start": 658.96, "end": 838.2, "token_count": 589, "text": "Det er det lagd instruksjoner for, men det er ikke lagd instruksjoner som gjør dette. Det skal vi se på etterpå. Det vil bety at en sånn linse som dette her kan aldri oversettes av én linje maskinkode. Ok. Men det er jo litt merkelig at GCC lager kode som ikke bruker register. Det er jo det mest effektive. Da er det viktig å vite at GCC default lager den maskinkoden som det er raskest mulig å kompilere. Så hvis du har et stort program og driver og utvikler, så ønsker du at den skal kompileres så fort som mulig. Og det er det som er default i GCC. Men hvis du ønsker at GCC skal lage et mest mulig effektivt program, et som kjører fortest mulig, så må du si ifra om det. Da kan det ta lengre tid å kompilere, men da optimaliserer GCC for å kjøre fort. Den opsjonen man bruker for å få til det, det er minus O. Så da kan jeg prøve å gjøre det med... Hvis vi gjør det med maine, altså sånn gjør vi det, så merker vi ikke så veldig forskjell, for det går ekstremt fort å gjøre dette her. Det går kanskje enda fortere også akkurat de operasjonene inne i CPU-en. Det går veldig fort, men hovedpoenget her er... Kan vi se på koden, hvordan den endrer seg? Hvordan GCC endrer på koden for å få den til å gå raskere? Da kan vi gjøre det samme. Da kan vi be om stor minus S. Da ber vi om GCC. om å lage maskinkode, eller assemble kode, som ser ut som den maskinkoden den virkelig lager. Og så kan vi se på hvordan den ser ut nå. Og da ser vi at... Jo, her er det plutselig annerledes. Ett sted er det en referanse til TeRam, men stort sett foregår alle operasjonene da. Inne i CPU-en med registeret. Her f.eks. legges tallet tre i et register. Og det er det tallet som man sammenligner med. Så det er den som får løkka til å gå. Men hovedpoenget her er at alt man... Alt som gjøres, det gjøres inni CPU uten at man refererer til ram. Eller ute i Maine, så kan man lagre resultateram.", "source": "lecture"}
{"lecture_id": "os5del3", "chunk_id": "os5del3_0005", "start": 788.52, "end": 885.7, "token_count": 301, "text": "Og da ser vi at... Jo, her er det plutselig annerledes. Ett sted er det en referanse til TeRam, men stort sett foregår alle operasjonene da. Inne i CPU-en med registeret. Her f.eks. legges tallet tre i et register. Og det er det tallet som man sammenligner med. Så det er den som får løkka til å gå. Men hovedpoenget her er at alt man... Alt som gjøres, det gjøres inni CPU uten at man refererer til ram. Eller ute i Maine, så kan man lagre resultateram. Eller hvis resultatet bare skal skrives ut, så trenger det ikke å lagres i ramme i det hele tatt. Det mest effektive er å kjøre det da inni CPUN. Men så er det begrenset lagreskapasitet i CPUN. Hvis du har et program som har en million... Et RA som har en million... Da kan du ikke ha alle variablene i registeret. Da må tallene lastes inn og ut av rammen hele tiden. Derfor vil litt større programmer alltid laste inn og ut av rammen. Men utgangspunktet er det raskeste å kjøre programmer inne i CPU-en. Bare bruke pokalregister.", "source": "lecture"}
