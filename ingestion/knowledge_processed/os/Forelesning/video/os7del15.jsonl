{"lecture_id": "os7del15", "chunk_id": "os7del15_0000", "start": 0.0, "end": 209.84, "token_count": 584, "text": "Her er jeg nå på den Rex desktop. Den ser vi her når jeg taster én i topp, så får jeg opp at den har fire Sippu-er. Men her ser vi at jeg har en løkke som endrer på noe i Systevise System Sippu Online. Og den kan sette de forskjellige Sippu-ene. Så det er åtte CPU-er her. Så det jeg gjør nå, er at jeg setter de resterende fire online. Sånn at hvis jeg nå taster topp og én, så ser vi - vips! Så kommer det fire CPU-er til. Så nå er denne en server eller en desktop med fire... Nei, med åtte CPU-er. Så ser vi også at dette her er one line sippu-list. 0 til 7. Åtte sippu-er. Men så ser vi at det står 2 treads per core og core per sockets. Og vi ser også at dette er en Intel Core E7. Hvis man slår opp på det, så vil man finne ut at denne her bruker hypertrening. Det eneste påstandet nå er at dette er hypertrødning. Den er faktisk... Det er egentlig ikke åtte helt uavhengige course. Sånn som operativsystemet fremstiller det. Og sånn som det ser ut når man kjører topp eller hot-topp. Så ser man... Her er det åtte super. Men vi skal nå se på hvordan det ser ut når vi faktisk kjører prosess. Eller er det egentlig fire? Det er problemstillingen her nå. Er dette åtte helt selvstendige CPU-er? Eller er det fire CPU-er som kjører hyper-trading og på en måte lurer OS til å tro at det er åtte? Så det første vi kan gjøre da, det er jo også prøve å kjøre mange... Mange prosesser. Så ser jeg hvordan det ser ut. Og vi hadde en fåløkke med reine... Ja, da ble det veldig mange. Det man kan gjøre litt enklere, er å si noe sånt. La oss si jeg har én til åtte prosesser. Så kjører jeg topp her samtidig. Oi. Nå ser jeg jeg har feil vindu. Rop ut. Ja vel. Jeg kan gjøre det på nytt. Det jeg gjorde, var at jeg startet åtte regnprosesser. Og så ser vi... Nå er det åtte CPU-er som står og kjører her.", "source": "lecture"}
{"lecture_id": "os7del15", "chunk_id": "os7del15_0001", "start": 155.4, "end": 373.14, "token_count": 595, "text": "Og vi hadde en fåløkke med reine... Ja, da ble det veldig mange. Det man kan gjøre litt enklere, er å si noe sånt. La oss si jeg har én til åtte prosesser. Så kjører jeg topp her samtidig. Oi. Nå ser jeg jeg har feil vindu. Rop ut. Ja vel. Jeg kan gjøre det på nytt. Det jeg gjorde, var at jeg startet åtte regnprosesser. Og så ser vi... Nå er det åtte CPU-er som står og kjører her. Vi kan i grunnen... Bare for å få det veldig eksplisitt, så kan vi sette på den... Last Used CPU her nede. Så kan vi prøve å få med den. Så må jeg få... Oi... Utvide topp lite grann. Der, ja. Der har vi LASJus CPU. Så kjører jeg nå åtte prosesser. Og vi ser da 01628 osv. De kjører i parallell på disse åtte CPU-ene. Sånn sett så ser det jo vel da bra ut. Men... Da er spørsmålet... Hvordan kan jeg finne ut nå... Er dette 100 %... Kjører de 100 % på helt uavhengige regneenheter? Eller er det hypertraining? Sånn som man kan lese at det faktisk er. Og hvordan ser man i så fall forskjell på det?  Jo, for å gjøre en lang, stor rekord, så kan man jo... Hvis det er hypertrening, så betyr det at da er det fire aluer. Og hvis det da er åtte jobber som står og jobber, så er det klart, da har operativsteamet satt inn to stykker på hver av CPU-ene, og de må da bytte på og... De må da dele på den aluen, og det vil jo ikke da gå like fort å kjøre. Så det vi kan gjøre, er å prøve å ta noen eksperimenter. Først så kan jeg prøve å kjøre fire jobber. Nå er de på hver sine CPU. Og kjører full rulle på dem. Og så kan vi se hvor lang tid tar egentlig det. Så dette er på en måte litt sånn som... Hvis man har potetskrellere, altså personer som skreller poteter, som står inne i hver sin bod, så kan man jo teste... Hvis det er to personer som står inne der og deler en potetskreller.", "source": "lecture"}
{"lecture_id": "os7del15", "chunk_id": "os7del15_0002", "start": 331.66, "end": 524.38, "token_count": 587, "text": "Først så kan jeg prøve å kjøre fire jobber. Nå er de på hver sine CPU. Og kjører full rulle på dem. Og så kan vi se hvor lang tid tar egentlig det. Så dette er på en måte litt sånn som... Hvis man har potetskrellere, altså personer som skreller poteter, som står inne i hver sin bod, så kan man jo teste... Hvis det er to personer som står inne der og deler en potetskreller. Akkurat som de deler en alu. Så vil det måtte gå dobbelt så lang tid å skrelle poteter. Så det er potetskrelling jeg nå egentlig holder på med her. Vi ser... Da jeg kjørte åtte... Nei, når jeg kjørte fire, så tok dette her realtime 18,5 sekunder, usertime 18,5... Jo, det betyr at disse prosessene, de fikk tilgang til 100 % av CPU. Og da skulle også realtiden, den totale realtiden, da være... Så dette er riktig. Sånn bør det være. Men vi kan begynne å ane nå at dette tar mye lengre tid. Og vi ser faktisk... Jo, dette tok nesten dobbelt så lang tid. Vi ser 18 sekunder tok det for én CPU. En prosess på én enkel CPU. Men når vi delte inn i åtte prosesser... Så tok det 35,7 sekunder. Altså... 37 ville vært det dobbelte. Så vi kan se her at vi har hatt en ørliten effekt av hypertreding. Men stort sett så ser vi disse to prosessene her. De måtte faktisk dele på samme aliu. Og det er derfor det tok mye lengre. Nesten dobbelt så lang tid å regne ut. Men det er også litt forvirrende, for det står fortsatt 99 %. Men dette er på en måte sånn som... Men i virkeligheten så switcher de lynhastig frem og tilbake. Da kan man jo lure på hvorfor dette... Hvorfor er dette hypertrening så viktig i det hele tatt? Men da har vi et... Skal vi se... Jeg har et... Dette her. Det er da et program som bruker et RA, og så gjør den en masse RA-operasjoner. Så den leser masse inn og ut fra RAM. Og da vil sånn som hypertraining kunne ha en effekt.", "source": "lecture"}
{"lecture_id": "os7del15", "chunk_id": "os7del15_0003", "start": 472.02, "end": 651.02, "token_count": 568, "text": "Men dette er på en måte sånn som... Men i virkeligheten så switcher de lynhastig frem og tilbake. Da kan man jo lure på hvorfor dette... Hvorfor er dette hypertrening så viktig i det hele tatt? Men da har vi et... Skal vi se... Jeg har et... Dette her. Det er da et program som bruker et RA, og så gjør den en masse RA-operasjoner. Så den leser masse inn og ut fra RAM. Og da vil sånn som hypertraining kunne ha en effekt. Så hvis jeg nå kompilerer dette RAM2-programmet, og så kjører det i stedet... Vi kan gjøre den samme testen. Vi kan kjøre én til fire. Nei... Det var... Det var feil. Sorry. Vi skulle ikke kjøre regnvann. Nå skulle vi kjøre ADOTAT. Sånn. Nå kjører jeg fire av de RAM-programmene samtidig. Og de vil da kjøre på hver sin CPU. Og de bruker det i fire sekunder. Og så setter jeg i gang åtte av dem. Hvis hypertraining ikke er noe effektivt nå, så ville dette tatt åtte sekunder. Men vi ser... Her hadde hypertraining plutselig en veldig stor effekt. For nå brukte vi realtid 4,3 sekunder. Mens her så brukte vi bare 4. Og dette viser hypertraining på... Med sitt største potensial. Her så klarte operativstemme å sette inn to prosesser på én og samme CPU med samme alu. Men siden her er det mye snakk med minnet... Man må hele tiden vente for å... Her oppe så klarer ikke én prosess å utnytte CPU-en fullstendig. For den må hele tiden vente på ting fra ram. Så derfor er hypertrening veldig effektivt. For da kan... Så kan disse to stå og bytte på å gjøre de institusjonene de trenger på SPU-en, og så får de gjort jobben veldig mye raskere. Men dette var de to ekstreme tilfellene. En regnejobb kan ikke utnytte hypertrening, men en rammejobb kan utnytte det veldig godt. Ofte så er det litt imellom, men i snitt så kan du kanskje få en sånn 30-40 % forbedring med hypertrening.", "source": "lecture"}
