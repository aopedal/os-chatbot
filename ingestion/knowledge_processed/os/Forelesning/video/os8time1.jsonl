{"lecture_id": "os8time1", "chunk_id": "os8time1_0000", "start": 0.0, "end": 196.48, "token_count": 590, "text": "Sånn. Da tar vi opp forelesningen fra nå av. Ine, er det noe du vil si relatert til opplegger eller oppgaver og erfaringene fra første innlevering f.eks.? Nei, ikke noe spesifikt noe. Det var veldig mange som svarte veldig bra og fikk til veldig mye, så det var fint å se. Det er jo sprøyt. Ja... Nei, fint. Men hvis dere har spørsmål til oppgaver eller INE eller de som er studentassistenter, så still gjerne spørsmål i 17. Hvis ikke, så begynner vi å se på hvor vi er og prøver å orientere oss litt. Forrige uke var det... Komte uke, så jeg håper at... Mange av dere klarte å ta inn det tapte hvis dere lå litt tilbake. For det har vært ganske... Ganske intenst, egentlig, de første ukene. Vi har på en måte kommet litt lenger enn vi var i fjor. Så det kommer nok... Det er en hard periode nå i dette kurset. Mye roligere etter påske. Vi har bare satt opp undervisning fram til uke 16. Det er mulig vi da får ganske mye tid til å se på tidligere eksamensoppgaver og så fordøye det stoffet vi har lært. Så da blir det litt mindre trykk mot slutten av kurset. Men her vi er nå, så har vi begynt med en container. Der ligger det en forelesning ute. Jeg hadde i hvert fall tenkt å dele den opp i litt mer deler, sånn at dere kan se på enkeltdeler. Men det er en ganske sakte, rolig, systematisk måte å begynne i praksis med containere, spesielt med dokkercontainere, Og kjøre de på de VM-ene som dere har. Så dokker er noe vi skal jobbe mye med de neste ukene. Jeg får se hvor langt vi kommer i dag. Men jeg tenkte kanskje å bruke litt tid på å se på de første oppgavene denne uken, som går nettopp på dette her, med å kjøre Hello World på dokker og starte opp. Og så, i løpet av dagen, komme frem til det å kunne starte opp en dokkecontainer som kjører en webserver på Linux-VM deres. Så tidligere så har dere kjørt en webserver direkte på Linux-VM,", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0001", "start": 157.08, "end": 357.04, "token_count": 589, "text": "Jeg får se hvor langt vi kommer i dag. Men jeg tenkte kanskje å bruke litt tid på å se på de første oppgavene denne uken, som går nettopp på dette her, med å kjøre Hello World på dokker og starte opp. Og så, i løpet av dagen, komme frem til det å kunne starte opp en dokkecontainer som kjører en webserver på Linux-VM deres. Så tidligere så har dere kjørt en webserver direkte på Linux-VM, men nå skal dere kjøre en dokkecontainer inni Linux-VM som kjører en webserver. Så det er en del ting der som kan være litt forvirrende. Jeg skal prøve å sette av litt tid mot slutten i dag, og så kan vi gå inn og se på de oppgavene og se hvordan det er tenkt det skal være. Men ellers så er hovedfokus i dag på scheduling og hvordan et operativsystem egentlig virker.  Altså hele det store bildet av operativsystemet, hvordan det styrer alle prosesser som kjører på en maskin. Vi har sett en del i praksis sånn som... Med multitasking og multitredding som vi holdt på med forrige gang... Hvordan operativsystemet da fordeler prosesser på... Og så hvordan et operativsystem deler inn tiden og lar én og én prosess kjøre. Men det er en del problemstillinger som vi ikke har sett på, spesielt hvordan man i praksis kan få til dette her. For der er det en del tilfeller hvor operativsystemet er nødt til å ha hjelp Og ha egne instruksjoner for å kunne kontrollere prosessene. Hvis vi tenker tilbake på dette med prosess, som er et levende liv, så tenker vi oss nå at vi har tusenvis av levende liv innenfor en datamaskin. Og så skal operatørsystemet nå holde orden på alle de tusen. Enkelte liv, altså prosesser, må fryses helt. Alt må lagres. Og så må man sette i gang andre prosesser. Og samtidig så må man sørge for at de ikke ødelegger for hverandre. Og det er de problemstillingene vi skal se på i dag. Så ser vi at det også står vaffelrøre på programmet i dag. Og det er da en simulering som jeg har lagd av hvordan... Rett og slett hvordan et operativsystem virker.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0002", "start": 312.24, "end": 491.0, "token_count": 598, "text": "Og så skal operatørsystemet nå holde orden på alle de tusen. Enkelte liv, altså prosesser, må fryses helt. Alt må lagres. Og så må man sette i gang andre prosesser. Og samtidig så må man sørge for at de ikke ødelegger for hverandre. Og det er de problemstillingene vi skal se på i dag. Så ser vi at det også står vaffelrøre på programmet i dag. Og det er da en simulering som jeg har lagd av hvordan... Rett og slett hvordan et operativsystem virker. Og det... Et operativsystem kan kjøre to prosesser samtidig på samme CPU. Og det er det jeg har illustrert med den vaffelrøre-videoen som ligger ute. Her så er jeg da... Jeg er på en måte... Jeg er en CPU. Og så tenker jeg at jeg skal både holde forelesning og lage vaffelrøre samtidig. Og da må jeg jo switche mellom de to oppgavene. Og da har jeg prøvd å gjøre det på en veldig systematisk måte, nemlig med å kjøre et operativsystem som styrer de to prosessene, som kjører da på meg. Og operativsystemet kjører også da på meg. Og da... Ja, vi kan komme litt mer tilbake til det på slutten. Kanskje vi setter av litt tid også, sånn at du kan se på den. Men det er altså en... Skal vi se... For de som syns forelesningen blir kjedelig, så kan dere hoppe og så se på den videoen. Så... Ja. Da ønsker jeg velkommen til denne. Vi skal ikke kjøre denne her, men dere ser jeg har et operativstem. Og så lager jeg vafler og holder forelesning samtidig. Dette ligger veldig tett opp til scheduleren i versjon 2.6 i Linux-kjernen. Så det er en litt eldre kjerne. I dag ser scheduleren litt annerledes ut. Men hovedideen er å få vist prinsippene. Så... Men vi kommer tilbake til det mot slutten av forelesningen. Først skal vi se på noen av de tingene som er viktige. For i det hele tatt å få til dette her. Og da er det spesielt prosessormodus. Og så er det trap og systemcall. Det er også en viktig ingrediens i det å lage et operativsystem.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0003", "start": 450.8, "end": 652.38, "token_count": 588, "text": "Så det er en litt eldre kjerne. I dag ser scheduleren litt annerledes ut. Men hovedideen er å få vist prinsippene. Så... Men vi kommer tilbake til det mot slutten av forelesningen. Først skal vi se på noen av de tingene som er viktige. For i det hele tatt å få til dette her. Og da er det spesielt prosessormodus. Og så er det trap og systemcall. Det er også en viktig ingrediens i det å lage et operativsystem. Aller først skal vi se på litt... Noe som egentlig henger mer sammen med det vi holdt på med forrige gang med multitasking. Én prosess ikke kan utnytte to sepur. Ja... Da hopper vi dit. Ja, sist, forrige gang, så holdt vi på med... Vi startet egentlig med cash og så på minne, og hvor viktig det er at vi har... for cash imellom CPU og ram, fordi CPU-en er mye raskere enn ram. Og da må man ha et mellomlager for å kunne utnytte hele effekten av raske CPU-er. Så så vi mye på cores, eller kjerner, regneenheter. Og da regnet de med at... Eller hver kjerne eller regneenhet. Det så vi på som én alu. Og da, når vi etterpå så på hypertrening... Intel hypertrening består da av at operatørsystemet ser på... Det som egentlig er én core, én kjerne, som har én alu... Den ser på det som to CPU-er eller to regneenheter. Men i virkeligheten så er det ved hjelp av Hardware så kan Hardware switche lynraskt, altså på nanosekunder. Så kan den switche mellom to prosesser som kjører samtidig inn i denne kjernen. Og de har da typisk to sett med registre osv. Og så switcher man veldig fort mellom dem. Og da kan man i enkelte tilfeller... Kan man utnytte den ventetiden som man vanligvis har på å hente noe i RAM, så kan det utnyttes, sånn at prosesser går mye raskere. Men det er igjen så veldig mye av alt annet, som cash og andre... Andre viktige deler ved en CPU. Det er egentlig der bare for at ting skal gå fortere. Da skal vi se på", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0004", "start": 608.96, "end": 793.8, "token_count": 596, "text": "Og de har da typisk to sett med registre osv. Og så switcher man veldig fort mellom dem. Og da kan man i enkelte tilfeller... Kan man utnytte den ventetiden som man vanligvis har på å hente noe i RAM, så kan det utnyttes, sånn at prosesser går mye raskere. Men det er igjen så veldig mye av alt annet, som cash og andre... Andre viktige deler ved en CPU. Det er egentlig der bare for at ting skal gå fortere. Da skal vi se på hvorfor ikke en prosess kan utnytte to CPU-er. Og problemstillingen her er nå spesielt det at man tenker at... OK, her har jeg en... Det kan være en regnejobb, typisk, som bruker mye CPU. Og nå vil jeg kjøre den på en svær server som har 96 CPU-er. Det må da gå... Fantastisk fort. Men da... Men det er ikke så lett å utnytte flere parallelle CPU-er. Flere forskjellige, samtidige renhentede enhenter. Og det er som regel fordi at... Én prosess, det er ett dataprogram som skal kjøres. Og som vi har sett, det som skjer når et dataprogram kjøres... Det er, som vi ser på denne illustrasjonen her, at det er instruksjoner etter hverandre som bare står og kjører om og om igjen. For det første vet ikke operativsystemet noe om hva som foregår inni denne koden. Den ser bare instruksjoner, og den sier til CPU-e... Sett i gang. Kjør disse instruksjonene. hva som egentlig foregår her. Det er det programmereren som het. Så derfor er det veldig vanskelig å gjøre noen fordeling her. Operativsystemet kan ikke si at OK, CPU1, du gjør instruksjon 1, 2, 3, og CPU2, du gjør 4 og 5. I prinsippet så kunne man gjøre det, men da måtte man flytte hele prosessen fra CPU1 og over på CPU2. Og det ville bare ta veldig mye tid. Så her er det på en måte opplagt at disse institusjonene må kjøre på samme CPU. For hele tiden er man avhengig av hva som skjedde i forrige institusjon. Man kan ikke kjøre dette uavhengig på en annen CPU.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0005", "start": 750.32, "end": 911.64, "token_count": 592, "text": "Operativsystemet kan ikke si at OK, CPU1, du gjør instruksjon 1, 2, 3, og CPU2, du gjør 4 og 5. I prinsippet så kunne man gjøre det, men da måtte man flytte hele prosessen fra CPU1 og over på CPU2. Og det ville bare ta veldig mye tid. Så her er det på en måte opplagt at disse institusjonene må kjøre på samme CPU. For hele tiden er man avhengig av hva som skjedde i forrige institusjon. Man kan ikke kjøre dette uavhengig på en annen CPU. Og det vi ser her, er en veldig enkel implementasjon av Fibonacci-rekken. Først legger du én inn i AX og én inn i BX. Og så på ledd 3 så ser du legg til AX til BX. Så da blir BX 2, og AX er fortsatt 1. Og så hopper du til neste ledd. Legg til BX til AX. Da legger du 2 pluss 1 er 3, så da blir AX 3. Og så hopper du opp til 3 igjen. Og sånn fortsetter det. Da blir BX lik... 2 pluss 3 er 5. Og så på neste så blir AX lik... Tre pluss fem er åtte, og så... og så videre. Ja, jeg ser forresten den Fimonacci-rekken her. Så ikke veldig riktig ut. Én, én, to, tre, fem, skulle stå der, og åtte. Det blir et problem for oppgavene. Hva er feil i denne Fimonacci-rekken? Men hovedpoenget er at man kan ikke utnytte... To eller hundre prosessorer, når du bare har ett program som kjører sånn som dette her... Det må kjøres sekvensielt. Og her er det altså... Det vi kunne få til, er hvis man som programmerer kan skrive kode som kan kjøres i parallell. Men det er opp til programmereren. Hvis programmereren kan klare å få til å splitte opp denne koden... Sånn at den kan kjøre på to steder samtidig, gjøre noen milliarder institusjoner på hvert sted, og så slå sammen resultatene. Da kan man utnytte to eller flere prosesser. Men i de fleste tilfeller så er det vanskelig. Og i et sånt tilfelle som dette her, hvor alt avhenger av", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0006", "start": 879.04, "end": 1049.96, "token_count": 584, "text": "Men det er opp til programmereren. Hvis programmereren kan klare å få til å splitte opp denne koden... Sånn at den kan kjøre på to steder samtidig, gjøre noen milliarder institusjoner på hvert sted, og så slå sammen resultatene. Da kan man utnytte to eller flere prosesser. Men i de fleste tilfeller så er det vanskelig. Og i et sånt tilfelle som dette her, hvor alt avhenger av forrige to-tre institusjoner, så vil det ikke være mulig å utnytte flere CPU-er. Men i noen tilfeller så har man parallelliserbar kode. Og vi tenker oss et enkelt tilfelle sånn som dette her. At vi skal legge sammen en stor sum. Vi skal telle fra 1 pluss 2 pluss 3 pluss 4 opp til 2000. Nå er det klart. I dette tilfellet så fins det en formel. Man kan utlede en formel som gir... Som er 1 ganger 1 pluss 1½, er det vel? Men det er jo ikke poenget. Poenget er at her skal vi gjøre en lang regneroperasjon. Vi skal gjøre den på denne måten. Og dette er da kode som opplagt er parallelliserbart. For da, hvis vi har en oppgave som er på denne måten her, at det er veldig mange helt like operasjoner... Da kan vi dele dette i to. Én CPU kan regne ut summen fra 1 til 1000. Og en annen CPU kan regne ut summen fra 1001 til 2000. Og så, etterpå at de to prosessene er ferdige, kan man slå sammen resultatet, og så får man totalsummen. Og dermed har man klart å parallellisere koden, og dermed kan man utnytte flere CPU-er. Men hvis man bare kjører et C-program som lager denne summen her, og overleverer det, laster det inn i RAM og ber operativsystemet om å kjøre, så aner ikke operativsystemet noe om hva alle disse institusjonene i denne summen gjør. Så operativsystemet selv er overhodet ikke i stand til å utnytte... Og har 48 CPU-er til rådighet. Det går bare ikke. Så man kan ikke forvente at operativsystemet skal kunne sørge for at man utnytter alle CPU-ene.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0007", "start": 1005.32, "end": 1204.72, "token_count": 587, "text": "Men hvis man bare kjører et C-program som lager denne summen her, og overleverer det, laster det inn i RAM og ber operativsystemet om å kjøre, så aner ikke operativsystemet noe om hva alle disse institusjonene i denne summen gjør. Så operativsystemet selv er overhodet ikke i stand til å utnytte... Og har 48 CPU-er til rådighet. Det går bare ikke. Så man kan ikke forvente at operativsystemet skal kunne sørge for at man utnytter alle CPU-ene. Og da er det programmereren selv som må sørge for parallellisering. Da kunne man løse dette her med to prosesser eller to tråder. Vi skal se på javatråder og p-treds i C, som vi da kan sette opp for å gjøre ting i parallelt. Vi har vel egentlig delvis sett på det når vi har gjort regnejobber i parallelt også. Da er det en sånn type regnejobb. Så setter vi opp akkurat like regnejobber på fire søppeur ved å bare starte fire bæsjscript samtidig. Ikke har slått sammen resultatene ennå. Men det er en liten detalj som man kan få til. Et eksempel på når dette kan være nyttig, er passordkracking. Og det var en student som syntes at den passordkrakking-algoritmen gikk litt tregt. Den tok jo over to minutter på studietid. Men i hvert fall da den stunten... klarte å dele opp... Dele opp det problemet i åtte like biter, og utnyttet da de åtte sekundene som var på PC-en. Og passord-cracking er typisk et problem som er parallelliserbart. Men hvis vi da setter i gang en skript som kjører gjennom alle de... Så kan ikke operativsystemet forstå dette her. ... Oi, dette her er jo parallelliserbart. Så intelligent er ikke operativsystemet. Det finnes noen kompilatorer som kan automatisk parallellisere på den måten. Så noen automatiske måter finnes det. Men stort sett så er det da programmereren som må se... Og på hver CPU så kan jeg kjøre gjennom ett antall passord. Så fordeler jeg de jobbene likt. Og det er først da man kan virkelig utnytte at man har mange CPU. Og dette er viktig å kunne,", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0008", "start": 1164.84, "end": 1354.44, "token_count": 589, "text": "Så intelligent er ikke operativsystemet. Det finnes noen kompilatorer som kan automatisk parallellisere på den måten. Så noen automatiske måter finnes det. Men stort sett så er det da programmereren som må se... Og på hver CPU så kan jeg kjøre gjennom ett antall passord. Så fordeler jeg de jobbene likt. Og det er først da man kan virkelig utnytte at man har mange CPU. Og dette er viktig å kunne, for veldig ofte så kan man nå kjøre på servere som har mange CPU-er. Og da kan det være viktig å ha kode som utnytter CPU-er. Hvis det er CPU-avhengig kode som man ønsker skal kjøre fort. Så dette er problemstillinger man ofte kommer ut for hvis man koder og er utvikling. Men det vi ser på, er liksom de prinsipielle delene av dette. Ok. Da skal vi se litt mer teoretisk på dette med scheduling og samtidige prosesser, og hvordan et operativsystem da styrer det. Det store bildet av hvordan et operativ styrer. Ja, vi har allerede snakket mye om at det er viktig at to prosesser ikke må ødelegge for hverandre. To programmer som står og kjører. Samtidig, på samme CPU... Også delvis. Hvis de kjører på hver sin CPU, så må de f.eks. ikke skrive til samme del av minnet. For med multicore CPU-er så har vi jo samme minne. Så det må ikke være sånn at én prosess overskriver minnet for en annen. Så må det heller ikke være sånn at én CPU, nei, én prosess, hvis den ønsker det, at den kan kapre all... Den setter opp en løkke og bare jobber og jobber, og andre prosesser ikke får gjort noe. Og så kan det ikke være sånn at enkeltprosesser tar over hele CPU-en. At de f.eks. får hele systemet til å fryse. I verste fall kjører kommandoen holdt og stopper hele systemet. Sånn kan det opplagt ikke være. ... løsninger opp gjennom tiden. En tidlig Windows-løsning, så var det sånn at man... Det var jo sånn Windows 95, hvor man begynte med multitasking. Så var det litt sånn at man hadde en frivillig operativstemme.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0009", "start": 1312.08, "end": 1495.24, "token_count": 590, "text": "Og så kan det ikke være sånn at enkeltprosesser tar over hele CPU-en. At de f.eks. får hele systemet til å fryse. I verste fall kjører kommandoen holdt og stopper hele systemet. Sånn kan det opplagt ikke være. ... løsninger opp gjennom tiden. En tidlig Windows-løsning, så var det sånn at man... Det var jo sånn Windows 95, hvor man begynte med multitasking. Så var det litt sånn at man hadde en frivillig operativstemme. Bare overlot hele CPU-en til en prosess. Men så måtte prosessen frivillig gi den fra seg. Men da var det klart med en gang det. Og et eller annet galt, så kunne hele systemet låse seg. Så etter hvert har alle moderne operativstemmer gått over til den beste løsningen, som er all makt til operativstemme, og som ofte kalles for preemptive multitasking. Og preemptive, det er... Opprinnelig så var det sånn i England at man skulle dele ut landområder til folk, til innbyggerne. På samme måte som Operativ Stem gjør det. Den deler ut rettigheter til innbyggerne i landet, som da er prosessene. Og hver får sin del, og hver får sin del av ram, av minne, og sin del av CPU. Så det vi skal se på nå, er hvordan kan Operativ Stem i praksis få til dette. Da er det ett prinsipp som er viktig. Operativstøy må ha litt hjelp fra Hardware for å kunne få til dette. Og en viktig bestanddel i den hjelpen er prosessormodus. Og alle moderne prosessorer har et modusbytt som er 011, og som begrenser hva som er lov å gjøre. Og det modusbyttet svitser imellom, det er da brukermodus og privilegier. Privilegert modus, eller cornal mode som det heter på engelsk. User mode og cornal mode. Dette kalles også ofte protection hardware. Og det er helt nødvendig for å kunne kjøre multitasking i det hele tatt. Hvis du ikke har noen forskjell på brukermodus og privilegert modus, så vil da i prinsippet enhver prosess kunne ta over kontrollen på systemet. Og da vil alt avhenge av at den prosessen gjør ting riktig og ikke fryser systemet.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0010", "start": 1455.32, "end": 1640.46, "token_count": 597, "text": "Privilegert modus, eller cornal mode som det heter på engelsk. User mode og cornal mode. Dette kalles også ofte protection hardware. Og det er helt nødvendig for å kunne kjøre multitasking i det hele tatt. Hvis du ikke har noen forskjell på brukermodus og privilegert modus, så vil da i prinsippet enhver prosess kunne ta over kontrollen på systemet. Og da vil alt avhenge av at den prosessen gjør ting riktig og ikke fryser systemet. Det finnes systemer som er sånn. Vi skal se på unicunnels senere. Og da er det typisk at du har en kjerne som bare gjør én bestemt ting. F.eks. bare er webserver. Og da har man ikke brukere og andre prosesser osv.  Da er det full kontroll til denne prosessen. Men den må da selvsagt ikke ødelegge systemet. Men dette med prosess og modus er veldig viktig i et generelt operativsystem som skal kjøre mange prosesser samtidig. Vi kommer ofte til å bruke ordet user mode, altså engelske betegnelsen på brukermodus. Og i user mode så er det begrenset aksess til ram. Og til instruksjoner. Så når CPU-en er switchet til use mode, så kan ikke alle instruksjoner utføres. F.eks. hvis du er i use mode og prøver å gjøre institusjonen holdt, eller stoppe maskinen, så blir den bare ignorert. Da skjer det ingenting. Og det er hovedhensikten med use mode. Og det samme gjelder minne. Man får ikke tilgang til alt som er i minnet. I corner mode, eller privilegert modus, så kan alt... Alle institusjoner kan utføres, alt minne og alle registre, alt kan gjøres. Og det er opplagt her, i corner mode, der kjører operativsystemkjernen. Og det er hele ideen. Fra corner mode så kontrollerer operativsystemkjernen alt som skjer. Men... Selv om vi har kernel mode og use mode, hvordan kan operativstem effektivt kontrollere brukerprosessene? Det er et godt spørsmål i chatten som ofte dukker opp, og som er et veldig viktig poeng. Spørsmålet er... Hvis du gjør dette... Sudo PC-user, altså hvis du kjører et skript som RUT, med sudo,", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0011", "start": 1590.44, "end": 1791.12, "token_count": 596, "text": "Og det er hele ideen. Fra corner mode så kontrollerer operativsystemkjernen alt som skjer. Men... Selv om vi har kernel mode og use mode, hvordan kan operativstem effektivt kontrollere brukerprosessene? Det er et godt spørsmål i chatten som ofte dukker opp, og som er et veldig viktig poeng. Spørsmålet er... Hvis du gjør dette... Sudo PC-user, altså hvis du kjører et skript som RUT, med sudo, kjører du da skript i privilegert modus? Nei, det er det viktig at man ikke gjør. Det er en veldig stor forskjell på det å være RUT på en maskin, RUT eller administrator, og det å være operativkjerne. For Ruth har adgang til alle... Hva kan man si... Alle devices. Altså... Det vil si da alle filer, alle nettverkspakker som kommer inn. Og... Så alt dette har Ruth tilgang til. Den kan stoppe prosesser, og den kan gjøre alt mulig. Men den kjører ikke i den grunn av... Kernelmode, det er en modus som operativsystemkjernen kjører deg i. Hvis du er Rut og du starter opp en regnejobb, så kjører du ikke da i kernelmode. Du kjører i usermode. Så det er en veldig distinkt forskjell på operativsystemkjernen og det å være Rut eller administrator. Så har du full kontroll på alle deviser, men ikke på selve institusjonene inni kjernen. Det er det bare operativsystemkjernen som har. Det er et godt og viktig spørsmål. Men hvordan kan OS effektivt kontrollere brukerprosesser? Jo... Problemet er at vi kan ikke bare si til en prosess... OK. Nå har du full kontroll på denne CPU-en. Gjør hva du vil. For da får vi et problem hvis den prosessen da bare sier - holdt... Eller setter opp en nøkkel og bare står i en evig løkke og står og går. Men samtidig, hvis operativsystemet skal kontrollere hver eneste instruksjon som brukerprosessen utfører, en slags emulering, så gir det veldig mye system overhead. Selv om det på en måte er litt... Det er litt det man kan se med virtuelle maskiner, med virtualisering, sånn som KVM og WMW osv. Men også med Java-virtuell maskin.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0012", "start": 1754.4, "end": 1948.84, "token_count": 591, "text": "For da får vi et problem hvis den prosessen da bare sier - holdt... Eller setter opp en nøkkel og bare står i en evig løkke og står og går. Men samtidig, hvis operativsystemet skal kontrollere hver eneste instruksjon som brukerprosessen utfører, en slags emulering, så gir det veldig mye system overhead. Selv om det på en måte er litt... Det er litt det man kan se med virtuelle maskiner, med virtualisering, sånn som KVM og WMW osv. Men også med Java-virtuell maskin. Så finnes det systemer som på en måte kontrollerer alle institusjoner. Men så for igjen da... For å få det effektivt så ofte så til syvende og sist så ender det med at... Prosessene må få full kontroll på CPU-en. Må kunne gjøre hver institusjon uten et overhead. F.eks. sånn som den Fibonacci-rekken... Hvis vi skal utføre den prosessen effektivt, så kan ikke operativstemmene gå inn og kontrollere hver institusjon og se at den ikke gjør noe galt, i den koden. Så vi må prøve å finne en løsning på det problemet. Ja... Så... En effektiv løsning på dette problemet... Vi har allerede vært litt inne på det i prinsippet. Men ikke hvordan det i praksis utføres. Men den effektive løsningen, den går da ut på at man bruker en hardwaretimer. I systemet så er det en hardwaretimer som da gir et begrenset tidsinnstilling. I den simuleringen som ligger ute, så bruker jeg en sånn kjøkkenklokke. Der ringer hardware-timeren hvert minutt. Så der er den. Der tar det lang tid. Men her, når vi snakker om OS-hardware-timere, så er det typisk et hundredels sekund. Veldig ofte kommer det et sånt hardware-timer-tick. Og da er det sånn... ved hardware... Så når det kommer et tikk fra timeren, så switches det til... Skal vi se... Har vi sett for det riktige her... Hver gang hardware-timeren slår inn, så kommer operativsystemet inn. Da svisjes det til privilegert modus, eller kurl-mode, og så har kjernen kontrollen. Og så, i starten av dette tikket, så sier operativsystemet...", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0013", "start": 1893.42, "end": 2083.3, "token_count": 591, "text": "Veldig ofte kommer det et sånt hardware-timer-tick. Og da er det sånn... ved hardware... Så når det kommer et tikk fra timeren, så switches det til... Skal vi se... Har vi sett for det riktige her... Hver gang hardware-timeren slår inn, så kommer operativsystemet inn. Da svisjes det til privilegert modus, eller kurl-mode, og så har kjernen kontrollen. Og så, i starten av dette tikket, så sier operativsystemet... Ok, nå skal den prosessen få lov å kjøre. Så da svisjer operativsystemet... Operativstemkjernen svisjer. Og så laster den inn den første instruksjonen. Det kan være Zikes lik 1. Det er typisk førsteinstruksjonen til koden som skal kjøre. Og så får den koden stå og kjøre i et hundredels sekund. Og hele hovedpoenget da er... Uansett hva den prosessen gjør, så vil den ikke kunne ødelegge systemet, for den vil da kjøre i brukermodus. Og det er helt ufarlig. Den kan ikke hvis en utfører holdt, så skjer det ingenting. Vi kan gå tilbake og se på den koden her. Tenk deg nå - timeren går på. Operativsystemkjernen kommer inn. Det switches automatisk over til curl mode. Og første operativsystemkodelinje settes inn. Det operativsystemet gjør da, er å laste inn alt som er nødvendig for at denne prosessen skal begynne å kjøre. Og så switcher operativsystemet. For når du er i corner mode, da kan du switche til use mode. Men ikke motsatt. Så du er i corner mode, så switcher du til use mode, og så legger du denne instruksjonen inn i instruksjonsregisteret. Og så overlater du full kontroll til den prosessen. Så løper den prosessen opp og ned, opp og ned, opp og ned her milliarder av ganger, lager kjempemange ledd i femmodazji-rekken. Og så går det en timer. Da kommer det en hardware timer inn etter 100 sekunder. Og idet hardware timeren kommer inn, så tar operativstemma over kontrollen igjen. Og på den måten så kan brukerprosesser kjøre Og utnytter CPU-en direkte, veldig effektivt og så mye det vil.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0014", "start": 2052.56, "end": 2239.36, "token_count": 596, "text": "Så løper den prosessen opp og ned, opp og ned, opp og ned her milliarder av ganger, lager kjempemange ledd i femmodazji-rekken. Og så går det en timer. Da kommer det en hardware timer inn etter 100 sekunder. Og idet hardware timeren kommer inn, så tar operativstemma over kontrollen igjen. Og på den måten så kan brukerprosesser kjøre Og utnytter CPU-en direkte, veldig effektivt og så mye det vil. Mens hvert hundredels sekund så kommer operativsystemet inn og tar over og sier OK, nå er det neste prosess som kjører. Så sånn kan operativsystemet da effektivt kontrollere brukerprosessene på en sikker måte uten at brukerprosessene kan f.eks. skru av helmaskinen. Dette er et minnekart, altså det bildet av ramm, på hvordan brukermodus og privilegertmodus eller corner mode ser ut på rammenivå. Og da tenker vi oss at vi har her øverst... Så har vi den delen av minnet som er tilgjengelig fra brukermodus. Det er typisk brukerdata og vanlige programmer. Men så er det også noe av operativsystemkjernen. Ikke operativsystemkjernen, men noe av operativsystemet. Altså den delen av operativsystemet som er utenfor kjernen. Det kan være system software som ikke nødvendigvis trenger å gjøre privilegerte institusjoner. Som ikke trenger det, men som utfører en del jobb, akkurat som et vanlig program utfører. Men så har du den privilegerte delen av minnet som utgjør OS-kjernen. Og her er det opplagt... Her kan ikke vanlige brukerprogrammer... De kan ikke få aksess her inne. For da kunne de endre på operativstemme og ødelegge alt. Det ville være en hackers drøm å kunne få tilgang til OS-kjernen.  For da kan du virkelig endre planen for alt. Så det må utgås. Og da er det igjen sånn at når modusbytt switcher til brukermodus, og en prosess prøver å endre på noe i denne adressen her, i ram, Hvis en prosess prøver å endre på noe i RAM som tilhører en annen prosess, så får den heller ikke lov. Så dette ville være styrt.", "source": "lecture"}
{"lecture_id": "os8time1", "chunk_id": "os8time1_0015", "start": 2195.84, "end": 2279.0, "token_count": 218, "text": " For da kan du virkelig endre planen for alt. Så det må utgås. Og da er det igjen sånn at når modusbytt switcher til brukermodus, og en prosess prøver å endre på noe i denne adressen her, i ram, Hvis en prosess prøver å endre på noe i RAM som tilhører en annen prosess, så får den heller ikke lov. Så dette ville være styrt. Men den privilegerte delen av mine, den er det helt umulig å touche. Så på den måten kontrollerer da operativsystemet alle prosessene, både CPU og RAM, ved hjelp av brukermodus og... OK. Da skal vi se på det andre viktige prinsippet i dag, og det er systemkall. Men da ser vi at vi trenger en pause. Så da tar vi et kvarter pause før vi starter med systemkall.", "source": "lecture"}
