{"lecture_id": "os4del18", "chunk_id": "os4del18_0000", "start": 0.0, "end": 188.72, "token_count": 585, "text": "Da kan vi til slutt se litt på hvordan denne koden virker. Hva er det som egentlig skjer her? Først i koden her så er det bare litt info. Jeg har oppsummert noen av de størrelsene som man bruker i Assembly. B står for Bite, 8-bit. L er long, 32-bit eller har 4 bytes, og Q er code, 64-bit eller 8-bites. Så har man da tilsvarende registre som er av forskjellig størrelse. Som jeg sa, så har man tradisjonelt AX, BX, CX og DX. Og så har man en slags... 8-bit-registeret. Ah og Al, og da omtaler man egentlig... Første og andre, altså high or low av de 16-bitene i AX. Så med Extended AX, som er 32-bit... De første CPU-ene var på 4-bit. Etter hvert som var det vanlig med 16-bits CPU-er. Men så kom 32-bits, og da måtte man utvide registrene. Så kom, sånn rundt 2000, så kom 64-bits CPU-er. Da måtte man utvide til 64-bit. Det som jeg bruker her, er som vi ser RCX. Det er et 64-bits reaser, så det er litt overkill når vi bare snakker om så små tall. Men vi ser jeg gjør akkurat det samme som i simuleringen. Jeg legger først tallet 3 i R6. Med move-kommandoer så legger jeg tallet 1 i add-x. Den er sånn at tallet 3... Dette er bare en konstant. Hvis det står en dollar, så kommer den konstant etterpå. Så dette er tallet 3. I tillegg må man ha en prosent foran registeret når man omtaler et register. Så jeg legger nå 3 i iCX, 1 i DX, 0 i BXAX. Så begynner jeg å kjøre en lucky. Det første jeg gjør her, er add DX til BX. Og det betyr da egentlig... Ta verdien i RBX og så legg til RDX. Og det er da en I pluss pluss. Jeg kunne gjort dette med en Operasjon INK. Da ville det hatt den samme effekten. Men jeg gjør det som i simuleringen. Og så fortsette. Add RAX til RAX. Det betyr da ta RAX lik RAX pluss RBX.", "source": "lecture"}
{"lecture_id": "os4del18", "chunk_id": "os4del18_0001", "start": 140.02, "end": 297.0, "token_count": 511, "text": "Så jeg legger nå 3 i iCX, 1 i DX, 0 i BXAX. Så begynner jeg å kjøre en lucky. Det første jeg gjør her, er add DX til BX. Og det betyr da egentlig... Ta verdien i RBX og så legg til RDX. Og det er da en I pluss pluss. Jeg kunne gjort dette med en Operasjon INK. Da ville det hatt den samme effekten. Men jeg gjør det som i simuleringen. Og så fortsette. Add RAX til RAX. Det betyr da ta RAX lik RAX pluss RBX. Og det er den summen. Ta S og så legg til I. Og så kommer sammenligningen. Jeg sammenligner nå R6 og RBX. Og R6, det ser vi i det tallet i den løkka jeg hadde. Så den avgjør hvor langt løkka går. Så da jeg endret den til 4, så gikk den én runde. Og så... Det kommer først som Compare, er i lik tre. Og så Jump, not equal. Hvis de ikke er like, så hopp opp til Start. Og her står det en Label Start. Det er da... I virkeligheten så vil dette programmet ligge i ramm når det er kompilert, og da er dette en adresse som den hopper opp til. Akkurat som i simulering. Så når alt er ferdig, så returnerer man. Og da kan man endre på koden her. For eksempel så sa jeg... rbx erlik rbx pluss rdx. Det kunne man jo for eksempel i stedet. Så kunne jeg bare si incrbx her. Det betyr øk rbx med én. Så kan jeg da teste. Det er veldig lett. Jeg kan teste nå om dette gikk bra. Kopulerer først assembler-koden, så linker jeg med main. Og så kjører jeg. Ja, det gikk faktisk bra. Jeg oppnådde det samme med en annen institusjon, nemlig INK. Som er increment. Den bare øker RBX med én.", "source": "lecture"}
