{"lecture_id": "os11del14", "chunk_id": "os11del14_0000", "start": 0.0, "end": 192.24, "token_count": 585, "text": "Ok. Da skal vi se på... Da skal vi se på et annet eksempel. Som på en måte er ligner, men denne gangen så er det... Så skal vi se på maskinkode. Og da skal vi se på faktisk... Helt enkeltinstitusjoner. Som likevel kan ha problemer med synkronisering. Så... Utgangspunktet her er... Dette programmet, Tredd.c, det er da... Dette er da en implementasjon av P-tredds i C. Og det er Cs motto å... Det er et bibliotek. Som gjør det mulig å kjøre tråder i et C-program. Vi skal ikke se så veldig mye på implementasjonen av det. Det er ikke kjempeviktig, men det er litt sånn som med Yawa. Her skaper vi en tråd. Tråd 1 og tråd 2. Og de skapes, og så sendes de med en metode, INK. Det er den metoden her oppe. Det som skjer, er at trådene kjøres. Så ser vi at de har en join her nede. Det betyr at de venter på hverandre, sånn at begge er ferdige før Maine avslutter og skriver ut svaret. Og det metoden gjør, det ligner jo litt på saldo, men det er at den veldig mange ganger, 100 millioner ganger, så kaller den på metoden én linje. Og jeg har kalt det én linje, den metoden, for å eksplisitt se Også for å kunne implementere den metoden direkte i Assembly. Og da må vi se hva én linje gjør. Og den... Én dot c, den er ganske enkel. Den bare... Den tar en ekstern int-svar. Og så øker den den med én. Enkelt og greit. Sånn som saldo. Her så ser vi... Denne variabelen her er deklarert globalt. Så når vi kompilerer den, kompilerer dette programmet sammen med 1.c, så vil dette være en global variabel som da denne én-linje får tak i. Så alt i alt... Det som da bør skje, er at... Nå er det ikke én som trekker fra en som legger til, men begge disse her legger til. Sånn at vi har... 100 mill. ganger så kaller vi svart pluss-pluss for den ene tråden", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0001", "start": 157.16, "end": 389.96, "token_count": 595, "text": "Denne variabelen her er deklarert globalt. Så når vi kompilerer den, kompilerer dette programmet sammen med 1.c, så vil dette være en global variabel som da denne én-linje får tak i. Så alt i alt... Det som da bør skje, er at... Nå er det ikke én som trekker fra en som legger til, men begge disse her legger til. Sånn at vi har... 100 mill. ganger så kaller vi svart pluss-pluss for den ene tråden og 100 mill. for den andre. Så resultatet til slutt bør bli 200 mill. Så da kan vi prøve å kopilere Tredoce. Men... ja... Det kan være greit å se på en typisk feil. Hvis vi bare kompilerer sånn, så ser dere at den gir en feilmelding om p3d. Det er fordi man må ha på en opsjon minus p3d. Den linker inn et bibliotek, p3d-biblioteket. Så må jeg skrive det riktig. Sånn. Da er jeg klar til å kjøre. Oi, se. Nå kjører Adatat. Så kjører den. Men vi ser... Akkurat som med javatrådene, så... Blir svaret forskjellig fra gang til gang. Her får jeg noe sånt som 114 millioner. Det jeg burde fått, var 200 millioner. Så igjen ser vi... Her er det et eller annet som går galt. Ja... Det vi ikke vet her, er... Kan dette være fordi den institusjonen... Altså én linje? Det kunne jo være at når den kompileres, at kompilatoren lager flere linjer når den kompileres. For å sjekke ut det, for å være sikker på at den ikke gjør det, så kan vi da lage... I stedet for én linje, så kan vi lage en liten minimal... Jeg kaller den minimal.s. En veldig liten assemblyfil. Et lite assemblyprogram som implementerer én linje. Og den implementerer det som... Med én enkel institusjon. Så dette er nå bare... Her er det liksom svart på hvitt at dette er bare én enkel assemblyinstitusjon. Jeg skal ikke gå inn på det... RIP er et spesielt register som brukes til å overføre variabler. Så det som skjer når jeg kjører den her, er at den felles variabelen...", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0002", "start": 344.44, "end": 549.28, "token_count": 592, "text": "Jeg kaller den minimal.s. En veldig liten assemblyfil. Et lite assemblyprogram som implementerer én linje. Og den implementerer det som... Med én enkel institusjon. Så dette er nå bare... Her er det liksom svart på hvitt at dette er bare én enkel assemblyinstitusjon. Jeg skal ikke gå inn på det... RIP er et spesielt register som brukes til å overføre variabler. Så det som skjer når jeg kjører den her, er at den felles variabelen... Så den gjør i praksis akkurat det som 1.c gjør. Men 1.c ble komplert, så da var jeg ikke sikker på om dette faktisk ga én enkeltinstitusjon. Men dette her gir én enkeltinstitusjon. Så jeg kan da prøve å komplere på nytt, men i stedet for 1.c så tar jeg med minimal. Sånn som det. Og så prøver jeg igjen. Og vi ser at... Jo, fortsatt... Så får jeg altså forskjellige svar. Og det... Det virker jo veldig rart, for her er det jo bare én institusjon. Så det kan ikke være noen context hitch som gjør at den ene... At det får den samme effekten. At man henter inn variabelen, og så kommer kontekst-session, og så lagres den. Men det virker rart fordi... Det virker rart fordi her er det bare én institusjon. Så vi har ikke noen sånn... Sånn som vi hadde Java. Og da er det jo én ting som er nærliggende å tenke deg. Hva om vi prøver med TaskSet her? Fordi at disse to programmene, eller dette programmet, de to trådene, de vil jo kunne skeduleres på hver sin CPU. Og da har vi plutselig ikke noe kontroll på det som skjer. Så et naturlig forsøk å gjøre her. Altså se hva... Hvis vi tvinger disse til å kjøre på samme SUPU, får vi da den samme effekten. Nei, det får vi ikke. Da ser vi... Hvis jeg tvinger dem til å kjøre på samme SUPU, så takket være at dette bare er én institusjon, så... Dette er bare én institusjon, så da kan vi ikke få noen kontekster som hopper fra prosess A til prosess B.", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0003", "start": 505.92, "end": 707.24, "token_count": 596, "text": "Så et naturlig forsøk å gjøre her. Altså se hva... Hvis vi tvinger disse til å kjøre på samme SUPU, får vi da den samme effekten. Nei, det får vi ikke. Da ser vi... Hvis jeg tvinger dem til å kjøre på samme SUPU, så takket være at dette bare er én institusjon, så... Dette er bare én institusjon, så da kan vi ikke få noen kontekster som hopper fra prosess A til prosess B. For du har ikke den mellomlagringen. Så her klarer operativstyrken og CPU-en, og den ene CPU-en, å styre dette. Men det er klart... Vanligvis kjører man ikke med Taset, så med en gang man... Kjører man med to i to CPU-er, så får man problemer. Spørsmålet er hvorfor det har noe å si at de kjører på hver sin CPU når det bare er én linje med kodeminimal. Ja, det er fordi at vi har sett at det som egentlig skjer... Når man utfører en kodelinje, selv om det bare er svar pluss, pluss... I praksis så må den verdien hentes fra RAM og inn i et register. Selv om det gjøres som én operasjon, så har vi også sett at én operasjon er delt opp i mange sånne små minioperasjoner. Så ting skjer ikke sånn atomisk. Det skjer ikke som én operasjon. Operasjon hvor ingen andre ting utenom skjer. Da må vi huske på at dette er to forskjellige CPU-er. Hver av de CPU-ene henter da inn denne variabelen. Den svarvariabelen ligger i ett spesielt sted i RAM. Begge to CPU-ene er koblet inn med databussen. Og begge henter ut den verdien når de skal gjøre svar pluss, pluss. Da vil det avhenge av hvem som blir ferdig med svaret før den sender, og før den henter ut neste, og trafikken på databussen. Og når man gjør dette 200 millioner ganger, så ser vi at hele tiden så... Hele tiden så kan det gå galt. Men det man kan gjøre... Jeg har en lock minimal her. Der har jeg fortsatt den ene institusjonen. Men så har jeg en institusjon som heter LOCK. Og det er den første metoden vi skal se på som kan løse dette problemet.", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0004", "start": 662.64, "end": 882.32, "token_count": 584, "text": "hvem som blir ferdig med svaret før den sender, og før den henter ut neste, og trafikken på databussen. Og når man gjør dette 200 millioner ganger, så ser vi at hele tiden så... Hele tiden så kan det gå galt. Men det man kan gjøre... Jeg har en lock minimal her. Der har jeg fortsatt den ene institusjonen. Men så har jeg en institusjon som heter LOCK. Og det er den første metoden vi skal se på som kan løse dette problemet. Og LOCK, den må jo da videreformidle til alle de andre CPU-ene at nå må ingen bruke databussen. Neste instruksjon... Fra og med lokk, som jeg sender, som jeg gjør nå... Den låser databussen, så ingen andre kan... Etter at jeg har satt lokk, så kan ingen bruke databussen. Og dermed... Hvis jeg nå kompilerer den... Lokk minimale stødighet. Så kan vi se at selv om jeg nå kjører Adopt-out... Uten å låse... uten å være på samme SUPPU, så ser vi at svaret blir riktig hver gang. Men så så vi, la kanskje merke til også, at dette tar lengre tid. Og det er ikke så rart, for nå må databussen låses hele tiden, sånn at de to trådene som kjører på hver sin CPU, de må nå koordineres. De opererer samtidig, men de må vente på hverandre. Så vi ser... Det tar nå sånn som 4,3 sekunder. Hvis jeg...  Hvis jeg kjører med den opprinnelig, minimal. Old timer, så tar det... Ja, det går nesten fire ganger så fort. Og dette er noe som generelt gjelder for koordinering. Det vil opplagt ta lengre tid, for da må... Da låses bussen med gjennom mellomrom, og dermed tar det rett og slett lenger tid. Men opplagt ikke minsten er at da unngår man race condition. Man får serialisert de to trådene, og resultatene blir riktige. Ja... Vi skal avslutte det, men det er et spørsmål til... Hva er forskjellen på dette med plassering i ramm? Når man kjører to tråder på samme CPU og hver sin CPU... Ja, det er ikke noen direkte forskjell. Altså, én CPU er koblet med databussen til RAM.", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0005", "start": 834.2, "end": 1023.88, "token_count": 596, "text": "Men opplagt ikke minsten er at da unngår man race condition. Man får serialisert de to trådene, og resultatene blir riktige. Ja... Vi skal avslutte det, men det er et spørsmål til... Hva er forskjellen på dette med plassering i ramm? Når man kjører to tråder på samme CPU og hver sin CPU... Ja, det er ikke noen direkte forskjell. Altså, én CPU er koblet med databussen til RAM. Men hvis, når disse to institusjonene kjører på samme CPU, altså med Task-sett, så... Når man utfører Svar pluss-pluss, eller altså når man utfører... Når man utfører denne institusjonen her, så... Hvis vi tenker oss at vi har to tråder, og den ene tråden utfører denne, så vil hele den institusjonen fullføres før det gjør en context-witch. Henter ut fra ram, variabelen svar... La oss si den er 50. Så øker den med 1 til 51 og legger ut svar igjen. Og dette foregår på én atomisk operasjon. Det er bare én operasjon i CPU-en. Og CPU-en blir aldri avbrutt midt inni den operasjonen. Men når denne operasjonen er ferdig, da kan det skje en context switch, og da kan... Den andre tråden kom inn. Men på den måten så ser vi at når de jobber på samme CPU, så vil først tråd én gjøre ferdig den. Og så kommer tråd to inn, og så vil den gjøres sin addisjon. Og da går det helt fint. Men når de er på to forskjellige CPU-er, så henter bare hver CPU da ut... Med denne institusjonen sender den en beskjed ut på databusse. ... hent inn variabelen Svar. Og de er ikke koordinerte i det hele tatt. Så den trafikken går frem og tilbake totalt uten koordinasjon. Og da kan man risikere at Prosess 1, som er på CPU1, kan hente svar i ett tilfelle. Og så kommer Prosess 2, som er på CPU2. Den henter ut den samme. De kan sende meldingen helt likt, og da får begge svaret tilbake samtidig. Og begge vil da øke med én og sende svaret tilbake.", "source": "lecture"}
{"lecture_id": "os11del14", "chunk_id": "os11del14_0006", "start": 988.88, "end": 1047.0, "token_count": 227, "text": "... hent inn variabelen Svar. Og de er ikke koordinerte i det hele tatt. Så den trafikken går frem og tilbake totalt uten koordinasjon. Og da kan man risikere at Prosess 1, som er på CPU1, kan hente svar i ett tilfelle. Og så kommer Prosess 2, som er på CPU2. Den henter ut den samme. De kan sende meldingen helt likt, og da får begge svaret tilbake samtidig. Og begge vil da øke med én og sende svaret tilbake. Og da får vi akkurat det samme problemet tidligere. Hvis den opprinnelig var 50, så sender begge to tilbake svaret 51. Og 51 lagres to ganger, men ett tall har da blitt borte. Og dermed så ser vi at det totale antallet ofte blir mindre. Mindre enn det det skal.", "source": "lecture"}
