{"lecture_id": "os14del10", "chunk_id": "os14del10_0000", "start": 0.0, "end": 193.72, "token_count": 594, "text": "Og vi skal se på noe som virker ganske rart i utgangspunktet. Jeg starter ut med et lite og enkelt program. Det eneste som ikke er så enkelt, er at det er veldig mange nuller her. Skulle kanskje brukt den definerte med ganger og så videre. Sånn som vi gjorde i det andre programmet. Men hvis jeg holder på de nullene her... Så ser vi at her er det... Bortsett fra 24 først her, så er det ni nuller. Så det er 1024 millioner. Så dette er da én milliard eller én giga. Så det jeg prøver å definere her nå, er et... Eller det jeg definerer her, er et... Og så ser vi at jeg har en enkel, liten forløkke. Den er enkel, og den går ikke helt opp, men den går til 10 millioner. Så vi ser at jeg bruker da en hundredel av det store r-øyet. Eller går opp til en hundredel. Så ser vi. Dette ser litt rart ut foreløpig, men... Bare tenk på det som en institusjon som vi ikke bruker. Vi setter J lik I ganger 100. Så den J-en går helt opp til maks her oppe. Men i første omgang, det jeg gjør, er at jeg setter nå hvert Ri lik I. Så jeg begynner med Ri av 0 og setter ned lik 0, Ri av 1 lik 1, Ri av 2 lik 2 osv. oppover. Og det er jo... Ja. Hva som skjer når man bruker ramm. Hvis vi gjorde sånn som vi gjorde før pause... At vi så på topp osv., så ville vi da sett at etter hvert som man brukte det jeg er i, så ville det komme inn i ress osv. Men nå skal jeg bare kompilere programmet. Det heter MDC. Og så ta tiden på... Og vi ser, til tross for at det skriver til... Hva er det... 1 million RI-elementer? Nei, 10 millioner. Så går det på 0,02 sekunder. Selv om vi sier ram er tregt, så går det veldig fort. Mye raskere enn til disk. Og det er bare det at registeret er enda raskere. Ekstremt rask. Men i hvert fall... Dette går fort. Så skal jeg gjøre det som er litt spesielt. Nå skal jeg endre I til J her.", "source": "lecture"}
{"lecture_id": "os14del10", "chunk_id": "os14del10_0001", "start": 150.0, "end": 365.2, "token_count": 597, "text": "Og vi ser, til tross for at det skriver til... Hva er det... 1 million RI-elementer? Nei, 10 millioner. Så går det på 0,02 sekunder. Selv om vi sier ram er tregt, så går det veldig fort. Mye raskere enn til disk. Og det er bare det at registeret er enda raskere. Ekstremt rask. Men i hvert fall... Dette går fort. Så skal jeg gjøre det som er litt spesielt. Nå skal jeg endre I til J her. Det er den eneste endringen jeg gjør. Jeg setter... Byttet nå I ut med J. Det vil si at jeg gjør akkurat like mange instruksjoner. For det er ti millioner ganger som jeg løper gjennom her. Så eneste forskjellen er at det første jeg gjør, er RA0 lik 0. Og så det neste jeg gjør, er RA av... Når I er lik 1, så vil J bli 100. Så neste institusjon er RA100 lik 1. Og så RA200 lik 2 osv. Men jeg gjør dette da ti millioner ganger. Så i utgangspunktet... I hvert fall hvis ram var ram, så burde dette ta... Akkurat like lang tid. Men vi ser dette tar enormt mye lengre tid. Det tar 1,5 sekunder i stedet for 0,19. Altså... Dette er faktisk nesten en faktor 100. Så hvordan kan det ha seg? Og at det kan skyldes... veldig stor forskjell i effektivitet. Vi gjør det samme antall institusjoner. Ti millioner ganger så skriver vi noe til et RI i RAM. Fyller opp program med tall ti millioner ganger. Helt det samme hver gang. Vel, vi har snakket med om cash. Og dette er absolutt noe som har med cash å gjøre. Og... Ja, det er et forslag at det er på grunn av r-øyet. Ja, det er pga. r-øyet. Og vi må prøve å tenke oss... Hva er det som... Hva er det egentlig som skjer her? Dette... Dette er et viktig poeng, så jeg tenker vi kan bruke litt tid på det. Kanskje jeg skal prøve å tegne... Tegne opp hva som skjer. Øyeblikk... Oi, hvor var den? Vi har et r-øy vi kaller r-øy her.", "source": "lecture"}
{"lecture_id": "os14del10", "chunk_id": "os14del10_0002", "start": 311.32, "end": 559.4, "token_count": 585, "text": "Ja, det er et forslag at det er på grunn av r-øyet. Ja, det er pga. r-øyet. Og vi må prøve å tenke oss... Hva er det som... Hva er det egentlig som skjer her? Dette... Dette er et viktig poeng, så jeg tenker vi kan bruke litt tid på det. Kanskje jeg skal prøve å tegne... Tegne opp hva som skjer. Øyeblikk... Oi, hvor var den? Vi har et r-øy vi kaller r-øy her. Og det... Og da er det et viktig poeng at dette R-øyet ligger i ramm. Og det ville da settes av plass til på adresser etter hverandre. Dette vil da være logiske eller virtuelle adresser. Men de ville mappes over, avbildes på fysisk R-øye i ramm, og da ligger de etter hverandre. Og det vi gjorde i første programmet... Det var å legge inn sånn... 0, 1, 2, 3, 4, 5 osv. Nedover sånn. Og da ser vi... Kanskje vi kom ned til 100 her nå, da. Eller vi kom egentlig mye lenger. Vi kom ned til... Vi kan ta med masse nuller der. Vi kommer ned til plass nummer 10 millioner. Kjempesvoltære. Men likevel så må vi huske på at dette var bare én av de 100 sånne som vi hadde bortover. Hvis vi tenker at dette er... At Ramm bare fortsetter sånn, ned dit, o... ned dit, og så videre. Så hadde vi da... Her oppe hadde vi 10 millioner og 1. Og her så hadde vi plassnummer 20 millioner. Den lå her nede. Og så hadde vi 100 sånne bortover. For vi har 100 ganger så mye som 10 millioner. Så det vi gjorde i det første programmet, det var bare å fylle opp det r-et der. Det var prog 1. Men så... Hva gjorde vi i prog 2? Jo, da så vi at vi fikk en faktor 100. Jeg prøver å skrive Prog2 med rødt der. Så i Prog2 så la vi fortsatt J lik 1. Så la vi fortsatt 0 inn her. Men så begynte vi å gå inn og legge inn her i 100.", "source": "lecture"}
{"lecture_id": "os14del10", "chunk_id": "os14del10_0003", "start": 511.12, "end": 741.48, "token_count": 594, "text": "For vi har 100 ganger så mye som 10 millioner. Så det vi gjorde i det første programmet, det var bare å fylle opp det r-et der. Det var prog 1. Men så... Hva gjorde vi i prog 2? Jo, da så vi at vi fikk en faktor 100. Jeg prøver å skrive Prog2 med rødt der. Så i Prog2 så la vi fortsatt J lik 1. Så la vi fortsatt 0 inn her. Men så begynte vi å gå inn og legge inn her i 100. Så la vi 1. Og så lenger ned her. 200. Så la vi to. Og så fortsetter vi sånn nedover. Men da begynte vi å legge inn her også. Når vi kom opp i over ti... Over ti millioner. Kanskje vi fikk da... Ja, her nede. Så la vi inn... I 20 millioner så la vi vel inn noe sånt som 200 millioner. Men håpepoenget er at vi legger da over alt i ramm. Nå fyller vi ut hele det herreiet. Og så legger vi i den andre kjøringen. Altså når jeg hadde Prog 2, var Array av J. Det var prog 2. Krog 1 var array av i, ligg i... Array av jilliki. Da bare la vi nedover her. Array av jodligi, da økes... Det er da prog 2. Da økes jod med 100 for hver gang, sånn at vi legger... Vi legger data utover i hele æreøyet, og totalt sett så var... Hele dette var på 4G. Så et svært æreøy. Men da kom vi til løsningen på dette. Ja, det er noen som kommer med et forslag her. Du må ut i ramma og hente en... Ja, det er riktig. Eller riktignok... Nå skriver vi til ramm. Sånn at vi må skrive ut til ramm. Men... Ja, og da... Når du legger inn tall på alle plassene, kan du legge inn flere tall før den må ut igjen. Jo, men problemet... Da... Jeg er ikke helt sikker på det. Jeg forstår deg riktig, men... En skulle på en måte tro at det var... For å si det på en annen måte... Hvis dette var ramm i ordets rette betydning, random access memory, så skal det gå like raskt å skrive noe hit", "source": "lecture"}
{"lecture_id": "os14del10", "chunk_id": "os14del10_0004", "start": 693.0, "end": 876.84, "token_count": 585, "text": "Sånn at vi må skrive ut til ramm. Men... Ja, og da... Når du legger inn tall på alle plassene, kan du legge inn flere tall før den må ut igjen. Jo, men problemet... Da... Jeg er ikke helt sikker på det. Jeg forstår deg riktig, men... En skulle på en måte tro at det var... For å si det på en annen måte... Hvis dette var ramm i ordets rette betydning, random access memory, så skal det gå like raskt å skrive noe hit som å skrive noe dit. Eller hvor som helst i ramm. Du er inne på noe der når du sier hvis du går... Hvis du legger inn tall på alle plassene på en gang... Må systemet kanskje flushe cashen? Ja, men det er akkurat dette som er... Akkurat det er poenget. Cashen må flushes. Altså... Når du legger alle etter hverandre på denne måten her, så det systemet vil gjøre da... Den vil ikke skrive én og én bite ut. Den vil ikke legge hver bite på ram ut på bussen og så skrive. Den vil ta hele... Litt avhengig av hvor stor LN cash er. Kanskje det er plass til 200 bite i LN cash. Så tar den hele den biten her. Og legger ut i LN cash. Da skriver den ikke bare én og én bite, men den kan ta hele biten etter hverandre, for den biten skal ligge på samme sted i ram. Og da kan man ta hele biter og skrive ut. Eller hvis man leser, så leser man da ikke én bite, men man leser fra ram. Først fyller man opp hele El3Cash, så El2Cash, og så El1Cash. Når de ligger etter hverandre, så kan de i sin helhet legges ut i LNCash. Og dermed så kan du ta mange hundre biter av gangen. Og som vi ser, så går det 100 ganger så fort. Derimot, når... ... vi prøver å kjøre program 2, så ser vi... Disse er spredt med 100 bite imellom. Så kanskje det er bare noen få bites som da treffer med hver gang LNCash kjøres. Noen flere treffer med L2, enda flere med L3, men du får ikke plass til alt. Så dette vil ta veldig mye lengre tid.", "source": "lecture"}
{"lecture_id": "os14del10", "chunk_id": "os14del10_0005", "start": 842.62, "end": 881.0, "token_count": 153, "text": "Og dermed så kan du ta mange hundre biter av gangen. Og som vi ser, så går det 100 ganger så fort. Derimot, når... ... vi prøver å kjøre program 2, så ser vi... Disse er spredt med 100 bite imellom. Så kanskje det er bare noen få bites som da treffer med hver gang LNCash kjøres. Noen flere treffer med L2, enda flere med L3, men du får ikke plass til alt. Så dette vil ta veldig mye lengre tid. Og vi ser det tar nesten 100 ganger så lang tid med Prog2.", "source": "lecture"}
