{"lecture_id": "os5time1", "chunk_id": "os5time1_0000", "start": 0.0, "end": 262.74, "token_count": 599, "text": "Hva er det som er så spesielt med denne filmen? Det er vanskelig å forstå hva som skjer i løpet av en uke. Ja. God morgen, alle sammen. Og i dag må jeg huske på å si at det er veldig hyggelig at det er så mange som står opp tidlig om morgenen for å gå på forelesning. Veldig bra. Så god morgen til alle sammen. Jeg er ikke sikker på om vi har med Ine i dag. Er du her i dag, Ine? Du er her, ja. Flott. Jeg hører deg også. Kjempebra. Da... Under hele forelesningen, så... Der er hun i chatten også. Hun er tilgjengelig for å svare på spørsmål. Avbryt når som helst og spør. I chatten kan dere spørre hele tiden. Også Ine hvis det er noe veldig viktig, så avbryter du meg. Eller uansett, hvis det er et godt spørsmål, så ta... Bare stopp meg og si... Hør her. Eller hvis jeg sier noe veldig galt. Det pleier ikke å skje. Kjempebra. Ja, også Ine, det er fint at dere minner meg på om å ta opp. Men nå startet jeg med å ta opp før jeg begynte her. For jeg tar ikke opp direkte i Zoom, sånn at dere ikke vil høre den stemmen som sier jeg tar opp. Men det blir tatt opp. Men nå blir det tatt opp sånn at... Hvis vi ikke ser bildene fra Zoom, f.eks., hvis dere dukker opp der. Så det blir tatt opp, og så legger jeg ut... Jeg tror jeg kanskje rekker å legge ut i pausen allerede fra første time. Og så deler jeg det som vanlig opp i biter, sånn at det er enklere å se på senere.  Men da skal vi først se på hva vi skal holde på med i dag. Og her er oversikten. Det kanskje viktigste denne uken er at det er frist for Obligin-levering på fredag. Og Obligin består i alle de deloppgavene som har vært Men da ikke fra uke 5. Altså ikke oppgavene denne uken. Det er vel til og med denne uken. Uke 4. Når du er ferdig med obliger denne uken, kan obligen leveres inn. Så alle oppgavene fra uke 4 skal leveres inn her.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0001", "start": 213.16, "end": 401.34, "token_count": 595, "text": "Men da skal vi først se på hva vi skal holde på med i dag. Og her er oversikten. Det kanskje viktigste denne uken er at det er frist for Obligin-levering på fredag. Og Obligin består i alle de deloppgavene som har vært Men da ikke fra uke 5. Altså ikke oppgavene denne uken. Det er vel til og med denne uken. Uke 4. Når du er ferdig med obliger denne uken, kan obligen leveres inn. Så alle oppgavene fra uke 4 skal leveres inn her. Det jeg håper dere gjør, er at dere jobber jevnt hver uke. Da vet dere hva som er obligatorisk, så gjør dere de oppgavene. Ja, altså Ine? Du hører meg? Ja, vi har snakket litt med... Litt om de som av forskjellige grunner er alene på en gruppe. Spesielt nå er det ikke alltid så lett å få til samarbeid. Men uansett så tenker jeg det er fornuftig å så på en måte lempe litt på kravet til godkjent for de som er alene på en gruppe. Jeg tenker det er rimelig sånn at man... For det kan være litt ekstra utfordrende. Det er ganske mye oppgaver, men det aller viktigste å gjøre etter kurset er Det er å jobbe dere gjennom oppgavene. Jeg var jo alene selv da jeg leverte. Jeg husker jo det var ganske mye mer ekstra jobb. Ja, så vi tar det litt med i beregningen. Ja. Når vi vurderer godkjent, ikke godkjent. Ja, men det høres veldig rimelig ut. Så har jeg lagt ut digitale videoer om skjellscript. Jeg ligger litt etter der, så jeg har ikke fått ferdig de helt siste videoene. Jeg får det i løpet av dagen eller i morgendagen. Og så skal jeg også legge ut flere videoer om bæsj-scripting. Så det er liksom skjellscripting som er fokus nå. Og da blir det litt mer avanserte skjellscript. Og så fra neste uke... Prøver dere å få til det i løpet av uken, så skal jeg dele ut virtuelle maskiner til alle, sånn at alle får en virtuell maskin som dere kan logge inn på med en public ip-adresse hvor dere kan styre alt selv.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0002", "start": 364.5, "end": 576.78, "token_count": 583, "text": "Jeg får det i løpet av dagen eller i morgendagen. Og så skal jeg også legge ut flere videoer om bæsj-scripting. Så det er liksom skjellscripting som er fokus nå. Og da blir det litt mer avanserte skjellscript. Og så fra neste uke... Prøver dere å få til det i løpet av uken, så skal jeg dele ut virtuelle maskiner til alle, sånn at alle får en virtuell maskin som dere kan logge inn på med en public ip-adresse hvor dere kan styre alt selv. Lage webservere osv. Egentlig er det ikke virtuelle maskiner. Vi kommer tilbake til det. Det er dokkerinstanser som ser ut som virtuelle maskiner. Så skal vi bruke de fra neste uke, og så uken etter der igjen, så skal vi begynne å kjøre dokker-condeinere på disse VM-ene. Egentlig er det dokker i dokker, men det kommer vi tilbake til. I dag så er temaet C og maskinkode. Det er tema første time, og så skal vi se på pipelining og... Superskalære prosessorer i andre time. Og da skal vi gå hakket videre fra den skalære prosessoren som vi hadde i simuleringen. En skalær er altså en prosessor som gjør én ting av gangen. Så skal vi se på moderne CPU-er som faktisk selv innen den samme enkle CPU-en, Men det kommer vi til å stukke ut i andre time. Først kan vi fortsette å se på sammenhengen mellom høynivåkode og maskinkode. Og dette er det viktig å ha med seg senere i kurset, for da skal vi se hvordan operativsystemer styrer prosesser. Og i mange tilfeller så er det helt avgjørende hvordan hardwaren under virker. Hvor mange CPU-er man har, hyperthreading og til en viss grad også det med pipelining, er viktig for operativshemmede. Det vi først og fremst skal se på i dag, det er... maskinkode. Og det aller første jeg tenkte å se på, var optimalisering av maskinkode. Og da skal jeg gå til et eksempel på det. Skal vi se... Her har jeg laget en liten rutine. Som... Ja, det er ikke så viktig hva eksempelet er, men dette er da eksempel på kode som...", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0003", "start": 504.36, "end": 723.58, "token_count": 596, "text": "Hvor mange CPU-er man har, hyperthreading og til en viss grad også det med pipelining, er viktig for operativshemmede. Det vi først og fremst skal se på i dag, det er... maskinkode. Og det aller første jeg tenkte å se på, var optimalisering av maskinkode. Og da skal jeg gå til et eksempel på det. Skal vi se... Her har jeg laget en liten rutine. Som... Ja, det er ikke så viktig hva eksempelet er, men dette er da eksempel på kode som... Som går i en loop og som logisk bygger på hverandre. Så den... Den... Vi skal se senere. Denne koden kan ikke utføres i parallell. Men det viktigste nå er å se på hvordan utføres kode effektivt i en CPU. Det vi skal ha fokus på, er at vi har sett... I simuleringen forrige gang så vi at noen instruksjoner utføres bare på registrene. Og da står man inne i CPU-en, hvor man har registeret tilgjengelig. Og så tar man f.eks. R0 lik R0 pluss R1, som vi gjorde i simuleringen. Det er en operasjon som utføres kun på registeret. Men så så vi at vi også kan legge verdier ut i ramm. Det er det man typisk gjør når man har en variabel, sånn som den int a1 her. Når vi kjører et program som dette, så er det typiske som skjer da, når vi skal lagre den variabelen, er at den lagres i ramm. En egenplass i ram. En integer er på 4 bite, så da settes det av 4 bite i ram til den integeren. Eller 4 bite er 32 bit, så det settes av i ram. En som vi så sist, ram deler seg inn i bites. Åtte bit av gangen, så det er den minste enheten i ram. Det tar mye lengre tid å lagre ting i ramm. Så ca. ti ganger så lang tid tar det å lagre et tall i ramm enn å lagre det i registeret. Så derfor lønner det seg stort sett å gjøre så mye som mulig med registeret, og så laste ut resultatene etterpå til ramm. Så det vi skal se på nå, er hvordan en kompilator lager maskinkode av denne koden her. Aller først kan vi se på hvordan denne koden kjøres.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0004", "start": 680.74, "end": 911.84, "token_count": 599, "text": "Det tar mye lengre tid å lagre ting i ramm. Så ca. ti ganger så lang tid tar det å lagre et tall i ramm enn å lagre det i registeret. Så derfor lønner det seg stort sett å gjøre så mye som mulig med registeret, og så laste ut resultatene etterpå til ramm. Så det vi skal se på nå, er hvordan en kompilator lager maskinkode av denne koden her. Aller først kan vi se på hvordan denne koden kjøres. Så... Da har jeg en kode som heter maine sånn, som jeg skal kompilere og linke sammen med den fiberkoden. Her ser vi at vi definerer en ekstern int-fibo. Det er den assembly-metoden som jeg skal bruke. Eller nei, ikke assembly-metode. Dette er den C-metoden som jeg skal bruke. C-funksjonen som vi så på, nemlig fibo.c. Vi ser den må hete det samme. Og det som er litt forskjellig fra forrige gang, er at nå sender vi med... Vi kaller den Fibo med Last. Så ser vi i Main her, så setter jeg en Last Alec 10. Og så kjører jeg metoden Fibo på Last. Så Fibo er 10. Den skal gi Fibonacci-tall nummer 10 i rekken. Så vi kan først se hvordan det ser ut i komposisjon. De kan jeg kompilere rett sammen på samme linje. Sånn. Da får jeg ett program adatat. En kjørbar fil. Og så ser vi... Her kommer resultatet 55 ut. Så den funker som den skal. Men det vi skal se på nå, er... Den maskinkoden ut som det kompileres til når man kompilerer den høynivåkoden Fibo. Og da kan vi som sist spørre... GCC, hvordan ser assembly-koden du lager, ut? Og det gjør man med minus S. Men når jeg kjører den, så... Er det stor S, kanskje? Ja. Man gjør det ikke med minst liten S, men med stor S. Med stor S ber jeg GCC om å lage asemblerkode. Og da ser vi, da har jeg fått en fil her som heter fibo.s. Det er den vi skal se på nå. Det ser jo litt gresk ut, det som skjer her. Jeg skal ikke gå inn på dette i detalj, men vi ser... Den linja her oppe er viktig. Den definerer den rutinen Fibo.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0005", "start": 860.74, "end": 1081.98, "token_count": 590, "text": "Er det stor S, kanskje? Ja. Man gjør det ikke med minst liten S, men med stor S. Med stor S ber jeg GCC om å lage asemblerkode. Og da ser vi, da har jeg fått en fil her som heter fibo.s. Det er den vi skal se på nå. Det ser jo litt gresk ut, det som skjer her. Jeg skal ikke gå inn på dette i detalj, men vi ser... Den linja her oppe er viktig. Den definerer den rutinen Fibo. Men det eneste vi skal se på, som vi må få med oss her, det er at her brukes hele tiden... For det vi har sett tidligere, det er at... En sånn konstruksjon som dette er, det er en peker til en integr i ram. Det som er inne i parentesen, det er et register. Så adressen i ram ligger i dette registeret. Og minus 12, det er en sånn relativ adresse. Som sier at akkurat den integraen som vi skal hente ut, ligger minus 12 bite unna starten på det området. Så det eneste vi trenger å huske, er at dette er en variabel. Og dette er en variabel. Så det vi kan konkludere med, er at alle de operasjonene som utføres her, sånn som den her, for eksempel... Den utføres på integer som ligger i ram. Så hvis jeg tar adel, denne her, den sier legg tallet 1 til denne variabelen som ligger i ram. Og denne variabelen her er typisk den tellevariabelen i løkken. For den ser vi øker med 1 hver gang i runden. Så det vi kan konkludere med her, er at... At når GCC lager kode her, så skriver den inn og ut av RAM hele tiden. Vi kan også lenge merke til at alle ad-operasjoner, så er det ett register og ett element fra RAM. Så den tar EAX og legger til den verdien som ligger der ute i RAM. Og i prinsippet så kunne man tenke seg at man... Hvis vi går ut til... I prinsippet kunne det tenke seg at man utførte en operasjon som dette her direkte i RAM. Altså - man tok en referanse fra RAM og la den der. Spørsmål - hva betyr prosent-eax? Prosent-eax, det er et register. Det er et extended AX-register. Det er et 32-bits-register.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0006", "start": 1028.86, "end": 1230.76, "token_count": 592, "text": "Så den tar EAX og legger til den verdien som ligger der ute i RAM. Og i prinsippet så kunne man tenke seg at man... Hvis vi går ut til... I prinsippet kunne det tenke seg at man utførte en operasjon som dette her direkte i RAM. Altså - man tok en referanse fra RAM og la den der. Spørsmål - hva betyr prosent-eax? Prosent-eax, det er et register. Det er et extended AX-register. Det er et 32-bits-register. Det vi brukte forrige gang, var 64-bits-registeret da vi skrev kode. Da heter de... Registrene starter opp på R. RAX, RBX osv. Når vi kompilerer her, så lager den 32-bitskode. Det kan man endre ved kompileringen. Og man kan forlange å få 64-bitskoden. Men det viktige er at %dax, det er et register. Kjempebra dere spør. Bare stopp og spør mer. Så... Det vi så nå, var at når vi kompilerer denne koden her, så... Lage komplimenter om kode som går ut i minnet... Og lagrer hele ting i minnet. Og det er litt merkelig. Det jeg begynte å si, var at man kunne tenke seg at man gjorde en sånn operasjon med minnet også. At man tok det som ligger i A, legger til B... På en eller annen måte må det hentes inn i registrene før man legger sammen. Men det er det Hardware-en som gjør. Men i Exot 6 Hardware er det ikke definert operasjoner som bruker to minneadresser samtidig. Så i Exot 6 kan du f.eks. legge til et tall til en variabel direkte med en institusjon. Du kan ta et register og legge til i en variabel direkte i ramm. Men det er ikke lagde instruksjoner som gjør dette her. Det skal vi se på etterpå. Det vil bety at en sånn linje som dette her kan aldri oversettes av én linje maskinkode. Ok. Men det er jo litt merkelig at GCC lager kode som ikke bruker registeret. For det er jo det mest effektive. Og da er det viktig å vite at GCC default, som det er raskest mulig å kompilere. Så hvis du har et stort program og driver og utvikler, så ønsker du at den skal kopiere så fort som mulig.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0007", "start": 1194.1, "end": 1390.7, "token_count": 594, "text": "Det skal vi se på etterpå. Det vil bety at en sånn linje som dette her kan aldri oversettes av én linje maskinkode. Ok. Men det er jo litt merkelig at GCC lager kode som ikke bruker registeret. For det er jo det mest effektive. Og da er det viktig å vite at GCC default, som det er raskest mulig å kompilere. Så hvis du har et stort program og driver og utvikler, så ønsker du at den skal kopiere så fort som mulig. Og det er det som er default i GCC. Men hvis du ønsker at GCC skal lage et mest mulig effektivt program, et som kjører fortest mulig, så må du si ifra om det, og da kan det ta lengre tid å kompilere, men da optimaliserer GCC for å kjøre fort. Da kan jeg prøve å gjøre det med... Hvis vi gjør det med main, så merker vi ikke så veldig forskjell, for det går ekstremt fort å gjøre dette her. Det går kanskje enda fortere også akkurat de operasjonene inni CPU-en. Det går veldig fort, men hovedpoenget her er... Kan vi se på koden, hvordan den endrer seg? Hvordan GCC endrer på koden for å få den til å være raskere. Da kan vi gjøre det samme. Da kan vi be om... Stor minus S, da ber vi om GCC om å lage maskinkode. Eller da assemble kode, som ser ut... Som den maskinkoden den virkelig lager. Og så kan vi se på hvordan den ser ut nå. Og da ser vi at jo, her er det plutselig annerledes. Og det er ett sted så er det en referanse til Teram. Men stort sett så foregår alle operasjonene da inne i CPU-en med registeret. Det er det tallet som man sammenligner med. Det er den som får løkka til å gå. Men hovedpoenget er at alt man... Alt som gjøres, det gjøres inni CPU uten at man refererer til ram. Så kan man heller ute i Main, så kan man lagre resultat i ram. Eller hvis resultatet bare skal skrives ut, så... Så trenger det ikke å lagres i ramme i det hele tatt. Det mest effektive er å kjøre det da inni CPUD. Men så er det begrenset lagreskapasitet i CPUD. Hvis du har et program som har en million...", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0008", "start": 1350.54, "end": 1579.18, "token_count": 598, "text": "Men hovedpoenget er at alt man... Alt som gjøres, det gjøres inni CPU uten at man refererer til ram. Så kan man heller ute i Main, så kan man lagre resultat i ram. Eller hvis resultatet bare skal skrives ut, så... Så trenger det ikke å lagres i ramme i det hele tatt. Det mest effektive er å kjøre det da inni CPUD. Men så er det begrenset lagreskapasitet i CPUD. Hvis du har et program som har en million... Et RA som har en million variabler, så kan du ikke ha alle de variablene i registeret. Da må tallene lastes i. Da skal vi se lite grann på dette, så skal vi gå tilbake og se på rutinen vi hadde. Vi har regnet ut en sum. Og den het noe sånt som... Skal vi se... Det var den funksjonen... Sumfunksjonen. Denne. Og... Det vi så på sist, var at vi ba GCC om å lage assemblykode for den. Hvordan den så ut. Vi kan repetere det. Jeg ba GCC om å lage assemblerkode. Og den skulle da bli sumfunksjon.des. Og den så ut som noe sånt som dette her. Så fant vi ut... Hvis jeg går inn og ser i detalj, så ligner den veldig på den. Maskinkoden vi hadde i simuleringen... Bortsett fra denne skriver nå ut til minnene. Vi ser det er hele tiden minnereferanser. Men i prinsippet så ligner koden veldig. Men det vi skulle se på nå, var hva skjer med denne funksjonen hvis jeg ber om å lage så effektiv kode som bare mulig. Jo, da kan vi prøve å se hva som skjer da. Da får jeg en ny assembly-kode. Og denne er da lagd av GCC for å være mest mulig effektiv. Og da ser vi ganske overraskende at her var det ikke veldig mye kode. Noen som klarer å se hva denne koden her gjør? Den skal jo regne ut en hel sum. Det er veldig få instruksjoner her. Og det som da viser seg, er at kompilatoren er faktisk da så smart at den ser vel uansett hva som skjer med input og output eller i denne metoden her... Uansett når denne kjøres, så vil du regne ut en sum 1 pluss 2 pluss 3 som blir 6. Så den gjør vel da faktisk den optimale...", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0009", "start": 1547.54, "end": 1757.28, "token_count": 588, "text": "Den skal jo regne ut en hel sum. Det er veldig få instruksjoner her. Og det som da viser seg, er at kompilatoren er faktisk da så smart at den ser vel uansett hva som skjer med input og output eller i denne metoden her... Uansett når denne kjøres, så vil du regne ut en sum 1 pluss 2 pluss 3 som blir 6. Så den gjør vel da faktisk den optimale... Den regner ut hele løkka, og så kommer den fram til at svaret blir seks. Og så legges bare svaret seks ut i AX, og så returnerer det. Så det er morsomt nok. Så er det den optimale... Den optimale versjonen av dette... Av denne løkka her. Det er jo bare å returnere. Det virker jo litt overraskende, men det er helt logisk. GCC går nå inn for å lage den hurtigst mulige versjonen av denne koden, og det er da faktisk bare å returnere tallet seks. Med en gang du får et input her, eller det kan skje andre ting, så er det klart, da kan man ikke optimalisere på den måten. Da ville vi sett at det fortsatt var en løkke, men at programmet da stort sett bare brukte registeret. Ok. Da skal vi... Hvis det ikke er noen spørsmål rundt optimalisering, så skal vi gå til en litt annen problemstilling, som er veldig viktig å ta med seg senere. Men vi skal se på det i detaljene. Her har jeg en kode som heter 1-linje. Og det er kode som viser 1 linje i... 1 linje i høynivåkode. Og det som er fokus her, det er at vi skal se at... Det ikke er en én-til-én-avhengighet fra høynivåkode til maskinkode. Så vi kan se på strukturen av dette programmet først, sånn at vi skjønner hvordan det virker. For det første så har vi da en ekstern metode som heter én-linje. Og dette er min, main, og den kaller da én-linje. Så skal vi fokusere på koden i énlinje og se hvordan den ser ut. Og én linje.c, den ser rett og slett sånn ut. Så her ser vi - det er et veldig enkelt svar som regner ut meningen med livet.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0010", "start": 1715.9, "end": 1897.74, "token_count": 597, "text": "sånn at vi skjønner hvordan det virker. For det første så har vi da en ekstern metode som heter én-linje. Og dette er min, main, og den kaller da én-linje. Så skal vi fokusere på koden i énlinje og se hvordan den ser ut. Og én linje.c, den ser rett og slett sånn ut. Så her ser vi - det er et veldig enkelt svar som regner ut meningen med livet. Som dere vet, er svar på det... meningen med livet er... Så denne regner ut dette svaret. Og det gjør vi ved å bare sette opp to variabler - svar og memoar. Det er altså en variabel i minnet, begge to. Og så gjør vi én institusjon her, som er svar er lik svar pluss memoar. Og det som er det viktigste med det vi gjør nå, er at... Én sånn linje i høynivåkode. Denne kan umulig gi en enkeltlinje i maskinkode. Det er ikke mulig fordi det ikke finnes instruksjoner som gjør en så kompleks operasjon i X86-instruksjonssettet. Alt dette må jo oversettes til X86-institusjoner som utføres. Grunnen til at dette er viktig, er at når vi senere skal se på sånn som multitreading... Det å switche ut prosesser... Da skal vi ta en prosess, og så skal vi stoppe den midt i det programmet den gjør. Og så skal vi sette i gang andre prosesser på samme CPU. Da er det veldig viktig for operativsystemet å ha kontroll på hvilken prosess det er som gjør hva. Hvilken instruksjon det er. Og da er det som programmerer, og når vi ser på det selv, er det lett å tenke sånn at her har vi det programmet som prosessen kjører, og her utføres det én institusjon, og den er denne linjen. Men i virkeligheten så utfører prosessene ikke høynivåkode, men de utfører maskinkode. Så det vi skal se på nå, er hvordan denne ene linjen med høynivåkode fører til flere linjer Med maskinkode. Og det vi må gjøre da, er... Vi må prøve oss igjen og kompilere den. Og så må vi se hvordan maskinkode GCC lager.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0011", "start": 1862.64, "end": 2082.7, "token_count": 595, "text": "og her utføres det én institusjon, og den er denne linjen. Men i virkeligheten så utfører prosessene ikke høynivåkode, men de utfører maskinkode. Så det vi skal se på nå, er hvordan denne ene linjen med høynivåkode fører til flere linjer Med maskinkode. Og det vi må gjøre da, er... Vi må prøve oss igjen og kompilere den. Og så må vi se hvordan maskinkode GCC lager. Så... Det jeg skal prøve nå, er å be GCC lag maskinkode av... Denne C-koden. Og så kan jeg se på den. Ja... Igjen så ser vi at her brukes referanser til minne. Sånn som den første linjen her. Legg 32 i... på denne adressen. Og 32, det var den første. Memvar var den andre som var 10. Så legg ut den. Og så ser vi at denne verdien, altså det titallet, det legges i IX. Og så gjøres den ad long-verdien i IX, som da var 10. Det legges til 10. Men verdien som lå i variabelen... Skal vi se... Hva var det jeg kalte den variabelen? Svar. Så opplegget er nå... Kompilatoren bestemmer seg for at denne adressen... Denne adressen, her skal variabelens svar ligge. Minus åtte bite fra toppen av området ram. Der skal variabelen svar ligge. Og memvar skal ligge fire bite fra toppen. Så de får nå hver sin plass i ram. Der legges tallet 10. Legges i eax med movel. Og så sier man adel... Altså legg til eax til variabelen svar. Her ser vi programmet flytter nå svar inn til eax. Og hvorfor gjør det det? Jo, det er fordi når du returnerer en metode, en fusjon, en c-fusjon, så forventes det av c at svaret, returverdien, ligger i eax. Og dermed oppfører en rutinen seg som den skal. Her er den linjen som i høynivåkode var én linje. Den er da oversatt til tre linjer av kompulatoren. Man vet ikke hva kompulatoren gjør. Vanligvis vet man ikke det. Så man må alltid regne med at kompulatoren kan dele det opp i flere linjer.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0012", "start": 2041.98, "end": 2233.5, "token_count": 597, "text": "en metode, en fusjon, en c-fusjon, så forventes det av c at svaret, returverdien, ligger i eax. Og dermed oppfører en rutinen seg som den skal. Her er den linjen som i høynivåkode var én linje. Den er da oversatt til tre linjer av kompulatoren. Man vet ikke hva kompulatoren gjør. Vanligvis vet man ikke det. Så man må alltid regne med at kompulatoren kan dele det opp i flere linjer. Og når vi senere skal drive med multitasking, så kan ikke operativsystemet vite Eller det vil si... Operativsømme vet når når det switcher fra en prosess til en annen. For nå kan vi tenke oss denne prosessen står og kjører, og så kommer det kanskje en annen prosess, som er en webserver, som skal gjøre noe helt annet. Men denne prosessen som står her og kjører, den må stoppes her og fryses. Og så må den etterpå gjøre neste operasjon. Det er avgjørende for om programmet virker som det skal. Vi skriver til og fra minne, og da kan det være andre programmer som bruker den samme variabelen med minne. Og da kan de bli sure, hvis ikke de gjør det i riktig rekkefølge. Dermed er det veldig viktig at én sånn institusjon kan føre til flere institusjoner i maskinkoden som virkelig kjøres. Og forholde seg til. Så generelt så kan man ikke vite hvordan det fungerer, men kan man på en måte tvinge Jesus og Hette til å bare lage én linje? Og i dette tilfellet så kan man ikke det heller. Man kan ikke det heller fordi... Som jeg har sagt tidligere, så er ikke det mulig å ha en sånn operasjon. Men vi kan se hva... Vi kan spørre GCC. Hvis du skal lage raskest mulig kode av denne funksjonen her, hvordan vil den se ut? Da ber vi om det, og så ser vi på den. Ja... Da får vi det samme problemet igjen. Vi får på en måte ikke se den koden, fordi at her så ser vi... Hei, høre, gse-smarte-trekka. Den ser uansett hva vi måtte finne på her. Så får vi flytte opp. Så den gjør en liten scar der og legger den. Men...", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0013", "start": 2189.14, "end": 2405.36, "token_count": 597, "text": "Hvis du skal lage raskest mulig kode av denne funksjonen her, hvordan vil den se ut? Da ber vi om det, og så ser vi på den. Ja... Da får vi det samme problemet igjen. Vi får på en måte ikke se den koden, fordi at her så ser vi... Hei, høre, gse-smarte-trekka. Den ser uansett hva vi måtte finne på her. Så får vi flytte opp. Så den gjør en liten scar der og legger den. Men... Men generelt så... Vil det være umulig å lage en kodelinje som adrerer sammen to tall i minnet på denne måten? Og det vi kan gjøre, vi kan prøve å lage en assembly-kode som gjør akkurat det. Og så se hvordan det fungerer. Skal vi se om jeg ikke har et eksempel på det... Assemblykode, som kanskje er den raskeste til å utføre akkurat dette her. Vi kan se på dette. Dette er kode som en assembly-programmerer skriver. Man kan sette seg ned og skrive assembly-kode for X86. Så kan man inkludere den i C-koden og kjøre den. Assembleren som lager maskinkoden av denne her. Og maskinkode, stort sett så oversettes den linje for linje. Så når jeg skriver move memoer %rbx, så oversettes det av assembleren til maskinkode ved at move oversettes til det nummeret move har i instruksjonssettet osv. Så det er en én-til-én-oversettelse.  Det som er forskjellig fra forrige gang, som kommer i tillegg, det er her nede, så ser vi at vi har et datafelt. Og dette er måten man legger variabler i ram på. Så denne linjen her, den sier lag en variabelsvar, og legg i ram. Eller lagre 64 bit. Så denne vil lage 8 byte som inneholder denne variabelen. Og den vil inneholde tallet 32. Og så kan vi se... Så det første jeg egentlig trenger, er å definere funksjonen én-linje. Så den global gjør at jeg kan bruke denne funksjonen fra main. Skal jeg gjøre det etterpå? Det er en standard start av funksjonen. Det jeg gjør først, er... Nå! Den dataen her nede betyr at jeg allerede har lagd tallet 32 i...", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0014", "start": 2365.66, "end": 2603.94, "token_count": 591, "text": "Og den vil inneholde tallet 32. Og så kan vi se... Så det første jeg egentlig trenger, er å definere funksjonen én-linje. Så den global gjør at jeg kan bruke denne funksjonen fra main. Skal jeg gjøre det etterpå? Det er en standard start av funksjonen. Det jeg gjør først, er... Nå! Den dataen her nede betyr at jeg allerede har lagd tallet 32 i... Nei, her har jeg lagd tallet 10 i memoer. Så det første jeg gjør, er å flytte memoer til Erbex. Og så... Jeg legger til RBX til svar. Altså til svar som da ligger i ramm. Så denne ad-operasjonen her, den utføres på et register og et tall i ramm. Så det som utføres her nå, det er at jeg tar... I tallet 10 ligger det RBX, så jeg tar det og legger det til 32, og så får jeg svar. Hårek, det er et spørsmål om du kan gjenta hva denne koden betyr? Så den sier rett og slett'sett av 64 bit', eller 'atte bytes', til denne variabelen. Jeg tror hvis... Jeg husker ikke helt hvis man... Det er mulig det er.long, tror jeg det står, hvis du skal sette av 32 bit. Hvorfor er det et sånt tegn? Det er bare en kommentar. Ok. Men det vi skal se på nå, er... Først kan vi se på hvordan vi kan kjøre denne. Den kan jeg da kjøre ved å skjøtte den sammen med én linje main. Og enl.s, sånn. Og så kjøre Adadats, og da ser vi at den funker som den skal. Så hvis jeg her nå starter med 22 i stedet, så skal vi sjekke at vi faktisk... Ja, så svarer den 32. Men... Det som er viktig her nå, er... Hva skjer hvis vi... Skal vi se... Jo... Her ser vi at man, som det står i kommentarene her... Man trenger to linjer i kode for å gjøre en høynivålinje, svar, leks, svar, pluss memoer. Men hva hadde vi trengt å gjøre dette her? Move memoer til RBX, og så add RBX? I stedet for å flytte Memvar til RBX først,", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0015", "start": 2563.14, "end": 2748.6, "token_count": 599, "text": "Ja, så svarer den 32. Men... Det som er viktig her nå, er... Hva skjer hvis vi... Skal vi se... Jo... Her ser vi at man, som det står i kommentarene her... Man trenger to linjer i kode for å gjøre en høynivålinje, svar, leks, svar, pluss memoer. Men hva hadde vi trengt å gjøre dette her? Move memoer til RBX, og så add RBX? I stedet for å flytte Memvar til RBX først, så kunne vi bare addere Memvar til svar. For da ville det blitt én linje maskinkode som gjorde akkurat den jobben med å legge sammen de to. Den linjen her, det er jo bare for å returnere. Så dette ville da gjøre den operasjonen i to. Nei, med én institusjon. Men da kan vi prøve oss og se hva som skjer hvis jeg... Ja, nå kan jeg jo... Jeg kan gjøre sånn. Og da ser vi... Og dette gjenspeiler da... Dette gjenspeiler da at X86-arkitekturen har ikke... Institusjon som kan legge sammen to referanser i minnet samtidig. Du kan ikke ta to variabler og legge sammen på den måten. Og det er rett og slett fordi at det kan ikke ha noe å gjøre. I prinsippet så kunne man ha lagd X86-arkitekturen sånn at det var mulig, men man har funnet det hensiktsmessig å ikke bruke den type operasjoner. Men det er det der viktig å vite. Koder som dette her vil da nødvendigvis medføre at man må lage to uavhengige institusjoner i maskinkoden når den kjøres. Ok, men da ser jeg vi trenger en pause. Vi kan... Vi kan ta et kvarter pause, så starter vi en... Hva blir det? 9.33. Jeg har lyst til å si noe, bare, hvis det er greit. Vi har merket fra i fjor, så var det mange som ikke fikk med seg det at når vi retter oppliggene, så hvis det er spørsmål der vi tenker at vi kan forklare litt mer, eller altså vi gir det i kommentarer i den filen... Men det var da en del som fikk tilbake svar, og så hadde ikke de da fått med seg at det var sånne kommentarer til de ulike spørsmålene.", "source": "lecture"}
{"lecture_id": "os5time1", "chunk_id": "os5time1_0016", "start": 2718.62, "end": 2904.58, "token_count": 561, "text": "Jeg har lyst til å si noe, bare, hvis det er greit. Vi har merket fra i fjor, så var det mange som ikke fikk med seg det at når vi retter oppliggene, så hvis det er spørsmål der vi tenker at vi kan forklare litt mer, eller altså vi gir det i kommentarer i den filen... Men det var da en del som fikk tilbake svar, og så hadde ikke de da fått med seg at det var sånne kommentarer til de ulike spørsmålene. At folk er klar over det. Du mener at de leser kommentarene og får med seg det? Ja, for vi har skrevet én kommentar som hovedkommentar-tilbakemelding på oppgaven. Men så hadde vi lagt inn enkeltkommentarer på de oppgavene det var aktuelt for. Der var det litt forklaringer eller tips til hva man kunne se på for å løse oppgavene. Og de er jo gjerne veldig nyttige å se på hvis vi tenker at noen ikke har forstått noe og prøver å forklare litt mer. Så det er veldig nyttig hvis folk kan se litt på de, så får de antakeligvis mye hjelp derfra. Ja, for det var mange i fjor som ikke fikk med seg at de hadde fått kommentarer. Ja. Men det er veldig bra du sa, for det er kjempeviktig. Man lærer aller meste av sine feil eller små mangler. Pass på å lese de kommentarene. At folk også får utbytte av at vi bruker den tiden. Ja, kjempebra. Og det er enda viktigere hvis en gruppe ikke får godkjent. Hvis de ikke har svart bra nok til å få godkjent. Så er det opplagt veldig viktig å se på kommentarene og rette opp av de feilene man har gjort. Det er greit å si ifra sånn at folk får det med seg. Nei. Kjempebra du sier det. Ja, da tar vi en noblere kvarter pause til femoral. Og så møtes vi igjen da til... Ja, først skal vi se på en If-test, og så skal vi gå videre med pipelining og superskalare seppuer. Hva er det som er så spesielt med denne filmen?", "source": "lecture"}
