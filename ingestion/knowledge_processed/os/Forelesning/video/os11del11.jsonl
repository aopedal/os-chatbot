{"lecture_id": "os11del11", "chunk_id": "os11del11_0000", "start": 0.0, "end": 177.88, "token_count": 594, "text": "Men vi skal også se at vi kan ha en race condition selv om det bare er én enkelt kodelinje. Og en problemstilling for dette er at én linje høynivåkode... Selv om man bare ser koden, så ser man at dette er bare én linje. Så her kan det ikke skje noe galt med race condition. Men som vi har sett tidligere, så kan... Ofte én linje med høynivåkode oversettes til flere linjer med maskinkode. I noen tilfeller er det helt nødvendig, og det vil faktisk skje. En context switch kan oppstå når som helst mellom to maskininstitusjoner. Vi har sett mange ganger at operativsystemet ikke aner noe om hva de forskjellige... Om hva de forskjellige... Institusjonene betyr, og hva de gjør. Så operativstemme bare sier OK, kjør. Institusjon. Institusjon. Institusjon. Når som helst så kan det komme en kontekstsvikt. Og hvis prosessen opererer på to forskjellige stuper, så har man operativstemme enda mindre kontroll. Så da skal vi se på et eksempel med to prosesser som opptatt... De oppdaterer én felles variabel. Og da er det en saldo de oppdaterer. Og her ser vi koden for P1. Den gjør nå kode, og så gjør den et eller annet sted. Saldo eller saldo minus mill. Så den trekker fra en million kroner på saldo. Tilsvarende gjør P2 noen operasjoner, og så øker den saldo med én. Og da er det lett å tenke sånn at ja, dette er bare én. Så om disse to kjører samtidig, så vil ikke det ha noe å si. For først trekker den fra en mil, og så ligger den til en mil. Man skulle tro at dette, spesielt hvis man har kjørt på samme CPU, at dette burde gå fint. Men hva skjer egentlig hvis det på et uheldig sted kommer en Context Switch fra P1 til P2? Jo... Da må vi tenke på maskinarkitektur og assembly, og at det faktisk prosesser gjør, er å utføre maskinkode. I dette tilfellet er det maskinkode for X86, altså rett på halvvei. Vi skal se senere at vi har det tilsvarende når vi kjører i Java.", "source": "lecture"}
{"lecture_id": "os11del11", "chunk_id": "os11del11_0001", "start": 136.2, "end": 314.44, "token_count": 596, "text": "spesielt hvis man har kjørt på samme CPU, at dette burde gå fint. Men hva skjer egentlig hvis det på et uheldig sted kommer en Context Switch fra P1 til P2? Jo... Da må vi tenke på maskinarkitektur og assembly, og at det faktisk prosesser gjør, er å utføre maskinkode. I dette tilfellet er det maskinkode for X86, altså rett på halvvei. Vi skal se senere at vi har det tilsvarende når vi kjører i Java. Og da vil disse operasjonene, sånn som saldo og saldo pluss mill... Denne operasjonen kan ikke utføres av én enkelt maskininstitusjon. Det har vi sett tidligere. X86 tillater ikke to referanser til minnet samtidig. Så på en eller annen måte, uansett hvordan man kompilerer dette, eller om man skriver assembly-kode selv, så må man gjøre noe tilsvarende dette. Man kunne gjort det kanskje ett steg videre, men noe tilsvarende som dette må skje. Men man må flytte saldo inn i et register. Og så har vi mill. Det ligger også ute i minnet. Så vi flytter det inn i BX, og så legger vi BX til AX. Da har vi lagt til saldo lik saldo pluss mill, og så legger vi resultatet ut i saldo. Og så er det tilsvarende for... Og da får vi et problem. Da kan vi risikere at en million forsvinner. Og da tenker vi oss at saldo er fem først, og så begynner vi med prosess én som trekker ifra. Den flytter saldo og mill inn i registrene sine, og så skjer en context nitch. Og da er det viktig å huske på at ved en context nitch så må alt lagres. De lagres da for den prosessen. Og så kommer prosess 2 inn. Og den vil jo gjøre det samme, men flytte saldo og mill inn i AX og BX. Og allerede her aner vi at her kan ting gå galt. Denne P2 vil da ta og legge én mill til de fem eksisterende, sånn at den får AX eller X. Så flytter den verdien ut, sånn at det blir seks millioner her ute. Før eller senere skjer det en contact switch tilbake til prosess 1. Og så tar prosess 1 sub BX minus AX. Men den bruker jo de gamle verdiene.", "source": "lecture"}
{"lecture_id": "os11del11", "chunk_id": "os11del11_0002", "start": 276.06, "end": 425.08, "token_count": 475, "text": "Og den vil jo gjøre det samme, men flytte saldo og mill inn i AX og BX. Og allerede her aner vi at her kan ting gå galt. Denne P2 vil da ta og legge én mill til de fem eksisterende, sånn at den får AX eller X. Så flytter den verdien ut, sånn at det blir seks millioner her ute. Før eller senere skjer det en contact switch tilbake til prosess 1. Og så tar prosess 1 sub BX minus AX. Men den bruker jo de gamle verdiene. Altså den tar og trekker fra saldoen. Fem minus én, og da får den fire. Og så flytter den resultatet ut i saldo, og saldoen har blitt fire. Opplagt i dette tilfellet så burde jo saldo ha blitt 5, og 1 mill. er borte. Og det er alltid kjedelig fra en saldo. Så konklusjonen her er... Dette må opplagt serialiseres. Og det man må gjøre, er å serialisere aksess til felles data. Å serialisere betyr at først gjør P1 seg ferdig med sine operasjoner med saldo, og så gjør P2 seg ferdig. Eller motsatt. Men de må ikke kunne gjøre det samtidig. Og akkurat dette kalles et kritisk avsnitt. Altså når en prosess gjør en operasjon på en felles variabel. Da er det et såkalt kritisk avsnitt. Og ideen med å serialisere er at kritisk avsnitt må fullføres i sin helhet før den andre. Og for å få til dette så fins det en rekke forskjellige metoder. Men det skal vi se på neste gang hva slags metoder man kan bruke for å fikse dette. Nå skal vi se på noen eksempler på hvordan dette ser ut i praksis. Og med Petrads. Altså for tiden.", "source": "lecture"}
