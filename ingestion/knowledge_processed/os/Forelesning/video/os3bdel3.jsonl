{"lecture_id": "os3bdel3", "chunk_id": "os3bdel3_0000", "start": 0.0, "end": 186.24, "token_count": 588, "text": "D-vippe. Dette er altså en D-vippe, som er den endelige lagringsenheten for nullarenere i en CPU. Og den er satt sammen av to D-låser, eller latcher. Og måten vi har gjort det på, er at vi har én slave som hele tiden står og leser fra master. Og master er den som tar input utenfra. Så ser vi den stiplede linjen her. Det er de to lertsene som da er slått sammen til en D-vippe. Og det som er hele clouet med denne måten å gjøre det på, er at vi har en klokke som vi skrur av og på systematisk hele tiden med en viss frekvens. Og det er dette som er den berømte CPU-klokka. Som moderne CPU-er, fra en type sin frekvens mellom 1 og 3, ofte 4 GHz. Men noe særlig høyere enn det kommer man ikke pga. fysiske begrensninger. Da blir det altfor mye varmeutvikling. Derfor vet man at hvis man overklokker CPU-er, så må man begynne med vannavkjøling, og i ekstreme tilfeller med flytende luft osv. Men det er da mye mer effektivt, og i stedet for å ha høyere frekvens, så lager man flere sepur og fordeler dem, sånn at man da har maskiner som har fire, åtte, og i servere 30 og 60 sånne sepur. Så helt uavhengige enheter som regner hver for seg. Men vi skal se på hvorfor dette her virker. Og i de simuleringene som vi gjorde i fjor med studenter på rekke osv.... Så det jeg gjorde da, var at jeg var klokke. Og det jeg gjorde da, var at jeg hvert andre sekund omtrent så løftet jeg armen opp, og da er celik én, og da er det slavene som virker. Og så tok jeg armen ned. Og da blir det en ener som er sendt til master. Og hele clouet er at disse her virker annenhver gang. Og her har jeg satt opp systematisk, og vi ser på hver av de to fastene. Så i en CPU så deles tiden inn i små klokketall. Den går av og på hele tiden. Når klokken sender inn en null,", "source": "lecture"}
{"lecture_id": "os3bdel3", "chunk_id": "os3bdel3_0001", "start": 138.92, "end": 298.34, "token_count": 598, "text": "Og det jeg gjorde da, var at jeg hvert andre sekund omtrent så løftet jeg armen opp, og da er celik én, og da er det slavene som virker. Og så tok jeg armen ned. Og da blir det en ener som er sendt til master. Og hele clouet er at disse her virker annenhver gang. Og her har jeg satt opp systematisk, og vi ser på hver av de to fastene. Så i en CPU så deles tiden inn i små klokketall. Den går av og på hele tiden. Når klokken sender inn en null, da skal alle beregninger ferdigstilles. Det kretsen gjør, sånn som AD-er osv., det skal gjøres ferdig, og så lagres det hos Master. Den lagringen må være ferdig før klokken switcher til. Når klokka er null her, kan vi tenke oss at dette er et register vi skal lagre noe i. Så har vi kanskje en addisjon eller en subtraksjon eller et eller annet som pågår, og det tar tid. De må strømme fysisk, strømme gjennom den kretsen for å komme til et svar. Og da, når klokka er null, så leser Master det som kommer inn. Kanskje sluttsvaret på den summen, dette bittet, blir da null. Og da lagres det hos Master. Da er det viktig at før klokka ringer, før klokka skifter fra null til én, så må alle disse operasjonene være ferdige. Det er det som gjør at noen komplekse operasjoner, som å dividere f.eks., det tar mer enn en klokkesyklus, og da må det tas med i beregningen at den blir ikke ferdig på én klokkesykkel. En addisjon kan typisk være ferdig på én klokkesyklus, og da kommer resultatet inn med en gang. Og dette må være ferdig før klokka switcher over til 1. For da skrus lesingen fra master av. Og da, når klokka switcher 1, så ser vi at da er det Slaven som begynner å lese. Og da er det smarte her at da leser Slaven verdien fra master. Men da er master skrudd av, så da har slaven god tid på å lese denne verdien. Og da er den sikker på at denne verdien er den endelige verdien.", "source": "lecture"}
{"lecture_id": "os3bdel3", "chunk_id": "os3bdel3_0002", "start": 264.08, "end": 371.6, "token_count": 377, "text": "En addisjon kan typisk være ferdig på én klokkesyklus, og da kommer resultatet inn med en gang. Og dette må være ferdig før klokka switcher over til 1. For da skrus lesingen fra master av. Og da, når klokka switcher 1, så ser vi at da er det Slaven som begynner å lese. Og da er det smarte her at da leser Slaven verdien fra master. Men da er master skrudd av, så da har slaven god tid på å lese denne verdien. Og da er den sikker på at denne verdien er den endelige verdien. I dette tilfellet får vi en null her hos Slaven. Og det er denne som er verdien som registeret inneholder. Og helt tilsvarende med alle andre masterslavepar, som totalt sett utgjør en vippe. Så vi ser her når klokken slår én, Slaven leser hver informaster og lagrer den. Men jeg begynner med en gang å sende ut dette resultatet, som er det gjeldende resultatet, ut i kretsen, som er koblet til utgang for nyberegninger. Og på denne måten så går klokka av og på. Og for hver sånn klokkesyklus så utføres det da én beregning. Og denne CPU-klokken er helt essensiell for å synkronisere dataene. For hver tid på klokken kan man utføre et nytt sett av beregninger. Det kan f.eks. hver dag å utføre en maskininstitusjon.", "source": "lecture"}
