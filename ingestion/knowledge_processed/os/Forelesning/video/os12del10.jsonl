{"lecture_id": "os12del10", "chunk_id": "os12del10_0000", "start": 0.0, "end": 229.4, "token_count": 596, "text": "Vi kan raskt se på hva vi gjorde forrige gang. Først og fremst hadde vi ett program, eller to program, 3d.c, som en rekke ganger, ti millioner ganger allerede... Hundre millioner ganger. Så utfører det én linje. Den én-linje-operasjonen. Det eneste den gjør, er at den øker verdien på en fellesvariabel-svar med én. Og i dette Main-programmet så ser vi at vi har to tråder. Og de to trådene, de utfører den INK-operasjonen. 100 mill. ganger øke trådverdien med én. Og det man skulle tro da, det var at... Denne tråden, eller de to trådene, til slutt da skulle få den feltsvariabelen til å være 200 mill. Men vi kan se hvordan det ser ut. Hvis vi kompilerer... 30 og c sammen med e. Og så kjører vi ADOT-out. Så ser vi at... Og dette så vi forrige gang. Resultatet blir aldri 200 000, sånn som vi ønsket det skulle bli. Og da... Det vi gjorde da, var at vi... Jo, vi var... For det første så var vi ikke sikre på om denne institusjonen ble utført bare som én linje. Fordi det var jo en sånn svar pluss, pluss. Så det kunne føre til flere linjer. Så for å være helt sikker på det, Kompilerte vi 3d.c sammen med denne assembly-linjen... Det er denne assembly-koden som bare øker... Hvor du har én linje som øker svar med én. Så hvis vi gjør det om igjen... Kompilerer den sammen med min Moldates... Så så vi fortsatt at likevel... Så ble svaret forskjellig hver gang. Men det er da vi kan komme inn med en... Med instruksjon lokk. Denne instruksjonen låser minnebussen, sånn at neste gang så er det kun én tråd som kan endre på den verdien. Så hvis vi da kompilerer den på nytt og kjører... Så ser vi nå så tar det litt lengre tid. Det foregår noe synkronisering, og minnebussen blir låst. Men heldigvis så blir svaret riktig hver eneste dag. Men... Det vi da ikke så på sist, vare hva skjer om vi kjører dette her på... ", "source": "lecture"}
{"lecture_id": "os12del10", "chunk_id": "os12del10_0001", "start": 183.44, "end": 399.84, "token_count": 587, "text": "Denne instruksjonen låser minnebussen, sånn at neste gang så er det kun én tråd som kan endre på den verdien. Så hvis vi da kompilerer den på nytt og kjører... Så ser vi nå så tar det litt lengre tid. Det foregår noe synkronisering, og minnebussen blir låst. Men heldigvis så blir svaret riktig hver eneste dag. Men... Det vi da ikke så på sist, vare hva skjer om vi kjører dette her på...  Jo, vi så også på det sist. Hva skjer om vi setter disse her på samme CPU? Tasset minus 0, den gjør nå at begge må kjøre på samme CPU. Og da ser vi... Jo, det fungerer fortsatt som det skal, selv om de kjører på samme CPU. Selv om det da kan komme en konflikt-switch. Og det at vi kjører på samme CPU, det kan vi også se med... Hvis det tar tid... Hvis det tar tid når de kjører på hver sin CPU, så ser vi her... Her er det 189 % CPU-tid. Og det er et tydelig tegn på at jo, de kjører faktisk på hver sin CPU. Mens når jeg kjører Tasset, når jeg setter dem med Tasset, så ser vi at de kjører på samme CPU og får bare 100 %. Det med time... Det var bare for å vise eksplisitt at typisk, hvis du setter i gang to tråder, så kjører de på hver sin CPU. De deler ikke på CPU-en til. Skal vi se... Men det vi skal se på nå... Det er... Hva om vi skriver kode som... Som gjør denne endringen i to operasjoner? Så... Her er det... Dette er assembly-kode som er generert av GCC. Genererer GCC kode som utfører den økningen av svar i én enkel instruksjon, eller er det flere? Her har jeg skrevet kode som eksplisitt gjør dette her i tre operasjoner, sånn som man kan risikere. Så dette her er da tre operasjoner for å endre svar. Man flytter først svarvarabelen over i... Og så flytter man svaret ut igjen. Og hvis vi kjører denne koden, så skal vi se at da... Da kan man også få problemer hvis man... Hvis man har en contex-witch.", "source": "lecture"}
{"lecture_id": "os12del10", "chunk_id": "os12del10_0002", "start": 358.92, "end": 405.04, "token_count": 160, "text": "i én enkel instruksjon, eller er det flere? Her har jeg skrevet kode som eksplisitt gjør dette her i tre operasjoner, sånn som man kan risikere. Så dette her er da tre operasjoner for å endre svar. Man flytter først svarvarabelen over i... Og så flytter man svaret ut igjen. Og hvis vi kjører denne koden, så skal vi se at da... Da kan man også få problemer hvis man... Hvis man har en contex-witch. Altså hvis man med Tasep tvinger begge til å kjøre på samme suppu, men likevel kan man...", "source": "lecture"}
