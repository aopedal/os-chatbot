{"lecture_id": "os9del8", "chunk_id": "os9del8_0000", "start": 0.02, "end": 191.08, "token_count": 593, "text": "Skal vi se lite grann på prosessforløpet... Vi har jo vært mye inne på dette tilsvarende som i den vaffelsimuleringen. Men det er kanskje et par ting... noen begreper som vi kan ta med. Et prosessforløp starter som en ny prosess. Det er sånn alle prosesser starter. Og så legges det i ready-list. I vaffelsimuleringen var forelesning og vaffelprosessen... De lå helt inne i ready-list og ønsket å kjøre. Og så det typiske interruptet som kom da, var... Når det er ready-list, så er det en dispatcher. Det er den delen av scheduleren som velger hvilken prosess som skal kjøre. Dispatcheren setter i gang og kjører prosessen. Når den er i rønningtilstand, så kan den få et interrupt. Det typiske interruptet er timer interrupt. Hvert hundredels sekund vil man kunne bli avbrutt. Men så kan scooteren også velge å... Hvis det ikke er noen andre interrupt, så kan man velge å gi flere tics til samme prosess, sånn at den kjører litt lenger enn minste tidsevne. Så kan man også få IO. Det er sånn man venter på melkemannen, eller noe fra disk, eller noe som tar lang tid. Så blir den tatt ut fra Rønning og satt i en ventingkø. Da er den heller ikke i ready-list, for shelleren leter hele tiden etter de prosessene som er klare til å kjøre. Det er de som får tid. Det var også derfor de to jobbene som var nicet, fikk stå i Rønning. Fordi det ikke var noen andre i Ready-list på den CPU-en. Så det er klart, dette er én CPU. Dette er én enkel CPU, så vi har... Hvis du har flere CPU-er, så vil du ha én kø for hver CPU. Vi kan se... Jeg har en liten demo av dette her også, som ligger på... Som ligger på kurssiden. Det er en liten demo som viser hele det forløpet... Med at du har prosesser som står i ReadyList... Og så har du Dispatcher, eller Shedular Dispatcher... Som tar jobber fra ReadyList og ut til Running. Igjen så har denne simuleringen her... Eller denne illustrasjonen... Men med en gang du har flere CPU-er, kan kjernetråder også kjøres på mange CPU-er samtidig.", "source": "lecture"}
{"lecture_id": "os9del8", "chunk_id": "os9del8_0001", "start": 139.98, "end": 241.98, "token_count": 265, "text": "Vi kan se... Jeg har en liten demo av dette her også, som ligger på... Som ligger på kurssiden. Det er en liten demo som viser hele det forløpet... Med at du har prosesser som står i ReadyList... Og så har du Dispatcher, eller Shedular Dispatcher... Som tar jobber fra ReadyList og ut til Running. Igjen så har denne simuleringen her... Eller denne illustrasjonen... Men med en gang du har flere CPU-er, kan kjernetråder også kjøres på mange CPU-er samtidig. Så dermed kan du få en enda mer effektiv utnyttelse av de CPU-ene du har. Og brukerprogrammet vil da kunne kjøre helt i den. Den kan kjøre på en annen CPU og så skritulere dette. Men dette bildet er, har jeg tenkt, én CPU som står og kjører. Her var det en som måtte vente. Og da kommer den tilbake i Redelist når den er ferdig med å vente. Det er herfra at skredderne har ledd dispatcheren fra Redelist hele tiden. Plukkegrabber.", "source": "lecture"}
