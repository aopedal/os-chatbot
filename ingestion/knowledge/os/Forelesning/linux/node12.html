<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>11 Forelesning 2/4-24(2 timer). Windows PowerShell</TITLE>
<META NAME="description" CONTENT="11 Forelesning 2/4-24(2 timer). Windows PowerShell">
<META NAME="keywords" CONTENT="linux">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY >
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html639"
  HREF="node12.html#SECTION000121000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Windows PowerShell</A>
<UL>
<LI><A ID="tex2html640"
  HREF="node12.html#SECTION000121100000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Verdens korteste Hello World program</A>
</UL>
<BR>
<LI><A ID="tex2html641"
  HREF="node12.html#SECTION000122000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN> To viktige kommandoer</A>
<LI><A ID="tex2html642"
  HREF="node12.html#SECTION000123000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN> Likheter med bash</A>
<UL>
<LI><A ID="tex2html643"
  HREF="node12.html#SECTION000123100000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Omdirigering</A>
</UL>
<BR>
<LI><A ID="tex2html644"
  HREF="node12.html#SECTION000124000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">4</SPAN> Variabler</A>
<LI><A ID="tex2html645"
  HREF="node12.html#SECTION000125000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">5</SPAN> Environmentvariabler</A>
<LI><A ID="tex2html646"
  HREF="node12.html#SECTION000126000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">6</SPAN> Apostrofer</A>
<LI><A ID="tex2html647"
  HREF="node12.html#SECTION000127000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">7</SPAN> Objekter og Get-Member</A>
<LI><A ID="tex2html648"
  HREF="node12.html#SECTION000128000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">8</SPAN> Undersøke typen til et objekt</A>
<LI><A ID="tex2html649"
  HREF="node12.html#SECTION000129000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">9</SPAN> ps</A>
<LI><A ID="tex2html650"
  HREF="node12.html#SECTION0001210000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">10</SPAN> Foreach</A>
<LI><A ID="tex2html651"
  HREF="node12.html#SECTION0001211000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">11</SPAN> Installasjon av programmer fra PowerShell</A>
<LI><A ID="tex2html652"
  HREF="node12.html#SECTION0001212000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">12</SPAN> Select-String, PowerShells svar på grep</A>
<LI><A ID="tex2html653"
  HREF="node12.html#SECTION0001213000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">13</SPAN> Logiske operatorer</A>
<LI><A ID="tex2html654"
  HREF="node12.html#SECTION0001214000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">14</SPAN> Windows script editor</A>
<LI><A ID="tex2html655"
  HREF="node12.html#SECTION0001215000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">15</SPAN> Summere antall bytes i filer</A>
<LI><A ID="tex2html656"
  HREF="node12.html#SECTION0001216000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">16</SPAN> Stoppe prosesser med et gitt navn: nkill.ps1</A>
<LI><A ID="tex2html657"
  HREF="node12.html#SECTION0001217000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">17</SPAN> PowerShell oneliner</A>
<LI><A ID="tex2html658"
  HREF="node12.html#SECTION0001218000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">18</SPAN> Sort-Object og Select-Object</A>
<LI><A ID="tex2html659"
  HREF="node12.html#SECTION0001219000000000000000"><SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">19</SPAN> DateTime</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION000120000000000000000">
<SPAN CLASS="arabic">11</SPAN> Forelesning 2/4-24(2 timer).   Windows PowerShell</A>
</H1>

<P>
Opptak av forelesningen inndelt etter temaer:

<P>
<A ID="tex2html147"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del6.mp4">linux11del6.mp4</A>
(09:58) Windows PowerShell, introduksjon-slides

<BR><A ID="tex2html148"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del7.mp4">linux11del7.mp4</A>
(07:11) Demo av Windows PowerShell i Windows 10 i Virtual Box, Set-ExecutionPolicy

<BR><A ID="tex2html149"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del8.mp4">linux11del8.mp4</A>
(03:48) PowerShell-demo: Get-Command og Get-Help

<BR><A ID="tex2html150"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del9.mp4">linux11del9.mp4</A>
(03:04) PowerShell-demo: likheter med Linux bash

<BR><A ID="tex2html151"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del10.mp4">linux11del10.mp4</A>
(02:58) PowerShell-demo: variabler og environment-variabler

<BR><A ID="tex2html152"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del11.mp4">linux11del11.mp4</A>
(03:21) PowerShell-demo: Apostrofer og $(ls $dir)

<BR><A ID="tex2html153"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del12.mp4">linux11del12.mp4</A>
(05:38) PowerShell-demo: Fil-objekter (viktig!)

<BR><A ID="tex2html154"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del13.mp4">linux11del13.mp4</A>
(06:18) PowerShell-demo: Prosess-objekter (viktig!)

<BR><A ID="tex2html155"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del14.mp4">linux11del14.mp4</A>
(02:46) PowerShell-demo: Array av Objekter

<BR><A ID="tex2html156"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del15.mp4">linux11del15.mp4</A>
(01:42) PowerShell-demo: Telle prosesser

<BR><A ID="tex2html157"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del16.mp4">linux11del16.mp4</A>
(05:22) PowerShell-demo: foreach og ForEach-Object onelinere

<BR><A ID="tex2html158"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux11del17.mp4">linux11del17.mp4</A>
(03:00) PowerShell-demo: Select-String som erstatning for Linux-grep

<BR><A ID="tex2html159"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del5.mp4">linux12del5.mp4</A>
(07:02) Demo: Scripting i PowerShell ISE, summasjon av fil-størrelser

<BR><A ID="tex2html160"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del6.mp4">linux12del6.mp4</A>
(12:19) Demo: Scripting, drep prosesser, kill.ps1, argumenter

<BR><A ID="tex2html161"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del78.mp4">linux12del7.mp4</A>
(05:17) Demo: PowerShell onelinere 
<A ID="tex2html162"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del10.mp4">linux12del9.mp4</A>
(07:55) Demo: Sort-Object og Select-Object, Measure-Command (tar tiden)

<BR><A ID="tex2html163"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del11.mp4">linux12del10.mp4</A>
(06:33) Demo: DateTime-objekter

<BR><A ID="tex2html164"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux12del12.mp4">linux12del11.mp4</A>
(08:29) Demo: Finne filer som ble endret i et gitt tidsrom

<BR>
<P>

<H2><A ID="SECTION000121000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Windows PowerShell</A>
</H2>
Windows PowerShell er, som bash for Linux, både kommandolinje og scriptspråk for Windows og ble innført av Microsoft i 2006. Fra og med Windows 2008 Server og Windows 7 har PowerShell vært installert som default. Det finnes en rekke aliaser som gjør at man kommer veldig langt med å skrive vanlige bash kommandoer.

<P>
Det finnes fire kategorier kommandoer i PowerShell:
<table width="90%"><tr><td align="right" valign="top">Cmdlets</td><td valign="top">&nbsp;Tilsvarer bash shell builtins som pwd og echo  (og er en del av shellet). De fleste kommandoer er Cmdlets.</td></tr>
<tr><td align="right" valign="top">Applications</td><td valign="top">&nbsp;Eksisterende Windowsprogrammer som ping og ipconfig. (tilsvarer /bin/mv)</td></tr>
<tr><td align="right" valign="top">Scripts</td><td valign="top">&nbsp;Tekstfiler med endelse .ps1 (også for PS versjon 2 og høyere), tilsvarer bash-script</td></tr>
<tr><td align="right" valign="top">Functions</td><td valign="top">&nbsp;Tilsvarer funksjoner i bash
</td></tr></table>

Operativsystemet Windows er i utgangspunktet objektorientert og konfigurasjonen er ikke basert på tekstfiler 
som i Linux, men på binære filer og databaser. Derfor må et kraftig Windows shell også være objektorientert og 
det er PowerShell. Som bash er PowerShell bygd opp av mange små programmer eller Cmdlets som gir en 
fleksibel måte å løse oppgaver på. Under Linux har vi sett at disse kommandoene kan settes sammen med pipes og 
omdirigering og det er da tekst som streames mellom kommandoene. PowerShell tar dette ett steg videre og 
sender hele objekter mellom Cmdlets med pipes.

<P>

<H3><A ID="SECTION000121100000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Verdens korteste Hello World program</A>
</H3>
Hvis du har problemer med keyboard-tegn og norsk tastatur, kan du velge Settings <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.12ex; " SRC="img4.png"
 ALT="$\rightarrow$"></SPAN> Time &amp; Language
<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.12ex; " SRC="img4.png"
 ALT="$\rightarrow$"></SPAN> Region &amp; Language <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.12ex; " SRC="img4.png"
 ALT="$\rightarrow$"></SPAN> norsk <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.12ex; " SRC="img4.png"
 ALT="$\rightarrow$"></SPAN> options og så legge til US keyboard.
Så kan du switche mellom keyboard med Windows-tasten og space.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

"Hello World!"
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Lagrer man dette som en fil med for eksempel navnet <code>hello.ps1</code> har man laget verdens korteste Hello World program. 
PowerShell script må ha filendelse <code>ps1</code>. Det gjelder også for versjon 2 av PowerShell. Med tanke på script som lastes ned 
av virus og ormer er det i utgangspunktet ikke lov å kjøre script i det hele tatt fra PowerShell. Men hvis du setter 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS&gt; set-executionPolicy remoteSigned
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
vil du kunne kjøre egne script. Men dette får du bare lov til å gjøre hvis du kjører PowerShell med 
"elevated privileges", det vil si som administrator. Det kan du få til ved å trykke Windows-tasten, skrive
"PowerShell" og så høyreklikke og velge "Run as administrator".

<P>
Hvis PowerShell scriptet åpner et nytt vindu som umiddelbart forsvinner, slik at du ikke ser "Hello World!"-teksten,
kan du finne noen mulige løsninger her:
<A ID="tex2html165"
  HREF="https://stackoverflow.com/questions/1337229/powershell-window-disappears-before-i-can-read-the-error-message">powershell-window-disappears</A>
.

<P>

<H2><A ID="SECTION000122000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN> To viktige kommandoer</A>
</H2>
De kanskje to viktigste kommandoene i powershell er de som gir deg hjelp: "Get-Command" gir liste over alle kommandoer og "Get-Help kommando" gir informasjon om kommandoene. Disse kan sammenliknes med "man" og "help" i bash.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Get-Command

CommandType     Name                                               Version    Source            
-----------     ----                                               -------    ------            
Alias           Add-ProvisionedAppxPackage                         3.0        Dism              
Alias           Apply-WindowsUnattend                              3.0        Dism              
Alias           Disable-PhysicalDiskIndication                     2.0.0.0    Storage           
Function        A:                                                                              
Function        Add-BCDataCacheExtension                           1.0.0.0    BranchCache       
Function        Add-BitLockerKeyProtector                          1.0.0.0    BitLocker         
Cmdlet          Read-Host                                          3.1.0.0    Microsoft.Power...
Cmdlet          Receive-DtcDiagnosticTransaction                   1.0.0.0    MsDtc             
...
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Uten argument listes alle kommandoene

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Get-Command ls

CommandType     Name                                               Version    Sourc
                                                                              e    
-----------     ----                                               -------    -----
Alias           ls -&gt; Get-ChildItem                                                




CommandType     Name                            Definition
-----------     ----                            ----------
Alias           ls                              Get-ChildItem
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Med kommando som argument listes informasjon om kommandoen.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Get-Help Get-ChildItem


NAME
    Get-ChildItem

SYNOPSIS
    Gets the items and child items in one or more specified locations.


SYNTAX
    Get-ChildItem [[-Path] &lt;string[]&gt;] [[-Filter] &lt;string&gt;] [-Exclude &lt;string[]
...
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
For å få informasjon om alle kommandoer, må du først kjøre Update-Help som Administrator.

<P>

<H2><A ID="SECTION000123000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN> Likheter med bash</A>
</H2>
Det er definert en rekke alias som gjør at mange av de kjente bash-kommandoene kan brukes direkte i powershell. Dette gjør at en del bash-script lett 
kan oversettes. Her er noen av de vanligste, kommandoen <code>alias</code> gir alle som er definert:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

set-alias cat        get-content
set-alias cd         set-location
set-alias cp         copy-item
set-alias history    get-history
set-alias kill       stop-process
set-alias ls         get-childitem
set-alias mv         move-item
set-alias ps         get-process
set-alias pwd        get-location
set-alias rm         remove-item
set-alias rmdir      remove-item
set-alias echo       write-output
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H3><A ID="SECTION000123100000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Omdirigering</A>
</H3>
Omdirigering og pipes virker på samme måte som i bash. For eksempel er 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS&gt; ls | sort &gt; fil.txt
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
en gyldig powershell-kommando. Vanlig output og feilmeldinger er også delt på samme måte, slik at følgende virker som i bash: 
<TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="LEFT">omdirigering</TH>
<TH CLASS="LEFT">virkning</TH>
</TR>
<TR><TD CLASS="LEFT"><code> &gt; fil.txt</code></TD>
<TD CLASS="LEFT">omdirigerer stdout til fil.txt. Overskriver</TD>
</TR>
<TR><TD CLASS="LEFT"><code> &gt;&gt; fil.txt</code></TD>
<TD CLASS="LEFT">legger stdout etter siste linje i  fil.txt</TD>
</TR>
<TR><TD CLASS="LEFT"><code> Write-Error "oops" 2&gt; $null</code></TD>
<TD CLASS="LEFT">sender stderr til "/dev/null"</TD>
</TR>
<TR><TD CLASS="LEFT"><code> &gt; fil.txt 2&gt; err.txt</code></TD>
<TD CLASS="LEFT">stdout -&gt; fil.txt stderr -&gt; err.txt</TD>
</TR>
</TABLE>
<BR>
<BR>
<BR>
Men som vi skal se senere er det ikke tekst som streames mellom Cmdlets, men hele objekter!

<P>

<H2><A ID="SECTION000124000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">4</SPAN> Variabler</A>
</H2>
Variabler lages som i PHP ved å sette et $-tegn foran navnet:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $var = "min nye var"
PS &gt; echo $var
min nye var
PS &gt; $var
min nye var
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Slike variabler er lokale.
PowerShell er ikke så nøye på mellorom som bash, men teksstrenger må skrives innenfor apostrofer. 
Legg merke til at echo er overfløding, en tekststreng blir skrevet ut selvom du ikke skriver echo først.

<P>
Cmdlet'en Get-Variable (kan forkortes til gv) viser hvilke variabler som er definert, følgende viser et utdrag:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

 
PS &gt; Get-Variable

Name                           Value
----                           -----
MaximumErrorCount              256
MaximumVariableCount           4096
MaximumFunctionCount           4096
MaximumAliasCount              4096
null
false                          False
true                           True
PWD                            C:\Documents and Settings\group10\My Documents\ps
MaximumHistoryCount            4000
HOME                           C:\Documents and Settings\group10
PSVersionTable                 {CLRVersion, BuildVersion, PSVersion, PSCompatible...
PID                            3976
Culture                        nb-NO
ShellId                        Microsoft.PowerShell
PSHOME                         C:\WINDOWS\system32\WindowsPowerShell\v1.0\
ErrorView                      NormalView
NestedPromptLevel              0
OutputEncoding                 System.Text.ASCIIEncoding
CommandLineParameters          {}
args                           {}
PROFILE                        C:\Documents and Settings\group10\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
var                            min nye var
dir                            mappe
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000125000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">5</SPAN> Environmentvariabler</A>
</H2>
I tillegg finnes det et sett med environmentvariabler i  namespace'et env: som kan listes ut med ls:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; ls env:
Name                           Value
----                           -----
Path                           C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32...
TEMP                           C:\DOCUME~1\group10\LOCALS~1\Temp
PATHEXT                        .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;....
USERDOMAIN                     IU-VM
PROCESSOR_ARCHITECTURE         x86
SystemDrive                    C:
APPDATA                        C:\Documents and Settings\group10\Application Data
windir                         C:\WINDOWS
TMP                            C:\DOCUME~1\group10\LOCALS~1\Temp
USERPROFILE                    C:\Documents and Settings\group10
ProgramFiles                   C:\Program Files
HOMEPATH                       \Documents and Settings\group10
COMPUTERNAME                   IU-VM
USERNAME                       group10
NUMBER_OF_PROCESSORS           1
PROCESSOR_IDENTIFIER           x86 Family 16 Model 4 Stepping 2, AuthenticAMD
SystemRoot                     C:\WINDOWS
ComSpec                        C:\WINDOWS\system32\cmd.exe
LOGONSERVER                    \\IU-VM
ALLUSERSPROFILE                C:\Documents and Settings\All Users
OS                             Windows_NT
HOMEDRIVE                      C:
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette betyr at det for eksempel finnes en variabel   $env:path

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $env:path
C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\system32\WindowsP
owerShell\v1.0\;C:\Program Files\OpenSSH\bin;C:\lcc\bin
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Legg merket til at variabler og cmdlets ikke er case-sensitive som de er i bash. Tilsvarende kan man liste 
funksjoner og aliaser med <code>ls function:</code> og <code>ls alias:</code>

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $alias:pwd
Microsoft.PowerShell.Management\Get-Location
PS &gt; &amp; $alias:pwd

Path
----
C:\Documents and Settings\group10\My Documents\ps
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Her ser vi at en &amp; i starten av en linje gjør at innholdet av en streng kjøres. Nyttig om man må ha 
apostrofer rundt en path fordi den inneholder mellomrom.

<P>

<H2><A ID="SECTION000126000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">6</SPAN> Apostrofer</A>
</H2>
Apostrofer virker stort sett som i bash:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS&gt; $dir="mappe"

PS&gt;  echo 'ls $dir'     #    ' -&gt; Gir eksakt tekststreng
ls $dir

PS&gt;  echo "ls $dir"     #    " -&gt; Variabler substitueres; verdien av $dir skrives ut.
ls mappe

PS&gt; echo "Filer: $(ls $dir)"        #  utfører kommandoen \verb+ls mappe+ inne i strengen
fil fil2.txt
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000127000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">7</SPAN> Objekter og Get-Member</A>
</H2>
Det som virkelig gir &rdquo;Power&rdquo; i PowerShell er at hele objekter sendes mellom Cmdlets. Dette gjør det 
veldig intuitivt og enkelt å trekke ut informasjon fra for eksempel lister av prosesser og filer. Og det geniale 
er at det kan gjøres på mer eller mindre samme måte uansett hvilke objekter vi ser på, objektene har bare litt andre egenskaper og metoder.

<P>
For eksempel returnerer en listing av filene i en mappe

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; ls
Mode                LastWriteTime     Length Name
----                -------------     ------ ----
d----        02.03.2010     20:38            mappe
-a---        01.03.2010     12:26         73 ps.ps1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
ikke bare tekst som viser filene i mappen slik som i bash. Egentlig returneres et array av 
objekter, ett for hver fil eller mappe. Om man ønsker kun et objekt for filen <code>ps.ps1</code>, 
kan man slik legge det i variabelen <code>$fil</code>:  

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $fil = ls ps.ps1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Hvis man på kommandolinjen nå skriver <code>$fil.</code> kan man tabbe seg gjennom alle 
metoder og properties for dette objektet. En måte å vise alle på en gang, er å sende 
objektet til cmdlet'en <code>Get-Member</code>:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $fil | Get-Member

   TypeName: System.IO.FileInfo

Name                      MemberType     Definition
----                      ----------     ----------
Mode                   CodeProperty System.String Mode{get=Mode;}
AppendText         Method          System.IO.StreamWriter AppendText()
Delete                  Method          System.Void Delete()
PSPath                NoteProperty System.String PSPath=Microsoft.PowerShel...
CreationTime       Property        System.DateTime CreationTime {get;set;}
DirectoryNam      Property        System.String DirectoryName {get;}
Extension             Property        System.String Extension {get;}
FullNa                 Property         System.String FullName {get;}
IsReadOnly          Property         System.Boolean IsReadOnly {get;set;}
LastAccessTime  Property         System.DateTime LastAccessTime {get;set;}
LastWriteTime    Property         System.DateTime LastWriteTime {get;set;}
Length                 Property         System.Int64 Length {get;}
Name                   Propertty        System.String Name {get;}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Bare et lite utvalg er vist over. 
Dermed kan man for eksempel få tak i tidspunktet filen sist ble aksessert, lest eller sett på:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $fil.LastAccessTime
1. mars 2010 12:26:50
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette tidspunktet er også et objekt, et System.DateTime objekt. På samme måte kan dette 
objektet tilordnes en variabel 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $date = $fil.LastAccessTime
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Og denne kan vi lese ut metoder og egenskaper fra med <code>Get-Member</code>:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $date | Get-Member
   TypeName: System.DateTime

Name                 MemberType     Definition
----                 ----------     ----------
AddHours             Method         System.DateTime AddHours(Double value)
IsDaylightSavingTime Method         System.Boolean IsDaylightSavingTime()
ToLongDateString     Method         System.String ToLongDateString()
ToLongTimeString     Method         System.String ToLongTimeString()
DayOfWeek            Property       System.DayOfWeek DayOfWeek {get;}
DayOfYear            Property       System.Int32 DayOfYear {get;}
Hour                 Property       System.Int32 Hour {get;}
Millisecond          Property       System.Int32 Millisecond {get;}
Minute               Property       System.Int32 Minute {get;}
Month                Property       System.Int32 Month {get;}
Second               Property       System.Int32 Second {get;}
TimeOfDay            Property       System.TimeSpan TimeOfDay {get;}
Year                 Property       System.Int32 Year {get;}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Igjen er bare et lite utvalg vist. Dermed kan man trekke ut disse egenskapene, for eksempel 
året: 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $date.year
2010
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Det er også mulig å gjøre dette direkte uten å gå veien om et dato-objekt:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $fil.LastAccessTime.year
2010
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Man kan til og med trekke det ut direkte fra kommandoen som listet filen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; (ls ps.ps1).LastAccessTime.year
2010
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000128000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">8</SPAN> Undersøke typen til et objekt</A>
</H2>
Med get-member vil vi få listet opp alle egenskaper (properties) og metoder som er tilgjengelige på det aktuelle objektet. Dette er viktig informasjon, fordi det forteller oss hva vi kan gjøre med objektene.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; ls | get-member

   TypeName: System.IO.FileInfo

Name                      MemberType     Definition
----                      ----------     ----------
...
Length                    Property       System.Int64 Length {get;}
Name                      Property       System.String Name {get;}
...
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Øverst ser vi at typen til det som returneres fra ls er <code>System.IO.FileInfo</code>. Men vi ser bare typen til det siste elementet på denne måten. Kommandoen ls returnerer altså et array av FileInfo-objekter. Dette kan vi se ved å kalle metoden <code>GetType()</code> på returverdien slik:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; (ls).getType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                                 System.Array
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
For mer informasjon om de ulike typene, kan man søke dem opp på Microsofts dokumentasjonssider, https://msdn.microsoft.com/. Søker man for eksempel etter <code>System.Array</code> får man som første treff <code>Array Class</code>. Her finner du definisjonen av klassen og kodeeksempler i flere språk.

<P>
Om man kaller metoden getType for ett av elementene får man vite hva slags type dette er:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; (ls)[1].getType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     FileInfo                                 System.IO.FileSystemInfo
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000129000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">9</SPAN> ps</A>
</H2>
Når man istedet for å liste filer med ls lister prosesser med ps, gir dette også objekter.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; ps
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    194          6         3276           6012      49         1,20        4936  Adobe_Updater
    102          5         1156            360      32          0,28       1264   alg
    320          5         1528            908      22         1,28        696     csrss
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Det som returneres fra ps er et array av prosessobjekter der første element er første 
prosess i listingen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $ps = ps
PS &gt; $ps[0].name
Adobe_Updater
PS &gt; $ps[0].id
4936
PS &gt; $ps[1].name
alg
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Lengden av dette arrayet vil da gi antall prosesser på maskinen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS &gt; $ps.length
44
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION0001210000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">10</SPAN> Foreach</A>
</H2>
Det er først når man bruker mulighetene objektorienteringen gir i script at PowerShell virkelig viser sin styrke:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

foreach ($ls in ls *.ps1){
    $sum += $ls.length
}
$sum
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
eller i onelinere som dette:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls | ForEach-Object {$sum += $_.Length}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Disse mulighetene vil bli utdypet i senere avsnitt.

<P>

<H2><A ID="SECTION0001211000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">11</SPAN> Installasjon av programmer fra PowerShell</A>
</H2>
På samme måte som man installerer programmer i et Linux shell med apt-get, kan man installere programmer i PowerShell med Chocolatey; eller bare choco som kommandoen heter. Da må man først installere choco og det kan i PowerShell gjøres med:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

wget -OutFile install.ps1 http://chocolatey.org/install.ps1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
hvor <code>wget</code> er et alias for <code>Invoke-WebRequest</code> og virker på omtrent samme måte som i Linux. Etter å ha kjørt dette installasjons-scriptet, kan man installere annen programvare som ssh og scp med:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; choco install openssh
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
og deretter bruke det fra PowerShell på samme måte som man bruker det fra bash i Linux.

<P>

<H2><A ID="SECTION0001212000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">12</SPAN> Select-String, PowerShells svar på grep</A>
</H2>

<P>
For å gå igjennom et array av objekter, som for eksemple alle prosessene som listes med ps, er foreach en meget nyttig konstruksjon. Allikevel er det viktig å sjekke hva mer man kan gjøre med kommandoen ps, før man overkompliserer oppgaven. I bash bruker vi kommandoen

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ ps | grep power
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
for å finne alle prosesser med "power" i navnet. Vi har en funksjon i powershell som likner på grep, nemlig <code>select-string</code> eller kortversjonen <code>sls</code>. Men kommandoen <code>ps | select-string power</code> returnerer ikke helt det vi ønsker. Grunnen til dette er at kommandoen <code>ps</code>, i PowerShell, returnerer et array av objekter, og ikke en tekst. For å gjøre tilsvarende søk i PowerShell skriver man heller følgenede:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ ps power*

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
     48       2      764       2696    28     0,05   2752 poweroff
    257       5    28968      28196   135     0,47   5412 powershell
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Her sender vi ordet power, med wildcardet *, til kommandoen ps, som er et alias for kommandoen get-process. Sjekk dette ved å skrive <code>get-command ps</code>. For detaljert informasjon om hva du kan gjøre med get-process, skriv <code>get-help get-process -detailed</code>

<P>
Fra Linux er vi vant til å velge ut linjer som inneholder et gitt ord med kommandoen <code>grep</code>. 
Det finnes ikke en helt tilsvarende PowerShell-kommando og ofte bruker man andre metoder for å oppnå det samme.
Men det er mulig å bruke CmdLet'en <code>Select-String</code> som ligner:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls | Select-String fil
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
er et forsøk på å velge alle linjer som inneholder ordet <code>fil</code> i ls-listingen. Men Select-String virker på
objekter og går derfor inn i mapper i listingen og det virker ikke helt som ønsket. Ved å pipe output fra
ls til Out-String gjøres objekt-strømmen om til vanlige strenger og man får det til å virke som
i bash:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls | Out-String -Stream | Select-String fil
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Man må også ha med opsjonen <code>-Stream</code> til <code>Out-String</code> for at det skal virke.

<P>

<H2><A ID="SECTION0001213000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">13</SPAN> Logiske operatorer</A>
</H2>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="LEFT">Operator</TH>
<TH CLASS="LEFT">Betydning</TH>
</TR>
<TR><TD CLASS="LEFT">-lt</TD>
<TD CLASS="LEFT">Less than</TD>
</TR>
<TR><TD CLASS="LEFT">-gt</TD>
<TD CLASS="LEFT">Greater than</TD>
</TR>
<TR><TD CLASS="LEFT">-le</TD>
<TD CLASS="LEFT">Less than or equal to</TD>
</TR>
<TR><TD CLASS="LEFT">-ge</TD>
<TD CLASS="LEFT">Greater than or equal to</TD>
</TR>
<TR><TD CLASS="LEFT">-eq</TD>
<TD CLASS="LEFT">Equal to</TD>
</TR>
<TR><TD CLASS="LEFT">-ne</TD>
<TD CLASS="LEFT">Not equal to</TD>
</TR>
</TABLE> 
<BR>
<BR>
<P>
<TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="LEFT">Operator</TH>
<TH CLASS="LEFT">Betydning</TH>
</TR>
<TR><TD CLASS="LEFT">-not</TD>
<TD CLASS="LEFT">Not</TD>
</TR>
<TR><TD CLASS="LEFT">!</TD>
<TD CLASS="LEFT">Not</TD>
</TR>
<TR><TD CLASS="LEFT">-and</TD>
<TD CLASS="LEFT">And</TD>
</TR>
<TR><TD CLASS="LEFT">-or</TD>
<TD CLASS="LEFT">Or</TD>
</TR>
</TABLE> 
<BR>
<BR>
<P>
Merk at i powershell kan vi bruke logiske operatorer rett i shellet. I bash vil <code> 2 -lt 3 </code> 
ikke returnere noen ting, fordi det er exit-verdien av denne kommandoen som indikerer om testen slo til eller ikke. I powershell er dette litt enklere:

<P>
<TABLE><TR><TD><PRE >

PS &gt; 2 -eq 3
False
PS &gt; 2 -lt 3
True
PS &gt; "hei" -eq "hei"
True
PS &gt; -not ("hei" -eq "heia")
True
</PRE></TD></TR></TABLE>

<P>

<H2><A ID="SECTION0001214000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">14</SPAN> Windows script editor</A>
</H2>
 En mulighet er å bruke Windows PowerShell ISE til å skrive PowerShell script. Da kan man få opp ett PowerShell vindu samtidig med et editor-vindu og kjøre scriptet ved å taste F5. Det finnes også mange generelle tekst-editorer for Windows som stort sett er GUI-baserte.

<P>
En annen mulighet er å installere <code>nano</code> med <code>choco install nano</code> og deretter bruke <code>nano</code> fra kommandolinjen slik som i et Linux shell.

<P>

<H2><A ID="SECTION0001215000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">15</SPAN> Summere antall bytes i filer</A>
</H2>
Output fra PowerShell CmdLets er som vi har sett ikke bare tekst som i et bash-shell, men objekter.
Dermed kan man ved hjelp av <code>foreach</code> gå igjennom alle objektene og trekke ut den informasjon man trenger:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

foreach ($ls in ls *.ps1){
    $sum += $ls.length
}
$sum
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Foreach er et alias for ForEach-Object, men når det står i starten av en setning, er det
et PowerShell statement eller reservert ord, slik som if og for. 
Summasjon som inkluderer filer i alle undermapper får man med opsjonen -r til ls:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

foreach ($ls in ls -r){
    if($ls.Extension -eq ".ps1"){
	$sum += $ls.length
    }
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Egentlig er <code>ls -r</code> et alias for <code>Get-ChildItem -Recurse</code>. 

<P>

<H2><A ID="SECTION0001216000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">16</SPAN> Stoppe prosesser med et gitt navn: nkill.ps1</A>
</H2>
En stor fordel med at kommandoene gir objekter er at man kan bruke de samme metodene på mange
forskjellige typer kommandoer, for eksempel på <code>ps</code> som er et alias for <code>Get-Process</code>:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$s = $args[0] # Første argument

foreach ($p in ps ){
   foreach ($name in $args){
      if ($p.name -eq $name){
         kill -whatif $p.id
      }
   }
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Opsjonen <code>-whatif</code> til <code>kill</code> er nyttig for å teste ut hva som kommer til å skje hvis
man kjører scriptet. Når scriptet virker som det skal, kan man fjerne <code>-whatif</code>.
En tilsvarende oneliner kan lages slik:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

 ps | foreach {	if($_.name -eq "navn"){kill $_.id -whatif}}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION0001217000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">17</SPAN> PowerShell oneliner</A>
</H2>
Ofte kan man lage tilsvarende kraftige konstruksjoner med bare en enkelt kommandolinje, såkalte oneliners.
For å gjøre det bruker man konstruksjoner som <code>ForEach-Object</code> og <code>Where-Object</code> og lage en
indre løkke hvor hvert objekt behandles. Inne i en slik løkke vil den spesielle variabelen <code>$_</code> være
en peker til objektet som er under behandling. Hele scriptet ovenfor kan lages som en oneliner slik:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls | ForEach-Object {$sum += $_.Length}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Men man må på kommandolinjen passe på at variabelen nullstilles og hvis man i tillegg ønsker å skrive
ut svaret kan man akkurat som i bash adskille kommandoer med semikolon:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$sum = 0; ls | ForEach-Object {$sum += $_.Length };$sum
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Med Where-Object kan man velge ut objekter med spesielle egenskaper. For eksempel kan man plukke ut mapper fra en listing av filer og mapper på følgende måte:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

 ls | Where-Object  {$_.PSIsCointainer}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
for <code>PSIsCointainer</code> er en TRUE/FALSE property som bare er sann for mapper. Where-Object kan kombineres med forEach-Object:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$sum = 0; ls | Where-Object  {$_.extension -eq ".txt"} | ForEach-Object {$sum += $_.Length };$sum
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
som legger sammen Length kun for filer med extension .txt. 

<P>

<H2><A ID="SECTION0001218000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">18</SPAN> Sort-Object og Select-Object</A>
</H2>
Med disse to CmdLets kan man sortere og velge ut objekter. For eksempel vil følgende oneliner sortere filer etter lengde, med de største først (descending) og deretter plukke ut de fire første:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls | Sort-Object Length -des | Select-Object -First 4
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION0001219000000000000000">
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">19</SPAN> DateTime</A>
</H2>
<code>DateTime</code> er en CmdLet som uten argumenter gir et objekt som inneholder dato og klokkeslett (DateTime)
akkurat nå:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; Get-Date
søndag 19. mars 2017 19.41.59
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Man kan også lage DateTime objekter for et vilkårlig tidspunkt:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; Get-Date -Year 2016 -Month 5 -Day 17  -Hour 17 -Minute 30 -Second 00
tirsdag 17. mai 2016 17.30.00

PS C:\&gt; Get-Date "17/5 2007 17:30"
torsdag 17. mai 2007 17.30.00

PS C:\&gt; Get-Date "17 May 2007 17:30"
torsdag 17. mai 2007 17.30.00
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Med utgangspunkt i en variabel som inneholder et DateTime-objekt, kan man med <code>Get-Member</code> finne
egenskaper og metoder objektet har og for eksempel bruke det til å lage en ny variabel ett døgn tilbake i tid.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; $now = Get-Date
PS C:\&gt; $now

søndag 19. mars 2017 19.44.26

PS C:\&gt; $now | Get-Member

   TypeName: System.DateTime

Name                 MemberType     Definition
----                 ----------     ----------
Add                  Method         datetime Add(timespan value)
AddDays              Method         datetime AddDays(double value)
AddHours             Method         datetime AddHours(double value)

PS C:\&gt; $yesterday = $now.AddDays(-1)
PS C:\&gt; $yesterday

lørdag 18. mars 2017 19.44.26
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Anta at du husker at du har laget eller endret noen filer på mandag 13 mars, men ikke husker hvor de ligger.
Da kan man først lage et par DateTime variabler tidlig på dagen og sent på kvelden: 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\&gt; $mm = Get-Date "13/3 2017 08:00" # Mandag morgen
PS C:\&gt; $mk = Get-Date "13/3 2017 22:00" # Mandag kveld
PS C:\&gt; $mm.DayOfWeek
Monday
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Den siste kommandoen dobbeltsjekker at den 13 var en mandag. 
Deretter kan man lage en oneliner som lister alle filer som har <code>LastWriteTime</code> i dette tidsrommet:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

PS C:\Users\haugerud&gt; ls -r | Where-Object {$_.LastWriteTime -gt $mm -and $_.LastWriteTime -lt $mk}

    Directory: C:\Users\haugerud

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----       13.03.2017     17.05                .ssh
d-----       13.03.2017     18.28                mappe
-a----       13.03.2017     19.00              0 file6.txt
-a----       13.03.2017     10.38          13074 history13.03.2017

    Directory: C:\Users\haugerud\.ssh

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----       13.03.2017     17.05            189 known_hosts

    Directory: C:\Users\haugerud\mappe

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----       13.03.2017     09.05            146 hello.ps1
-a----       13.03.2017     18.36             64 loop.ps1
-a----       13.03.2017     18.25            307 nkill.ps1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Hvis man sender output til <code>Format-Table</code> blir det litt ryddigere og man kan velge hvilke felt
man ønsker å ha med:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

 ls -r | Where-Object {$_.LastWriteTime -gt $mm -and $_.LastWriteTime -lt $mk} | Format-Table LastWriteTime,fullName

LastWriteTime       FullName
-------------       --------
13.03.2017 17.05.18 C:\Users\haugerud\.ssh
13.03.2017 18.28.23 C:\Users\haugerud\mappe
13.03.2017 19.00.45 C:\Users\haugerud\file6.txt
13.03.2017 10.38.02 C:\Users\haugerud\history13.03.2017
13.03.2017 17.05.18 C:\Users\haugerud\.ssh\known_hosts
13.03.2017 09.05.03 C:\Users\haugerud\mappe\hello.ps1
13.03.2017 18.36.16 C:\Users\haugerud\mappe\loop.ps1
13.03.2017 18.25.18 C:\Users\haugerud\mappe\nkill.ps1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Hvis man ønsker en sortert liste på tidspunktet, må man sende objektene til sort (alias for Sort-Objekt) før man
sender det til Format-Table:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

ls -r | Where-Object {$_.LastWriteTime -gt $mm -and $_.LastWriteTime -lt $mk} | sort LastWriteTime | Format-Table LastWriteTime,fullName

LastWriteTime       FullName
-------------       --------
13.03.2017 09.05.03 C:\Users\haugerud\mappe\hello.ps1
13.03.2017 10.38.02 C:\Users\haugerud\history13.03.2017
13.03.2017 17.05.18 C:\Users\haugerud\.ssh
13.03.2017 17.05.18 C:\Users\haugerud\.ssh\known_hosts
13.03.2017 18.25.18 C:\Users\haugerud\mappe\nkill.ps1
13.03.2017 18.28.23 C:\Users\haugerud\mappe
13.03.2017 18.36.16 C:\Users\haugerud\mappe\loop.ps1
13.03.2017 19.00.45 C:\Users\haugerud\file6.txt
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2025-03-27
</ADDRESS>
</BODY>
</HTML>
