{'text': ' Vi kan starte med PØL, som dere kanskje ikke har så stort tett forhold til. Bare for å forklare hvordan dette ser ut. Ja, her ser vi... Nei, dette var POP. Her ser vi POP-koden. Så denne POP-koden gjør dette, som er nøyaktig det samme som... Den har klart å gjøre dette 400 ganger på samme tid. Det betyr at POP-koden er 400 ganger så raskt som skjellskriftet. Så POP er oppe som en kandidat til å være raskest. Vi kan prøve å ta alle under én kamp. Jeg tror det står times equal i alle filene. Så jeg kan prøve å greppe på times equal. Og da får vi på en måte opp en resultatliste, hvis vi nå sorterer etter det største tallet. Og da ser vi... Vi kan komme tilbake til den. Men vi ser faktisk at av de som vi har kjørt, så er Java det raskeste programmet. Det er kanskje ganske overraskende. Det var bare fire av dere som trodde det. Java er 20 000 ganger raskere enn Skjellskriftet. Så det viktigste å ta med seg her fra dette, er at det er en... Ekstrem forskjell i regnekraft på programmeringsspråk som Java og C sammenlignet med et Shellscript. Shellscript er ekstremt trege til denne type oppgaver. På andreplass her så ser vi C-programmet kommer. Og på... skal vi se... ja, tredjeplass... Så kommer POP med 400, som vi så. Ganske overraskende så ser vi at Pyton også er vesentlig tregere enn f.eks. C. Vi ser at det er en faktor på 100 her. Så å kjøre dette i C og Java går mer enn 100 ganger så fort som om man kjører det i Pyton. En spearl er omtrent like rask som Pyton. Hvilken er den som har 28 000? Ja, det kommer jeg tilbake til. Så... Det første vi kan lære her, er at det er veldig stor forskjell. Og delvis skyldes dette at språk som Python, POP og Pearl er interpretert. Det betyr at de tolkes, så de kjører ikke kode direkte på CPU. Men også Java. Ved hjelp av just in time compiling, så vil Java kunne optimalisere, sånn at den i praksis kjører kode rett på CPU-en. Dvs. at det ikke er noen virtuell maskin imellom som først tolker koden, og så kjører den. Dette gjør at disse programmene er ganske mye tregere. Da kommer jeg tilbake til 28 000. For som vi så, så gikk faktisk sånn default, så gikk C-programmet saktere enn jeg var. Og det er det mange som stusser på, med god grunn, for man har alltid hørt at C og C pluss pluss, det er det raskeste som fins. Og det stemmer faktisk også. Men det vi har glemt å tenke på her, er... Når jeg kompilerer C-programmet på den måten her, og kjører det, så er GCC optimalisert for å kompilere raskt. Og det er ikke optimalisert for å gi rask kode. Derfor så har jeg da lagd en sum O, hvor O står for optimalisert. Og hvis man... Det er da samme koden. Hvis man kompilerer den... Og kjører. Så får man en optimalisert ferdig kode som går raskest mulig. Den gikk da litt under fem sekunder, men hovedpoenget med dette var at der kom tallet 28 000, som faktisk skulle vært litt større. Vi ser at vi kunne kanskje kommet opp i 35 000 med denne her. Så C er faktisk den... Det aller raskeste språket. Og vi ser her i kommentaren at det er nesten sju ganger raskere med minus O. Så det jeg kan... Ja, og i oppgaven denne uken, så... Så blir dere bedt om å tilpasse disse programmene til å kjøre på dokker. Jeg kommer tilbake til dokker etterpå og ser hvordan det går der. Men tanken er da at hvis tiden ikke er helt den samme som her, så må dere prøve å tilpasse tallene sånn at dere får et antall ganger i dokker på Linux-VM. For det vil være litt forskjell på dette her. Hvis vi kjører det rett over, så skal vi se at ikke alle går på på samme tid. Måten man kan gjøre det på, den kan vi prøve å illustrere her, er at vi ser... Dette programmet, SumO.c, det burde kjørt litt flere ganger. For det skal opp i 5,5 sekunder. Så det man kan gjøre da, at man kan regne ut tiden det tok på skjellskriftet, som er ca. 5,5. Og så kan man dele på 3,69, som er tiden C-programmet bruker. Da skal vi få 1,5. R er for øvrig en liten schellscript som gjør at det kan regne i kommandolinjen. Jeg får nå 1,5, og det betyr at da kan faktisk dette programmet klare å kjøre 1,5 ganger... Jeg kan ta 1,5 ganger... 28 000. Da ser vi at jeg får 42 000. Så tanken er da... Ok, da går jeg inn i sumo.c. Og så endrer jeg den til 42 000. Sånn. Så tar jeg og kompilerer på nytt med GCC. Nå har jeg endret times, sånn at også denne tar 5,5 sekunder. Så den riktige fasiten nå er at C, optimalisert C-kode, er 42 tuner. Det er ganske enorm forskjell. Så... dette er det viktig å ha med seg når man ser på... når man vurderer hvilket språk man skal velge for å gjøre denne oppgaven. Med en gang det har noe med regning å gjøre, Så er det fornuftig å velge C eller C++. C++ er omtrent like raskt som C. Alternativt Java, som pga. Just in time compiler også er veldig raskt. Den vi ser her nå, er i dette tilfellet dobbelt så raskt som Java. OK. Hvis vi går og ser på det dere svarte i utgangspunktet, så... Så er det opplagt at det er ikke så lett å... Eller generelt så har man ikke så mye intuisjon på hvor raskt ting går. Men det er en veldig stor forskjell, så det er det greit å huske å ha med seg videre. Vi skal se etterpå, etter pausen, at resultatene er veldig forskjellige. Så man kan ikke ta dette resultatet og bruke som det er. Dette gjelder kun for CPU-intensive jobber.', 'chunks': [{'timestamp': (0.0, 8.16), 'text': ' Vi kan starte med PØL, som dere kanskje ikke har så stort tett forhold til.'}, {'timestamp': (10.52, 15.72), 'text': ' Bare for å forklare hvordan dette ser ut.'}, {'timestamp': (15.72, 20.8), 'text': ' Ja, her ser vi... Nei, dette var POP. Her ser vi POP-koden.'}, {'timestamp': (21.52, 27.08), 'text': ' Så denne POP-koden gjør dette, som er nøyaktig det samme som...'}, {'timestamp': (30.0, 40.08), 'text': ' Den har klart å gjøre dette 400 ganger på samme tid.'}, {'timestamp': (40.12, 48.04), 'text': ' Det betyr at POP-koden er 400 ganger så raskt som skjellskriftet.'}, {'timestamp': (48.72, 57.8), 'text': ' Så POP er oppe som en kandidat til å være raskest. Vi kan prøve å ta alle under én kamp.'}, {'timestamp': (60.0, 66.36), 'text': ' Jeg tror det står times equal i alle filene.'}, {'timestamp': (66.36, 74.36), 'text': ' Så jeg kan prøve å greppe på times equal.'}, {'timestamp': (76.12, 80.44), 'text': ' Og da får vi på en måte opp en resultatliste,'}, {'timestamp': (80.44, 86.76), 'text': ' hvis vi nå sorterer etter det største tallet. Og da ser vi...'}, {'timestamp': (90.0, 96.14), 'text': ' Vi kan komme tilbake til den. Men vi ser faktisk at'}, {'timestamp': (96.26, 102.18), 'text': ' av de som vi har kjørt, så er Java det raskeste programmet.'}, {'timestamp': (102.18, 109.2), 'text': ' Det er kanskje ganske overraskende. Det var bare fire av dere som trodde det.'}, {'timestamp': (109.2, 114.58), 'text': ' Java er 20 000 ganger raskere enn Skjellskriftet.'}, {'timestamp': (114.6, 119.8), 'text': ' Så det viktigste å ta med seg her fra dette, er at det er en...'}, {'timestamp': (120.0, 127.6), 'text': ' Ekstrem forskjell i regnekraft på programmeringsspråk som Java og C'}, {'timestamp': (127.68, 130.48), 'text': ' sammenlignet med et Shellscript.'}, {'timestamp': (130.56, 135.32), 'text': ' Shellscript er ekstremt trege til denne type oppgaver.'}, {'timestamp': (135.32, 141.44), 'text': ' På andreplass her så ser vi C-programmet kommer.'}, {'timestamp': (143.04, 147.44), 'text': ' Og på... skal vi se... ja, tredjeplass...'}, {'timestamp': (150.0, 154.8), 'text': ' Så kommer POP med 400, som vi så.'}, {'timestamp': (154.8, 163.8), 'text': ' Ganske overraskende så ser vi at Pyton også er vesentlig tregere enn f.eks. C.'}, {'timestamp': (164.2, 167.24), 'text': ' Vi ser at det er en faktor på 100 her.'}, {'timestamp': (167.24, 175.68), 'text': ' Så å kjøre dette i C og Java går mer enn 100 ganger så fort som om man kjører det i Pyton.'}, {'timestamp': (175.68, 178.88), 'text': ' En spearl er omtrent like rask som Pyton.'}, {'timestamp': (180.0, 186.72), 'text': ' Hvilken er den som har 28 000? Ja, det kommer jeg tilbake til.'}, {'timestamp': (186.72, 195.78), 'text': ' Så... Det første vi kan lære her, er at det er veldig stor forskjell.'}, {'timestamp': (195.8, 202.4), 'text': ' Og delvis skyldes dette at språk som Python, POP og Pearl er interpretert.'}, {'timestamp': (203.44, 208.24), 'text': ' Det betyr at de tolkes, så de kjører ikke kode direkte på CPU.'}, {'timestamp': (210.0, 216.0), 'text': ' Men også Java. Ved hjelp av just in time compiling, så vil Java kunne'}, {'timestamp': (216.08, 222.24), 'text': ' optimalisere, sånn at den i praksis kjører kode rett på CPU-en.'}, {'timestamp': (222.24, 228.64), 'text': ' Dvs. at det ikke er noen virtuell maskin imellom som først tolker koden,'}, {'timestamp': (228.64, 237.36), 'text': ' og så kjører den. Dette gjør at disse programmene er ganske mye tregere.'}, {'timestamp': (240.0, 245.32), 'text': ' Da kommer jeg tilbake til 28 000.'}, {'timestamp': (245.32, 253.32), 'text': ' For som vi så, så gikk faktisk sånn default, så gikk C-programmet saktere enn jeg var.'}, {'timestamp': (253.38, 259.84), 'text': ' Og det er det mange som stusser på, med god grunn, for man har alltid hørt'}, {'timestamp': (259.84, 263.96), 'text': ' at C og C pluss pluss, det er det raskeste som fins.'}, {'timestamp': (263.96, 269.92), 'text': ' Og det stemmer faktisk også. Men det vi har glemt å tenke på her, er...'}, {'timestamp': (270.0, 278.02), 'text': ' Når jeg kompilerer C-programmet på den måten her, og kjører det,'}, {'timestamp': (278.02, 282.82), 'text': ' så er GCC optimalisert for å kompilere raskt.'}, {'timestamp': (282.84, 287.24), 'text': ' Og det er ikke optimalisert for å gi rask kode.'}, {'timestamp': (287.24, 295.36), 'text': ' Derfor så har jeg da lagd en sum O, hvor O står for optimalisert.'}, {'timestamp': (295.46, 299.98), 'text': ' Og hvis man... Det er da samme koden. Hvis man kompilerer den...'}, {'timestamp': (300.0, 309.74), 'text': ' Og kjører. Så får man en optimalisert ferdig kode som går raskest mulig.'}, {'timestamp': (312.26, 316.86), 'text': ' Den gikk da litt under fem sekunder, men hovedpoenget med dette var'}, {'timestamp': (317.84, 325.74), 'text': ' at der kom tallet 28 000, som faktisk skulle vært litt større.'}, {'timestamp': (325.76, 332.76), 'text': ' Vi ser at vi kunne kanskje kommet opp i 35 000 med denne her.'}, {'timestamp': (333.32, 339.48), 'text': ' Så C er faktisk den...'}, {'timestamp': (340.24, 342.16), 'text': ' Det aller raskeste språket.'}, {'timestamp': (342.16, 348.36), 'text': ' Og vi ser her i kommentaren at det er nesten sju ganger raskere med minus O.'}, {'timestamp': (348.38, 354.64), 'text': ' Så det jeg kan... Ja, og i oppgaven denne uken, så...'}, {'timestamp': (355.76, 362.68), 'text': ' Så blir dere bedt om å tilpasse disse programmene til å kjøre på dokker.'}, {'timestamp': (362.76, 367.2), 'text': ' Jeg kommer tilbake til dokker etterpå og ser hvordan det går der.'}, {'timestamp': (367.32, 374.0), 'text': ' Men tanken er da at hvis tiden ikke er helt den samme som her,'}, {'timestamp': (374.0, 383.56), 'text': ' så må dere prøve å tilpasse tallene sånn at dere får et antall ganger i dokker på Linux-VM.'}, {'timestamp': (383.56, 385.72), 'text': ' For det vil være litt forskjell på dette her.'}, {'timestamp': (385.74, 391.3), 'text': ' Hvis vi kjører det rett over, så skal vi se at ikke alle går på på samme tid.'}, {'timestamp': (391.3, 396.54), 'text': ' Måten man kan gjøre det på, den kan vi prøve å illustrere her, er at vi ser...'}, {'timestamp': (396.54, 402.14), 'text': ' Dette programmet, SumO.c, det burde kjørt litt flere ganger.'}, {'timestamp': (402.34, 404.46), 'text': ' For det skal opp i 5,5 sekunder.'}, {'timestamp': (404.54, 414.7), 'text': ' Så det man kan gjøre da, at man kan regne ut tiden det tok på skjellskriftet, som er ca. 5,5.'}, {'timestamp': (415.74, 422.4), 'text': ' Og så kan man dele på 3,69,'}, {'timestamp': (422.4, 429.2), 'text': ' som er tiden C-programmet bruker.'}, {'timestamp': (429.22, 433.46), 'text': ' Da skal vi få 1,5. R er for øvrig en liten schellscript'}, {'timestamp': (433.6, 438.4), 'text': ' som gjør at det kan regne i kommandolinjen.'}, {'timestamp': (438.42, 445.72), 'text': ' Jeg får nå 1,5, og det betyr at da kan faktisk dette programmet klare å kjøre 1,5 ganger...'}, {'timestamp': (445.74, 454.74), 'text': ' Jeg kan ta 1,5 ganger... 28 000. Da ser vi at jeg får 42 000.'}, {'timestamp': (454.9, 459.86), 'text': ' Så tanken er da... Ok, da går jeg inn i sumo.c.'}, {'timestamp': (459.86, 467.98), 'text': ' Og så endrer jeg den til 42 000. Sånn.'}, {'timestamp': (467.98, 473.5), 'text': ' Så tar jeg og kompilerer på nytt med GCC.'}, {'timestamp': (475.74, 481.74), 'text': ' Nå har jeg endret times, sånn at også denne tar 5,5 sekunder.'}, {'timestamp': (486.18, 504.18), 'text': ' Så den riktige fasiten nå er at C, optimalisert C-kode, er 42 tuner.'}, {'timestamp': (505.74, 515.74), 'text': ' Det er ganske enorm forskjell. Så... dette er det viktig å ha med seg'}, {'timestamp': (519.26, 524.98), 'text': ' når man ser på... når man vurderer hvilket språk man skal velge'}, {'timestamp': (525.06, 533.46), 'text': ' for å gjøre denne oppgaven. Med en gang det har noe med regning å gjøre,'}, {'timestamp': (535.74, 539.22), 'text': ' Så er det fornuftig å velge C eller C++.'}, {'timestamp': (539.22, 542.38), 'text': ' C++ er omtrent like raskt som C.'}, {'timestamp': (542.38, 548.66), 'text': ' Alternativt Java, som pga. Just in time compiler også er veldig raskt.'}, {'timestamp': (548.74, 554.74), 'text': ' Den vi ser her nå, er i dette tilfellet dobbelt så raskt som Java.'}, {'timestamp': (558.7, 565.54), 'text': ' OK. Hvis vi går og ser på det dere svarte i utgangspunktet, så...'}, {'timestamp': (565.74, 572.12), 'text': ' Så er det opplagt at det er ikke så lett å...'}, {'timestamp': (572.22, 577.58), 'text': ' Eller generelt så har man ikke så mye intuisjon på hvor raskt ting går.'}, {'timestamp': (577.58, 587.18), 'text': ' Men det er en veldig stor forskjell, så det er det greit å huske å ha med seg videre.'}, {'timestamp': (587.82, 594.22), 'text': ' Vi skal se etterpå, etter pausen, at resultatene er veldig forskjellige.'}, {'timestamp': (595.74, 601.62), 'text': ' Så man kan ikke ta dette resultatet og bruke som det er.'}, {'timestamp': (601.62, 607.3), 'text': ' Dette gjelder kun for CPU-intensive jobber.'}]}