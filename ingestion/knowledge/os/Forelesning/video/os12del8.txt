{'text': ' Så i praksis så brukes som oftest hardwaystøttede løsninger. Og en sånn hardwaystøttet løsning kan lages hvis man har en institusjon som f.eks. TestAndSet TSL. Det er da en institusjon som gjør begge de to operasjonene som vi snakket om på forrige slide. Å teste verdien og endre den, i én og samme institusjon. Det er viktig at det er én og samme institusjon, for det gjør at det ikke kan komme en kontekst-switch mens dens institusjon utføres. En TestAnset vil i tillegg låse minnebussen, bussen ut av ramm, sånn at ikke andre CPU-er kan lese verdien. Da kan man implementere GetMuteX på følgende måte... Man har da Wile test-and-set lock. Og denne operasjonen, det er bare da én institusjon. Og midt inni den institusjonen så kan det ikke komme en context switch. Og siden den i tillegg låser minnebussen, så er man da bombesikker på at bare denne prosessen kommer inn i kritiske avsnitt av gangen. En perfekt løsning. Vi så forrige gang på X86-institusjonen LOC. Og det... Den LOC-institusjonen, den utføres før en kritisk institusjon. Den koden vi hadde sist, var at vi først hadde LOC, og så hadde vi en ad, eller en ink. Og den gjør at man låser av minnebussen, sånn at ingen andre CPU-er heller får endre den verdien... Den minneadressen som man bruker. Alle andre minneadresser kan brukes, men ikke akkurat den. Så det sikrer da at institusjonen etterlokker. Den vil være den eneste som kan endre på den variabelen som kommer etter lock-instruksjonen. Og dette sørger da for at det kritiske avsnittet fullføres uten at noen andre tråder kommer inn. Men det er klart, dette fungerer bare hvis det kritiske avsnittet kun er én enkel institusjon. Men det kan det ofte være. Man kunne i prinsippet bruke en sånn lock-instruksjon til å lage En Mutex, men da bruker man heller Test-and-Set-institusjonen. Og Test-and-Set-institusjonen er også en X86-institusjon. Hvis man skal lese om dette, så kan man slå opp i Intels X86-manual. Der står det om hvordan denne lokkinstitusjonen låser av... Låser av bussen og hindrer at noen andre endrer på verdi.', 'chunks': [{'timestamp': (0.0, 9.42), 'text': ' Så i praksis så brukes som oftest hardwaystøttede løsninger.'}, {'timestamp': (10.0, 16.48), 'text': ' Og en sånn hardwaystøttet løsning kan lages'}, {'timestamp': (16.58, 22.98), 'text': ' hvis man har en institusjon som f.eks. TestAndSet TSL.'}, {'timestamp': (22.98, 28.5), 'text': ' Det er da en institusjon som gjør begge de to operasjonene som vi snakket om på forrige slide.'}, {'timestamp': (30.0, 36.14), 'text': ' Å teste verdien og endre den, i én og samme institusjon.'}, {'timestamp': (36.16, 40.0), 'text': ' Det er viktig at det er én og samme institusjon,'}, {'timestamp': (40.12, 44.96), 'text': ' for det gjør at det ikke kan komme en kontekst-switch'}, {'timestamp': (44.96, 49.56), 'text': ' mens dens institusjon utføres.'}, {'timestamp': (49.56, 57.6), 'text': ' En TestAnset vil i tillegg låse minnebussen, bussen ut av ramm,'}, {'timestamp': (57.6, 59.8), 'text': ' sånn at ikke andre CPU-er kan lese verdien.'}, {'timestamp': (60.0, 64.94), 'text': ' Da kan man implementere GetMuteX på følgende måte...'}, {'timestamp': (64.94, 68.42), 'text': ' Man har da Wile test-and-set lock.'}, {'timestamp': (68.44, 71.72), 'text': ' Og denne operasjonen, det er bare da én institusjon.'}, {'timestamp': (71.72, 76.96), 'text': ' Og midt inni den institusjonen så kan det ikke komme en context switch.'}, {'timestamp': (77.88, 80.72), 'text': ' Og siden den i tillegg låser minnebussen,'}, {'timestamp': (80.72, 88.32), 'text': ' så er man da bombesikker på at bare denne prosessen kommer inn i kritiske avsnitt av gangen.'}, {'timestamp': (90.0, 93.8), 'text': ' En perfekt løsning.'}, {'timestamp': (94.44, 99.96), 'text': ' Vi så forrige gang på X86-institusjonen LOC.'}, {'timestamp': (99.96, 103.44), 'text': ' Og det...'}, {'timestamp': (103.52, 109.86), 'text': ' Den LOC-institusjonen, den utføres før en kritisk institusjon.'}, {'timestamp': (109.88, 115.84), 'text': ' Den koden vi hadde sist, var at vi først hadde LOC, og så hadde vi en ad, eller en ink.'}, {'timestamp': (115.88, 115.84), 'text': ''}, {'timestamp': (121.52, 128.96), 'text': ' Og den gjør at man låser av minnebussen, sånn at ingen andre CPU-er heller får endre den verdien...'}, {'timestamp': (128.96, 134.32), 'text': ' Den minneadressen som man bruker.'}, {'timestamp': (134.32, 139.0), 'text': ' Alle andre minneadresser kan brukes, men ikke akkurat den.'}, {'timestamp': (139.0, 143.8), 'text': ' Så det sikrer da at institusjonen etterlokker.'}, {'timestamp': (145.84, 150.76), 'text': ' Den vil være den eneste som kan endre på den variabelen'}, {'timestamp': (150.8, 153.4), 'text': ' som kommer etter lock-instruksjonen.'}, {'timestamp': (153.4, 159.28), 'text': ' Og dette sørger da for at det kritiske avsnittet fullføres'}, {'timestamp': (159.32, 163.36), 'text': ' uten at noen andre tråder kommer inn.'}, {'timestamp': (163.36, 167.52), 'text': ' Men det er klart, dette fungerer bare hvis det kritiske avsnittet'}, {'timestamp': (167.6, 171.84), 'text': ' kun er én enkel institusjon. Men det kan det ofte være.'}, {'timestamp': (171.92, 175.76), 'text': ' Man kunne i prinsippet bruke en sånn lock-instruksjon til å lage'}, {'timestamp': (175.84, 181.64), 'text': ' En Mutex, men da bruker man heller Test-and-Set-institusjonen.'}, {'timestamp': (181.76, 186.16), 'text': ' Og Test-and-Set-institusjonen er også en X86-institusjon.'}, {'timestamp': (186.16, 191.8), 'text': ' Hvis man skal lese om dette, så kan man slå opp i Intels X86-manual.'}, {'timestamp': (191.92, 197.48), 'text': ' Der står det om hvordan denne lokkinstitusjonen låser av...'}, {'timestamp': (197.48, 203.92), 'text': ' Låser av bussen og hindrer at noen andre endrer på verdi.'}]}