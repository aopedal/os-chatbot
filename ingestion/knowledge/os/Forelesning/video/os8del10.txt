{'text': ' Hva da når et brukerprogram skal gjøre noe som... Som skal gjøre instruksjoner som ikke kan utføres fra Jus og Maud? Hvordan kan da brukerprogrammet få til det? Og det kan f.eks. være sånn som å lese noe fra disk. Sånn generelt så har jo operativsystemet full kontroll på disken. Men hvordan kan da et brukerprogram lese noe fra disken når den må utføre operasjoner som bare kan gjøres i kernel mode? Jo, der da systemcall kommer inn. Og det er rett og slett brukerkode som ber kjernen om hjelp ved hjelp av systemcall. Et systemkall er egentlig bare et API mot operativsystemkjernen. Det er et sett med operasjoner som et vanlig brukerprogram fra YSMOD kan be operativsystemkjernen om å gjøre. På samme måte som du har et API, et Application Programming Interface, mot moduler og programmer av alle mulige typer. Da er det liksom alle typer. Altså de operasjonene som det er mulig å få utført med dette programmet eller denne metoden. Men vi har et dilemma her hvis vi skal gjøre noe som krever kernal mode. Det kunne jo være sånn at man... At brukerprogrammet kunne sette modusbytt til kernal mode, og så... Og så utføre det man trengte, og så skulle det switches tilbake. Men da får du igjen problemet. Hvis du kan gjøre switch til curl-mode, så kan bruksprosessen ta over og stoppe systemet. Så igjen må vi ha hjelp fra Harvey, og da er det en spesiell intensjon som heter trap. Og trap, det som er det fine med den, er at den switcher til curl-mode og hopper til kode for et systemkall i én og samme operasjon. Og det betyr at fra juicemode så kan du ikke da først hoppe til kernel mode, og så love å si... Ja, etterpå... Jeg lover. Jeg skal gjøre systemcall etterpå. Men dette må gjøres i én og samme operasjon. Og for å få til noe i én og samme operasjon, så må man ha én instruksjon som gjør det. Så igjen så får man hjelp fra Hardware for å få til systemcall. Her er en oversikt over hvordan et systemkall foregår. Og da ser vi på venstre side her, så er vi i brukerminne. Og på høyre så har vi privilegert-minne. Og her er det vanlig brukerkode som kjører Jusemodes. Institusjon 1, 2, 3 osv. Og så... Skal gjøres et systemcall. Og det er systemcall nummer tre i API-et. Og sånn ser det ut i Lynix-API-et. Så er det systemcall. Den er nummerert da det var her. Og det finnes mange hundre systemcall. Men det er noen få som gjøres veldig ofte. Og tredje systemkall, Sister Read, det er akkurat det jeg også leser fra disk. Og det kan man ikke gjøre i Use and Mode. Og det som skjer da, er at her kommer et system kalt Trap 3. Og da... En viktig del av systemkallet er den institusjonen Trap. For den switcher da til... Den switcher modusbit til Curl-mode. Samtidig som den hopper inn i en branching-tabell her og hopper til første kodelinje i det systemkallet. Så da, i én institusjon, så switches modus blitt. Og første institusjon for dette systemkallet legges inn i... Inn i institusjonsregisteret. Det er den neste institusjonen som skal gjøres. Det må vi hele tiden tenke på. Vi har i utgangspunktet bare én CPU som vi ser på, og det er bare én av gangen som kan gjøre instruksjoner. Så dermed må man ha en sånn hardware-hjelp fra trap for å kunne både hoppe inn, switche modusputt, switche modusputt og hoppe inn i neste instruksjon. Og på denne måten så får man full kontroll. Wimebranching-tabell, det er rett og slett bare en tabell Her ligger da adressen til Dar-i-Ram, som første institusjon i dette systemkallet ligger. Ja, dette er en illustrasjon fra Tanbaum på systemkall. Litt mer... Litt flere detaljer, men ideen er den samme. Vi har vanlige institusjoner her. Én, to, tre. Og så kaller man read. Og så må det gjøres en del under huden med å få riktige verdier inn i forskjellige registre osv. Men så er det da den trap to cornal. Da hopper man inn i kjernekodet, utfører systemkallet, Men det er masse som må holdes orden på her. At man må hoppe tilbake til riktig sted i use mode osv. Så det er en ganske kompleks operasjon. Men det viktige prinsippet, det er trap. At man da både switcher modusbytt og hopper til systemkalkon. I én og sammen institusjon. Her er noen eksempler på systemcall. Vi så et av de tidligere... var fork. Og det er typisk noe som er systemcall. Altså at man... Fork brukes i Linux til å sette i gang en ny prosess. Da er det klart... Det kan ikke et vanlig brukerprogram gjøre. Der må operativsystemet inn og styre. Vi skal bruke det litt senere når vi skal forke og snakke med child. Men dette er igjen sånn prosessmanagement. Så har vi sånn som filemanagement, som vi har sett på, med open, close, read, write, skrive til og fra filer. Disken og filsystemet, det er det operativstemmet som kontrollerer. Her må vi bruke systemcall for å oppnå det. Igjen så kunne vi hatt vanlige brukerprosesser som styrte dette fra use and bot, men da kunne man risikere å krasje hele disken og skrive over for andre brukere osv. Så er det sånn som directory and system management med MKDIR. Link... mount... Vi ser sånn som MKD-er. Det er en del av de Shell-kommandoene som faktisk heter det samme som systemcall. Og i C så er alle disse systemcallene implementert. Så dermed så kan man skrive C-programmer som direkte utfører systemcall mot Linux-kjernen. En del sånn diverse, sånn som Kill, for eksempel, som opplagt trengs et systemkall for å gjøre. Det kan heller ikke en brukerprosess gjøre mot f.eks. andre brukere. Ja, her er noen vindussystemkall. Jeg har satt opp en masse systemkall Dette er bare for å illustrere at alle moderne operativsystemer har en tilsvarende mekanisme med systemcall. Men ofte er ting ganske forskjellig, sånn som Windows 32. Har ikke fork i utgangspunktet. De har rett og slett en create process. Det er da et systemcall som lager en ny prosess. Akkurat som Linux har Read, så har Windows-operativstemme ReadFile for å lese data fra en fil. Men i prinsippet så virker Windows og andre operativstemmer på nøyaktig samme måte, at det må gjøre systemkall for å... Vanlige brukerprosesser må gjøre systemkall når de skal gjøre kjerneoperasjoner. Alt som har med å snakke med hardware, og alt som har med å styre prosesser. Det er typisk kjernevirksomhet som man er nødt til å gjøre systemcall for å få utført.', 'chunks': [{'timestamp': (0.0, 8.84), 'text': ' Hva da når et brukerprogram skal gjøre noe som...'}, {'timestamp': (9.78, 15.64), 'text': ' Som skal gjøre instruksjoner som ikke kan utføres fra Jus og Maud?'}, {'timestamp': (15.64, 21.24), 'text': ' Hvordan kan da brukerprogrammet få til det?'}, {'timestamp': (23.68, 28.24), 'text': ' Og det kan f.eks. være sånn som å lese noe fra disk.'}, {'timestamp': (30.0, 35.56), 'text': ' Sånn generelt så har jo operativsystemet full kontroll på disken.'}, {'timestamp': (35.68, 41.2), 'text': ' Men hvordan kan da et brukerprogram lese noe fra disken'}, {'timestamp': (41.28, 47.08), 'text': ' når den må utføre operasjoner som bare kan gjøres i kernel mode?'}, {'timestamp': (47.2, 49.52), 'text': ' Jo, der da systemcall kommer inn.'}, {'timestamp': (49.52, 56.52), 'text': ' Og det er rett og slett brukerkode som ber kjernen om hjelp ved hjelp av systemcall.'}, {'timestamp': (60.0, 64.0), 'text': ' Et systemkall er egentlig bare et API mot operativsystemkjernen.'}, {'timestamp': (64.0, 69.4), 'text': ' Det er et sett med operasjoner som'}, {'timestamp': (69.4, 75.48), 'text': ' et vanlig brukerprogram fra YSMOD kan be operativsystemkjernen om å gjøre.'}, {'timestamp': (75.48, 83.24), 'text': ' På samme måte som du har et API, et Application Programming Interface,'}, {'timestamp': (83.32, 88.8), 'text': ' mot moduler og programmer av alle mulige typer. Da er det liksom alle typer.'}, {'timestamp': (90.0, 94.2), 'text': ' Altså de operasjonene som det er mulig å få utført'}, {'timestamp': (94.28, 98.88), 'text': ' med dette programmet eller denne metoden.'}, {'timestamp': (99.84, 107.16), 'text': ' Men vi har et dilemma her hvis vi skal gjøre noe'}, {'timestamp': (107.24, 113.44), 'text': ' som krever kernal mode. Det kunne jo være sånn at man...'}, {'timestamp': (113.44, 119.12), 'text': ' At brukerprogrammet kunne sette modusbytt til kernal mode, og så...'}, {'timestamp': (120.0, 125.08), 'text': ' Og så utføre det man trengte, og så skulle det switches tilbake.'}, {'timestamp': (125.12, 128.2), 'text': ' Men da får du igjen problemet.'}, {'timestamp': (128.22, 133.82), 'text': ' Hvis du kan gjøre switch til curl-mode, så kan bruksprosessen ta over og stoppe systemet.'}, {'timestamp': (133.82, 140.0), 'text': ' Så igjen må vi ha hjelp fra Harvey, og da er det en spesiell intensjon som heter trap.'}, {'timestamp': (140.12, 145.24), 'text': ' Og trap, det som er det fine med den, er at den switcher til curl-mode'}, {'timestamp': (145.44, 149.92), 'text': ' og hopper til kode for et systemkall i én og samme operasjon.'}, {'timestamp': (150.0, 156.78), 'text': ' Og det betyr at fra juicemode så kan du ikke da først hoppe til kernel mode,'}, {'timestamp': (156.8, 162.2), 'text': ' og så love å si... Ja, etterpå... Jeg lover. Jeg skal gjøre systemcall etterpå.'}, {'timestamp': (162.22, 167.44), 'text': ' Men dette må gjøres i én og samme operasjon.'}, {'timestamp': (167.46, 172.7), 'text': ' Og for å få til noe i én og samme operasjon, så må man ha én instruksjon som gjør det.'}, {'timestamp': (172.78, 179.86), 'text': ' Så igjen så får man hjelp fra Hardware for å få til systemcall.'}, {'timestamp': (180.0, 190.46), 'text': ' Her er en oversikt over hvordan et systemkall foregår.'}, {'timestamp': (190.48, 198.4), 'text': ' Og da ser vi på venstre side her, så er vi i brukerminne.'}, {'timestamp': (198.42, 202.04), 'text': ' Og på høyre så har vi privilegert-minne.'}, {'timestamp': (202.04, 206.24), 'text': ' Og her er det vanlig brukerkode som kjører Jusemodes.'}, {'timestamp': (206.36, 209.96), 'text': ' Institusjon 1, 2, 3 osv. Og så...'}, {'timestamp': (210.0, 215.44), 'text': ' Skal gjøres et systemcall.'}, {'timestamp': (215.52, 219.92), 'text': ' Og det er systemcall nummer tre i API-et.'}, {'timestamp': (219.92, 223.44), 'text': ' Og sånn ser det ut i Lynix-API-et.'}, {'timestamp': (223.52, 227.68), 'text': ' Så er det systemcall. Den er nummerert da det var her.'}, {'timestamp': (228.3, 232.44), 'text': ' Og det finnes mange hundre systemcall.'}, {'timestamp': (232.5, 237.08), 'text': ' Men det er noen få som gjøres veldig ofte.'}, {'timestamp': (237.1, 242.3), 'text': ' Og tredje systemkall, Sister Read, det er akkurat det jeg også leser fra disk.'}, {'timestamp': (242.38, 245.9), 'text': ' Og det kan man ikke gjøre i Use and Mode.'}, {'timestamp': (245.98, 251.42), 'text': ' Og det som skjer da, er at her kommer et system kalt Trap 3.'}, {'timestamp': (251.86, 260.62), 'text': ' Og da... En viktig del av systemkallet er den institusjonen Trap.'}, {'timestamp': (260.7, 267.02), 'text': ' For den switcher da til... Den switcher modusbit til Curl-mode.'}, {'timestamp': (267.08, 271.28), 'text': ' Samtidig som den hopper inn i en branching-tabell her'}, {'timestamp': (272.24, 276.28), 'text': ' og hopper til første kodelinje i det systemkallet.'}, {'timestamp': (276.36, 280.92), 'text': ' Så da, i én institusjon, så switches modus blitt.'}, {'timestamp': (281.0, 287.52), 'text': ' Og første institusjon for dette systemkallet legges inn i...'}, {'timestamp': (287.52, 291.68), 'text': ' Inn i institusjonsregisteret.'}, {'timestamp': (291.72, 297.06), 'text': ' Det er den neste institusjonen som skal gjøres. Det må vi hele tiden tenke på.'}, {'timestamp': (297.08, 300.68), 'text': ' Vi har i utgangspunktet bare én CPU som vi ser på,'}, {'timestamp': (300.68, 303.48), 'text': ' og det er bare én av gangen som kan gjøre instruksjoner.'}, {'timestamp': (303.64, 307.24), 'text': ' Så dermed må man ha en sånn hardware-hjelp fra trap'}, {'timestamp': (307.92, 311.88), 'text': ' for å kunne både hoppe inn, switche modusputt,'}, {'timestamp': (311.88, 315.96), 'text': ' switche modusputt og hoppe inn i neste instruksjon.'}, {'timestamp': (315.96, 321.04), 'text': ' Og på denne måten så får man full kontroll.'}, {'timestamp': (321.84, 325.92), 'text': ' Wimebranching-tabell, det er rett og slett bare en tabell'}, {'timestamp': (327.08, 333.08), 'text': ' Her ligger da adressen til Dar-i-Ram,'}, {'timestamp': (333.08, 342.08), 'text': ' som første institusjon i dette systemkallet ligger.'}, {'timestamp': (347.14, 355.04), 'text': ' Ja, dette er en illustrasjon fra Tanbaum på systemkall.'}, {'timestamp': (357.08, 363.72), 'text': ' Litt mer... Litt flere detaljer, men ideen er den samme.'}, {'timestamp': (363.84, 370.28), 'text': ' Vi har vanlige institusjoner her. Én, to, tre. Og så kaller man read.'}, {'timestamp': (370.28, 374.2), 'text': ' Og så må det gjøres en del under huden'}, {'timestamp': (374.32, 378.92), 'text': ' med å få riktige verdier inn i forskjellige registre osv.'}, {'timestamp': (379.04, 386.08), 'text': ' Men så er det da den trap to cornal. Da hopper man inn i kjernekodet, utfører systemkallet,'}, {'timestamp': (387.08, 391.76), 'text': ' Men det er masse som må holdes orden på her.'}, {'timestamp': (391.84, 397.12), 'text': ' At man må hoppe tilbake til riktig sted i use mode osv.'}, {'timestamp': (397.2, 401.0), 'text': ' Så det er en ganske kompleks operasjon.'}, {'timestamp': (401.08, 404.68), 'text': ' Men det viktige prinsippet, det er trap.'}, {'timestamp': (404.7, 412.24), 'text': ' At man da både switcher modusbytt og hopper til systemkalkon.'}, {'timestamp': (412.24, 415.16), 'text': ' I én og sammen institusjon.'}, {'timestamp': (417.08, 420.64), 'text': ' Her er noen eksempler på systemcall.'}, {'timestamp': (420.64, 425.96), 'text': ' Vi så et av de tidligere... var fork.'}, {'timestamp': (425.96, 429.84), 'text': ' Og det er typisk noe som er systemcall.'}, {'timestamp': (429.84, 436.32), 'text': ' Altså at man... Fork brukes i Linux til å sette i gang en ny prosess.'}, {'timestamp': (436.32, 441.84), 'text': ' Da er det klart... Det kan ikke et vanlig brukerprogram gjøre.'}, {'timestamp': (441.92, 446.0), 'text': ' Der må operativsystemet inn og styre.'}, {'timestamp': (447.08, 454.76), 'text': ' Vi skal bruke det litt senere når vi skal forke og snakke med child.'}, {'timestamp': (454.76, 457.96), 'text': ' Men dette er igjen sånn prosessmanagement.'}, {'timestamp': (458.0, 462.12), 'text': ' Så har vi sånn som filemanagement, som vi har sett på,'}, {'timestamp': (462.24, 466.88), 'text': ' med open, close, read, write, skrive til og fra filer.'}, {'timestamp': (466.88, 473.8), 'text': ' Disken og filsystemet, det er det operativstemmet som kontrollerer.'}, {'timestamp': (473.8, 479.74), 'text': ' Her må vi bruke systemcall for å oppnå det.'}, {'timestamp': (479.74, 485.3), 'text': ' Igjen så kunne vi hatt vanlige brukerprosesser'}, {'timestamp': (486.5, 489.1), 'text': ' som styrte dette fra use and bot,'}, {'timestamp': (489.18, 493.54), 'text': ' men da kunne man risikere å krasje hele disken'}, {'timestamp': (493.62, 498.3), 'text': ' og skrive over for andre brukere osv.'}, {'timestamp': (498.32, 503.48), 'text': ' Så er det sånn som directory and system management med MKDIR.'}, {'timestamp': (503.8, 509.48), 'text': ' Link... mount... Vi ser sånn som MKD-er.'}, {'timestamp': (509.48, 515.48), 'text': ' Det er en del av de Shell-kommandoene som faktisk heter det samme som systemcall.'}, {'timestamp': (515.48, 521.16), 'text': ' Og i C så er alle disse systemcallene implementert.'}, {'timestamp': (521.18, 525.66), 'text': ' Så dermed så kan man skrive C-programmer'}, {'timestamp': (525.66, 531.6), 'text': ' som direkte utfører systemcall mot Linux-kjernen.'}, {'timestamp': (533.8, 537.6), 'text': ' En del sånn diverse, sånn som Kill, for eksempel,'}, {'timestamp': (537.68, 542.68), 'text': ' som opplagt trengs et systemkall for å gjøre.'}, {'timestamp': (542.76, 547.68), 'text': ' Det kan heller ikke en brukerprosess gjøre'}, {'timestamp': (547.7, 552.08), 'text': ' mot f.eks. andre brukere.'}, {'timestamp': (555.84, 562.0), 'text': ' Ja, her er noen vindussystemkall. Jeg har satt opp en masse systemkall'}, {'timestamp': (563.8, 573.2), 'text': ' Dette er bare for å illustrere at alle moderne operativsystemer'}, {'timestamp': (573.28, 577.64), 'text': ' har en tilsvarende mekanisme med systemcall.'}, {'timestamp': (577.64, 582.46), 'text': ' Men ofte er ting ganske forskjellig, sånn som Windows 32.'}, {'timestamp': (582.46, 589.08), 'text': ' Har ikke fork i utgangspunktet. De har rett og slett en create process.'}, {'timestamp': (589.08, 593.56), 'text': ' Det er da et systemcall som lager en ny prosess.'}, {'timestamp': (593.8, 597.0), 'text': ' Akkurat som Linux har Read,'}, {'timestamp': (597.0, 603.36), 'text': ' så har Windows-operativstemme ReadFile for å lese data fra en fil.'}, {'timestamp': (603.36, 608.52), 'text': ' Men i prinsippet så virker Windows og andre operativstemmer'}, {'timestamp': (608.6, 615.28), 'text': ' på nøyaktig samme måte, at det må gjøre systemkall for å...'}, {'timestamp': (615.28, 623.48), 'text': ' Vanlige brukerprosesser må gjøre systemkall når de skal gjøre kjerneoperasjoner.'}, {'timestamp': (623.8, 628.0), 'text': ' Alt som har med å snakke med hardware,'}, {'timestamp': (628.08, 631.2), 'text': ' og alt som har med å styre prosesser.'}, {'timestamp': (631.28, 640.0), 'text': ' Det er typisk kjernevirksomhet som man er nødt til å gjøre systemcall for å få utført.'}]}