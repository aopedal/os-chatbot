{'text': " Avslutte prosesser... Det er mange måter å stoppe prosesser på. Vi kan ha en normal avslutning, frivillig. I et chell kan jeg skrive 'exit'. Da stopper vi, eller i C - exit. Så kan vi ha en avslutning med feil. Det er også frivillig. Men så kan man ha fatale feil. At det er en ufrivillig situasjon hvor det er vanskelig for operativstøtten å gå videre. F.eks. deling med null. Hvordan skal du da kunne gå videre? Da kan hele programmet krasje. Også hvis et program prøver å skrive til en del av minnene som en ikke har lov til, eller gjøre noe virkelig galt. Da får du gjerne en sånn segmentation fault. Og det betyr at det er et eller annet minneprogram. Fatal feil som programmet gjør, og at det da vil avsluttes. Så kan du bli drept av andre prosesser. I Linux har vi sett for eksempel kjørekill eller terminert prosess i Windows. I motsetning til Unix, som er hva... Jo... Unix er så mangt, men hvis vi ser på Linux, så er Linux stort sett skrevet i C. Det er noen ganger i uken når du skal se på alle kodelinjene i kildekoden. Dere vil da se at de aller fleste linjene er C. Ikke objektorientert. Det vil si at Linus-jern er da ikke bygd opp av objekter. Men den er jo veldig modulær. Hvis man har et objektorientert språk, så er man fullstendig tvunget til å skrive objekter og gjøre det modulært med objekter og metoder osv. Men det går også an å skrive programmer i programmeringsspråk som ikke er objektorienterte, på en veldig ryddig, modulær og systematisk måte. Det kan man jo si Linux er, men i utgangspunktet så er da Linux ikke objektorientert. Det har ikke... Rett og slett fordi ser programmeringsspråkets krefter ikke er objektorienterte. Men at det ikke er objektorientert, betyr ikke at det ikke er metoder og funksjoner osv. Det har det. Så det er veldig systematisk oppbygd, men det har ikke en eksplisitt objektorientering. Signaler... Ja, det har vi. Sett på tidligere... Jeg hadde et script som... Som jeg kjørte, og som brukte en kommando som heter trapp til å fange opp signaler. Det er ikke den trappen man har i kjernen, men den... En Shell-kommando som kan ta ut mot et kill-signal. F.eks. kontroll C er vel kill-signalet 2. Og så kan den behandle... Alle prosesser kan ta imot signaler og beholde dem. Et unntak er kill-minus-ni. Det er en sånn sure kill, så den vil drepe prosessen. Jeg kjørte en liten demo av den i en tidligere forelesning, så jeg kan legge inn en link tilbake dit. Så kan man studere hvordan man kan sende signaler til prosesser. Det er måten prosesser kommuniserer på. Det er ikke nødvendigvis kill, men man kan sende signaler om andre ting også.", 'chunks': [{'timestamp': (0.0, 7.88), 'text': ' Avslutte prosesser... Det er mange måter å stoppe prosesser på.'}, {'timestamp': (7.88, 13.04), 'text': ' Vi kan ha en normal avslutning, frivillig.'}, {'timestamp': (13.22, 19.98), 'text': " I et chell kan jeg skrive 'exit'. Da stopper vi, eller i C - exit."}, {'timestamp': (22.3, 27.78), 'text': ' Så kan vi ha en avslutning med feil. Det er også frivillig.'}, {'timestamp': (30.0, 36.38), 'text': ' Men så kan man ha fatale feil. At det er en ufrivillig situasjon'}, {'timestamp': (36.46, 41.22), 'text': ' hvor det er vanskelig for operativstøtten å gå videre.'}, {'timestamp': (41.3, 45.82), 'text': ' F.eks. deling med null. Hvordan skal du da kunne gå videre?'}, {'timestamp': (45.9, 48.9), 'text': ' Da kan hele programmet krasje.'}, {'timestamp': (48.98, 54.1), 'text': ' Også hvis et program prøver å skrive til en del av minnene'}, {'timestamp': (54.14, 58.9), 'text': ' som en ikke har lov til, eller gjøre noe virkelig galt.'}, {'timestamp': (60.0, 64.74), 'text': ' Da får du gjerne en sånn segmentation fault.'}, {'timestamp': (64.78, 68.24), 'text': ' Og det betyr at det er et eller annet minneprogram.'}, {'timestamp': (68.26, 73.34), 'text': ' Fatal feil som programmet gjør, og at det da vil avsluttes.'}, {'timestamp': (73.36, 77.68), 'text': ' Så kan du bli drept av andre prosesser.'}, {'timestamp': (77.78, 85.78), 'text': ' I Linux har vi sett for eksempel kjørekill eller terminert prosess i Windows.'}, {'timestamp': (90.0, 93.78), 'text': ' I motsetning til Unix, som er hva...'}, {'timestamp': (93.78, 99.78), 'text': ' Jo... Unix er så mangt, men hvis vi ser på Linux,'}, {'timestamp': (99.9, 105.58), 'text': ' så er Linux stort sett skrevet i C.'}, {'timestamp': (106.7, 112.86), 'text': ' Det er noen ganger i uken når du skal se på alle kodelinjene i kildekoden.'}, {'timestamp': (112.86, 117.38), 'text': ' Dere vil da se at de aller fleste linjene er C.'}, {'timestamp': (120.0, 123.18), 'text': ' Ikke objektorientert.'}, {'timestamp': (123.18, 131.78), 'text': ' Det vil si at Linus-jern er da ikke bygd opp av objekter.'}, {'timestamp': (132.62, 137.18), 'text': ' Men den er jo veldig modulær.'}, {'timestamp': (138.3, 144.3), 'text': ' Hvis man har et objektorientert språk, så er man fullstendig tvunget til'}, {'timestamp': (144.38, 149.7), 'text': ' å skrive objekter og gjøre det modulært med objekter og metoder osv.'}, {'timestamp': (150.0, 157.8), 'text': ' Men det går også an å skrive programmer i programmeringsspråk'}, {'timestamp': (157.8, 166.28), 'text': ' som ikke er objektorienterte, på en veldig ryddig, modulær og systematisk måte.'}, {'timestamp': (166.28, 173.76), 'text': ' Det kan man jo si Linux er, men i utgangspunktet så er da Linux ikke objektorientert.'}, {'timestamp': (173.84, 178.04), 'text': ' Det har ikke... Rett og slett fordi ser programmeringsspråkets krefter ikke er objektorienterte.'}, {'timestamp': (180.0, 188.84), 'text': ' Men at det ikke er objektorientert, betyr ikke at det ikke er'}, {'timestamp': (188.84, 194.02), 'text': ' metoder og funksjoner osv. Det har det.'}, {'timestamp': (194.02, 199.0), 'text': ' Så det er veldig systematisk oppbygd, men det har ikke'}, {'timestamp': (199.12, 202.68), 'text': ' en eksplisitt objektorientering.'}, {'timestamp': (205.34, 209.98), 'text': ' Signaler... Ja, det har vi.'}, {'timestamp': (210.0, 215.08), 'text': ' Sett på tidligere... Jeg hadde et script som...'}, {'timestamp': (215.52, 221.32), 'text': ' Som jeg kjørte, og som brukte en kommando som heter trapp'}, {'timestamp': (221.32, 224.34), 'text': ' til å fange opp signaler.'}, {'timestamp': (224.34, 229.44), 'text': ' Det er ikke den trappen man har i kjernen, men den...'}, {'timestamp': (229.44, 234.98), 'text': ' En Shell-kommando som kan ta ut mot et kill-signal.'}, {'timestamp': (235.04, 239.96), 'text': ' F.eks. kontroll C er vel kill-signalet 2. Og så kan den behandle...'}, {'timestamp': (240.0, 246.06), 'text': ' Alle prosesser kan ta imot signaler og beholde dem.'}, {'timestamp': (246.14, 249.02), 'text': ' Et unntak er kill-minus-ni.'}, {'timestamp': (249.02, 254.98), 'text': ' Det er en sånn sure kill, så den vil drepe prosessen.'}, {'timestamp': (255.5, 259.78), 'text': ' Jeg kjørte en liten demo av den i en tidligere forelesning,'}, {'timestamp': (259.86, 263.7), 'text': ' så jeg kan legge inn en link tilbake dit.'}, {'timestamp': (263.7, 269.1), 'text': ' Så kan man studere hvordan man kan sende signaler til prosesser.'}, {'timestamp': (270.0, 274.92), 'text': ' Det er måten prosesser kommuniserer på.'}, {'timestamp': (275.0, 281.0), 'text': ' Det er ikke nødvendigvis kill, men man kan sende signaler om andre ting også.'}]}