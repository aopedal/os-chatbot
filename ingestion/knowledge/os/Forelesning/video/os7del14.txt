{'text': ' Ja, hyperthreading er opprinnelig en markedsføringsterminologi som Intel innførte. Det er altså Intels varemerke hyperthreading. Som vi ser her nede, så er den generelle betegnelsen SMT. Simultaneous Multithreading. Så når AMD bruker det samme prinsippet, så kaller de det for SMT. Men vi ser først på Intel og Hyperthreading. Hyperthreading består i at én single core CPU, dvs. én CPU som har én enkelt alu, én regneenhet, én kjerne, kan inneholde to prosesser samtidig. Litt av innholdet i CPU-ene er da duplisert, spesielt registre. For det kan ikke lastes ut. Men dette foregår da på hardware-nivå. Så operativsystemet opplever dette som to selvstendige prosessorer. Det lister det i topp som to selvstendige prosessorer. Men det som skjer i virkeligheten, er at når OS fordeler prosesser til denne prosessoren som er hypertraining, så settes det i gang. Men de to prosessene deler da Alun, som er på denne CPU-en. Og da er det Hardware som switcher kjøpt imellom de to prosessene. Og dette skjer i løpet av nanosekunder, altså ekstremt hurtig. Og dette er ikke i nærheten av det som skjer når man gjør Context Switch med OS. Det tar veldig mye lengre tid. Og denne teknologien er da lagd fordi man har sett at... Selv om man har pipelining og mikrooperasjoner som utføres i parallell på superskalare CPU-er. Til tross for det, så vil det hele tiden være litt hardware-ressurser som ikke blir brukt. F.eks. at alun ikke blir utnyttet fullstendig. Og det er typisk, for selv med cash må man noen ganger vente på... Resultater eller vente på noe fra RAM eller fra andre devices. Denne ventetiden utnyttes av å lynhurtig switche frem og tilbake mellom de to prosessene som kjører. Det er dette som er hypertrening. Det typiske er at de har egne registre for hver prosess, men deler felles ALU. Etterpå skal vi kjøre noen tester, og da vil vi se at... Det går saktere når man har hypertrening, fordi de må dele på alle. Og som jeg nevnte, hypertrening styres og har det vel. Så OS vet egentlig ikke noe om dette her. Ja, de vet litt om det, men den er ikke med og styrer. Den bare gir prosesser til CPU-en, og så utfører CPU-en disse lynhurtige switchene mellom de to. I tillegg til prosessen om Kjell.', 'chunks': [{'timestamp': (0.0, 5.48), 'text': ' Ja, hyperthreading er opprinnelig'}, {'timestamp': (5.48, 11.88), 'text': ' en markedsføringsterminologi som Intel innførte.'}, {'timestamp': (11.88, 16.2), 'text': ' Det er altså Intels varemerke hyperthreading.'}, {'timestamp': (16.2, 21.8), 'text': ' Som vi ser her nede, så er den generelle betegnelsen SMT.'}, {'timestamp': (21.92, 24.56), 'text': ' Simultaneous Multithreading.'}, {'timestamp': (24.68, 29.96), 'text': ' Så når AMD bruker det samme prinsippet, så kaller de det for SMT.'}, {'timestamp': (30.0, 33.98), 'text': ' Men vi ser først på Intel og Hyperthreading.'}, {'timestamp': (34.0, 38.6), 'text': ' Hyperthreading består i at én single core CPU,'}, {'timestamp': (38.6, 44.96), 'text': ' dvs. én CPU som har én enkelt alu, én regneenhet, én kjerne,'}, {'timestamp': (45.04, 48.76), 'text': ' kan inneholde to prosesser samtidig.'}, {'timestamp': (48.76, 57.4), 'text': ' Litt av innholdet i CPU-ene er da duplisert, spesielt registre.'}, {'timestamp': (60.0, 67.22), 'text': ' For det kan ikke lastes ut. Men dette foregår da på hardware-nivå.'}, {'timestamp': (67.22, 72.62), 'text': ' Så operativsystemet opplever dette som to selvstendige prosessorer.'}, {'timestamp': (72.64, 76.04), 'text': ' Det lister det i topp som to selvstendige prosessorer.'}, {'timestamp': (76.04, 82.32), 'text': ' Men det som skjer i virkeligheten, er at når OS fordeler'}, {'timestamp': (82.32, 89.6), 'text': ' prosesser til denne prosessoren som er hypertraining, så settes det i gang.'}, {'timestamp': (90.0, 98.12), 'text': ' Men de to prosessene deler da Alun, som er på denne CPU-en.'}, {'timestamp': (98.12, 102.86), 'text': ' Og da er det Hardware som switcher kjøpt imellom de to prosessene.'}, {'timestamp': (102.88, 107.56), 'text': ' Og dette skjer i løpet av nanosekunder, altså ekstremt hurtig.'}, {'timestamp': (107.56, 112.24), 'text': ' Og dette er ikke i nærheten av det som skjer når man gjør Context Switch med OS.'}, {'timestamp': (112.36, 114.84), 'text': ' Det tar veldig mye lengre tid.'}, {'timestamp': (114.84, 119.92), 'text': ' Og denne teknologien er da lagd fordi man har sett at...'}, {'timestamp': (120.0, 126.74), 'text': ' Selv om man har pipelining og mikrooperasjoner'}, {'timestamp': (126.76, 133.36), 'text': ' som utføres i parallell på superskalare CPU-er.'}, {'timestamp': (133.44, 138.4), 'text': ' Til tross for det, så vil det hele tiden være litt hardware-ressurser'}, {'timestamp': (139.36, 144.8), 'text': ' som ikke blir brukt. F.eks. at alun ikke blir utnyttet fullstendig.'}, {'timestamp': (144.8, 149.8), 'text': ' Og det er typisk, for selv med cash må man noen ganger vente på...'}, {'timestamp': (150.0, 157.8), 'text': ' Resultater eller vente på noe fra RAM eller fra andre devices.'}, {'timestamp': (157.88, 163.4), 'text': ' Denne ventetiden utnyttes av å lynhurtig switche frem og tilbake'}, {'timestamp': (163.48, 169.08), 'text': ' mellom de to prosessene som kjører. Det er dette som er hypertrening.'}, {'timestamp': (169.08, 176.32), 'text': ' Det typiske er at de har egne registre for hver prosess, men deler felles ALU.'}, {'timestamp': (176.32, 179.92), 'text': ' Etterpå skal vi kjøre noen tester, og da vil vi se at...'}, {'timestamp': (180.0, 186.16), 'text': ' Det går saktere når man har hypertrening, fordi de må dele på alle.'}, {'timestamp': (186.16, 191.0), 'text': ' Og som jeg nevnte, hypertrening styres og har det vel.'}, {'timestamp': (191.0, 195.0), 'text': ' Så OS vet egentlig ikke noe om dette her.'}, {'timestamp': (195.48, 199.32), 'text': ' Ja, de vet litt om det, men den er ikke med og styrer.'}, {'timestamp': (200.18, 209.64), 'text': ' Den bare gir prosesser til CPU-en, og så utfører CPU-en disse lynhurtige switchene mellom de to.'}, {'timestamp': (210.0, 214.0), 'text': ' I tillegg til prosessen om Kjell.'}]}