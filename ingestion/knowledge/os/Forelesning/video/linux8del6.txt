{'text': ' Først og fremst skal vi se på dokkefiles. Men før det så skal vi prøve å se litt på volumes. Og generelt hvordan man får dokkefilene... Nei, får konteinerne til å koble seg opp mot det lokale filsystemet. For da kan man... Hvis man kobler en dokkefil til... Så kan man da koble løs containeren, sånn at den er en uavhengig enhet som raskt kan startes og stoppes. For hele tiden ønsker man å ha konteinere uavhengige. De skal gjerne gjøre så lite som mulig. Typisk så kjører en container én prosess. F.eks. én webserver, eller én applikasjon som skal testes og kjøres. Men vi vil gjerne kunne stoppe starten. Og gjerne kaste den også, bygge den på nytt. Uten at innholdet blir kastet. Så derfor skal vi nå begynne å se litt på volumer og hvordan man kobler til eksterne filer til en dokkerinstans. Dokkerinstans er da det samme som en container. Så det er en annen måte å si container på. Da skal jeg... I stedet dele slidene til Mike Long, som vi så på sist. Vi har en ca. 20 slider til. Da skal vi se på volumer. Ja... Dukkevolum, det er da... Som jeg sa, det er en mappe. Eller en fil som man bruker for å koble opp varige filer til en dokkeinstans. Sånn at man kan... Sånn at en... Selv om man da dreper og til og med avslutter.... så kan man bruke de samme filene senere. Ved å bygge en ny container fra et nytt image og koble opp mot de samme filene. Så kan de også deles mellom containere. Det er et par-tre måter å gjøre dette på. Det er som en link. Du kan ha en fil eller mappe her i containeren som peker direkte på en mappe på filsystemet på hosen du kjører containeren. Da kan du endre på filene på hosen, og så endres det i containeren. En litt mer abstrakt og foretrukket metode er volum. Et volum, det defineres av dokker-dimen. Så da er det dokker som står og styrer. Dette kan i større grad gjøre at konteinere kan dele data med hverandre også. Så dette er en litt mer abstrakt måte å styre filer på. Som også er styrt av dokker. Sånn at det er dokker som styrer dette. Så kan jeg altså montere direkte minne, det kommer ikke vi til å se på. De to måtene vi skal se på, er bind-mounts... Det er da direkte å binde hosen. Når man starter en container... Docky container run... Så legger man på den opsjonen minus v. Og slash house dir er da filsystemet her på hosen. I vårt tilfelle er det på Linux v. Og så slash-app. Det er da filsystemet i containeren. Så det vi skal gjøre etterpå, er å koble det til vår WWW hotml på containeren. Koble det til et filsystem her, sånn at vi kan endre innholdet på webserveren mens den kjører. Dette gjør det samme med et volum, men da må vi først gi dokker. Kreere et volum med docker volum create, og så navnet på volumet. Men det er fortsatt litt tilsvarende. Den vil da i praksis ligge på i fyllsystemet her, men den kan da styres av docker. Så vi skal straks ta en pause, men vi ser her... Hvis dere vil prøve på dette i pausen, Og starte å gjøre oppgaver. Før vi tar pause... Det er noen volum... Volume, best practices. Container should be ephemeral. Og det betyr at de skal være bruk og kast. Altså de skal ikke være evigvarende. Det er liksom hele filosofien. Men dette er et litt mer sånn avansert råd. Avoid monting directories from the host in production. Det som er en kanskje enda bedre måte å gjøre dette på, er å ha egne containere som inneholder data. Og som det står her, dette er hvordan det er brukt i Kates K8S. Det er da en forkortelse for Kubernet. Men det vi skal se på i dag, er hvordan vi faktisk monterer pilsystemer fra Håsen inn i...', 'chunks': [{'timestamp': (0.0, 4.12), 'text': ' Først og fremst skal vi se på dokkefiles.'}, {'timestamp': (4.12, 12.0), 'text': ' Men før det så skal vi prøve å se litt på volumes.'}, {'timestamp': (12.0, 17.88), 'text': ' Og generelt hvordan man får dokkefilene...'}, {'timestamp': (18.56, 24.76), 'text': ' Nei, får konteinerne til å koble seg opp mot det lokale filsystemet.'}, {'timestamp': (24.88, 27.92), 'text': ' For da kan man... Hvis man kobler en dokkefil til...'}, {'timestamp': (30.0, 38.16), 'text': ' Så kan man da koble løs containeren, sånn at den er en uavhengig enhet'}, {'timestamp': (38.28, 44.36), 'text': ' som raskt kan startes og stoppes. For hele tiden ønsker man å ha konteinere uavhengige.'}, {'timestamp': (44.36, 49.2), 'text': ' De skal gjerne gjøre så lite som mulig. Typisk så kjører en container én prosess.'}, {'timestamp': (49.32, 54.2), 'text': ' F.eks. én webserver, eller én applikasjon som skal testes og kjøres.'}, {'timestamp': (54.2, 59.92), 'text': ' Men vi vil gjerne kunne stoppe starten.'}, {'timestamp': (60.02, 64.06), 'text': ' Og gjerne kaste den også, bygge den på nytt.'}, {'timestamp': (64.46, 70.82), 'text': ' Uten at innholdet blir kastet. Så derfor skal vi nå begynne å se litt på volumer'}, {'timestamp': (71.78, 78.38), 'text': ' og hvordan man kobler til eksterne filer til en dokkerinstans.'}, {'timestamp': (78.38, 82.74), 'text': ' Dokkerinstans er da det samme som en container.'}, {'timestamp': (82.76, 88.66), 'text': ' Så det er en annen måte å si container på. Da skal jeg...'}, {'timestamp': (90.0, 102.34), 'text': ' I stedet dele slidene til Mike Long, som vi så på sist.'}, {'timestamp': (102.34, 111.26), 'text': ' Vi har en ca. 20 slider til. Da skal vi se på volumer.'}, {'timestamp': (120.0, 130.58), 'text': ' Ja... Dukkevolum, det er da... Som jeg sa, det er en mappe.'}, {'timestamp': (130.7, 141.62), 'text': ' Eller en fil som man bruker for å koble opp varige filer til en dokkeinstans.'}, {'timestamp': (141.74, 148.94), 'text': ' Sånn at man kan... Sånn at en... Selv om man da dreper og til og med avslutter.'}, {'timestamp': (150.0, 156.32), 'text': '... så kan man bruke de samme filene senere.'}, {'timestamp': (156.48, 160.16), 'text': ' Ved å bygge en ny container fra et nytt image'}, {'timestamp': (160.24, 163.76), 'text': ' og koble opp mot de samme filene.'}, {'timestamp': (163.76, 169.08), 'text': ' Så kan de også deles mellom containere.'}, {'timestamp': (169.12, 173.4), 'text': ' Det er et par-tre måter å gjøre dette på.'}, {'timestamp': (180.0, 186.3), 'text': ' Det er som en link. Du kan ha en fil eller mappe her i containeren'}, {'timestamp': (186.32, 190.68), 'text': ' som peker direkte på en mappe på filsystemet på hosen du kjører containeren.'}, {'timestamp': (190.68, 195.64), 'text': ' Da kan du endre på filene på hosen, og så endres det i containeren.'}, {'timestamp': (195.64, 203.0), 'text': ' En litt mer abstrakt og foretrukket metode er volum.'}, {'timestamp': (203.0, 208.6), 'text': ' Et volum, det defineres av dokker-dimen. Så da er det dokker som står og styrer.'}, {'timestamp': (210.0, 219.0), 'text': ' Dette kan i større grad gjøre at konteinere kan dele data med hverandre også.'}, {'timestamp': (219.12, 223.44), 'text': ' Så dette er en litt mer abstrakt måte å styre filer på.'}, {'timestamp': (223.44, 230.56), 'text': ' Som også er styrt av dokker. Sånn at det er dokker som styrer dette.'}, {'timestamp': (231.46, 237.88), 'text': ' Så kan jeg altså montere direkte minne, det kommer ikke vi til å se på.'}, {'timestamp': (240.0, 244.8), 'text': ' De to måtene vi skal se på, er bind-mounts...'}, {'timestamp': (244.82, 250.08), 'text': ' Det er da direkte å binde hosen.'}, {'timestamp': (252.32, 255.68), 'text': ' Når man starter en container...'}, {'timestamp': (257.26, 261.18), 'text': ' Docky container run... Så legger man på den opsjonen minus v.'}, {'timestamp': (261.18, 266.28), 'text': ' Og slash house dir er da filsystemet her på hosen.'}, {'timestamp': (266.28, 269.0), 'text': ' I vårt tilfelle er det på Linux v.'}, {'timestamp': (270.02, 276.26), 'text': ' Og så slash-app. Det er da filsystemet i containeren.'}, {'timestamp': (276.26, 284.14), 'text': ' Så det vi skal gjøre etterpå, er å koble det til vår WWW hotml på containeren.'}, {'timestamp': (284.26, 289.9), 'text': ' Koble det til et filsystem her, sånn at vi kan endre innholdet på'}, {'timestamp': (289.92, 293.18), 'text': ' webserveren mens den kjører.'}, {'timestamp': (293.18, 299.9), 'text': ' Dette gjør det samme med et volum, men da må vi først gi dokker.'}, {'timestamp': (300.0, 308.1), 'text': ' Kreere et volum med docker volum create, og så navnet på volumet.'}, {'timestamp': (308.12, 313.04), 'text': ' Men det er fortsatt litt tilsvarende.'}, {'timestamp': (313.12, 320.72), 'text': ' Den vil da i praksis ligge på i fyllsystemet her, men den kan da styres av docker.'}, {'timestamp': (320.74, 328.42), 'text': ' Så vi skal straks ta en pause, men vi ser her... Hvis dere vil prøve på dette i pausen,'}, {'timestamp': (330.0, 335.68), 'text': ' Og starte å gjøre oppgaver.'}, {'timestamp': (335.68, 341.52), 'text': ' Før vi tar pause... Det er noen volum...'}, {'timestamp': (342.26, 345.84), 'text': ' Volume, best practices. Container should be ephemeral.'}, {'timestamp': (345.84, 353.48), 'text': ' Og det betyr at de skal være bruk og kast. Altså de skal ikke være evigvarende.'}, {'timestamp': (353.52, 357.96), 'text': ' Det er liksom hele filosofien.'}, {'timestamp': (360.0, 363.56), 'text': ' Men dette er et litt mer sånn avansert råd.'}, {'timestamp': (363.56, 368.72), 'text': ' Avoid monting directories from the host in production.'}, {'timestamp': (368.72, 374.56), 'text': ' Det som er en kanskje enda bedre måte å gjøre dette på,'}, {'timestamp': (374.56, 379.32), 'text': ' er å ha egne containere som inneholder data.'}, {'timestamp': (379.4, 385.36), 'text': ' Og som det står her, dette er hvordan det er brukt i Kates K8S.'}, {'timestamp': (385.36, 388.44), 'text': ' Det er da en forkortelse for Kubernet.'}, {'timestamp': (390.0, 400.0), 'text': ' Men det vi skal se på i dag, er hvordan vi faktisk monterer pilsystemer fra Håsen inn i...'}]}