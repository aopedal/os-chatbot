<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>6 Forelesning 26/2-24(2 timer). Branch prediction, Multitasking</TITLE>
<META NAME="description" CONTENT="6 Forelesning 26/2-24(2 timer). Branch prediction, Multitasking">
<META NAME="keywords" CONTENT="os">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY  bgcolor="#ffffff">
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html985"
  HREF="node7.html#SECTION00071000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
<LI><A ID="tex2html986"
  HREF="node7.html#SECTION00072000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sist</A>
<LI><A ID="tex2html987"
  HREF="node7.html#SECTION00073000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> branch prediction</A>
<LI><A ID="tex2html988"
  HREF="node7.html#SECTION00074000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Meltdown</A>
<LI><A ID="tex2html989"
  HREF="node7.html#SECTION00075000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Viktig å huske fra datamaskinarkitektur</A>
<LI><A ID="tex2html990"
  HREF="node7.html#SECTION00076000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> OS historie</A>
<UL>
<LI><A ID="tex2html991"
  HREF="node7.html#SECTION00076100000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Microsoft Desktop-OS</A>
<LI><A ID="tex2html992"
  HREF="node7.html#SECTION00076200000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Microsoft Server-OS</A>
<LI><A ID="tex2html993"
  HREF="node7.html#SECTION00076300000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Unix operativsystemer</A>
<LI><A ID="tex2html994"
  HREF="node7.html#SECTION00076400000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interrupts (avbrytelser)</A>
</UL>
<BR>
<LI><A ID="tex2html995"
  HREF="node7.html#SECTION00077000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> Singletasking OS</A>
<UL>
<LI><A ID="tex2html996"
  HREF="node7.html#SECTION00077100000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Internminne-kart</A>
</UL>
<BR>
<LI><A ID="tex2html997"
  HREF="node7.html#SECTION00078000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> Multitasking-OS</A>
<LI><A ID="tex2html998"
  HREF="node7.html#SECTION00079000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> Multitasking</A>
<LI><A ID="tex2html999"
  HREF="node7.html#SECTION000710000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN>  PCB -Process Control Block</A>
<LI><A ID="tex2html1000"
  HREF="node7.html#SECTION000711000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> Timesharing og Context Switch</A>
<LI><A ID="tex2html1001"
  HREF="node7.html#SECTION000712000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> Multitasking i praksis, CPU-intensive programmer</A>
<LI><A ID="tex2html1002"
  HREF="node7.html#SECTION000713000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> Multitasking eksempel</A>
<LI><A ID="tex2html1003"
  HREF="node7.html#SECTION000714000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> CPU-intensiv prosess på system med èn CPU</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION00070000000000000000">
<SPAN CLASS="arabic">6</SPAN> Forelesning 26/2-24(2 timer).  Branch prediction, Multitasking</A>
</H1>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Avsnitt fra Tanenbaum: 1.3-1.6
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<A ID="tex2html153"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/os6.pdf">Slides brukt i forelesningen</A>
<P>

<H2><A ID="SECTION00071000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
</H2>
Opptak av forelesningen:

<P>
<A ID="tex2html154"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6time1.mp4">os6time1.mp4</A>
(43:50) Uredigert opptak av første time av forelesningen. 
<BR><A ID="tex2html155"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6time2.mp4">os6time2.mp4</A>
(54:03) Uredigert opptak av andre time av forelesningen. 
<BR>
<P>
Opptak av forelesningen inndelt etter temaer:

<P>
<A ID="tex2html156"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del1.mp4">os6del1.mp4</A>
(05:05) Praktisk info, MC1, oblig2

<BR><A ID="tex2html157"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del2.mp4">os6del2.mp4</A>
(03:31) Intro om Linux-VMer (Docker containere)

<BR><A ID="tex2html158"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del3.mp4">os6del3.mp4</A>
(07:10) Demo: Innlogging på Linux-VMer (Docker containere)

<BR><A ID="tex2html159"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del4.mp4">os6del4.mp4</A>
(02:04) Intro, hva vi gjorde sist

<BR><A ID="tex2html160"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del5.mp4">os6del5.mp4</A>
(08:08) Slides: Branch prediction og Meltdown

<BR><A ID="tex2html161"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del6.mp4">os6del6.mp4</A>
(13:19) Demo: branch prediction i praksis

<BR><A ID="tex2html162"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del7.mp4">os6del7.mp4</A>
(04:21) Spørsmål, hvordan få os-passord og logge seg inn på VM (repetisjon)

<BR><A ID="tex2html163"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del8.mp4">os6del8.mp4</A>
(03:06) Slides: Oppsummering av datamaskinarkitektur

<BR><A ID="tex2html164"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del9.mp4">os6del9.mp4</A>
(09:29) Slides: OS-historie, Microsoft OS

<BR><A ID="tex2html165"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del10.mp4">os6del10.mp4</A>
(02:45) Slides: OS-historie, Unix OS

<BR><A ID="tex2html166"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del11.mp4">os6del11.mp4</A>
(09:19) Slides: Intro til multitasking

<BR><A ID="tex2html167"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del12.mp4">os6del12.mp4</A>
(06:18) Slides: Context Switch og PCB (Prosess Control Block)

<BR><A ID="tex2html168"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del13.mp4">os6del13.mp4</A>
(03:30) Slides: Multitasking i praksis

<BR><A ID="tex2html169"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del14.mp4">os6del14.mp4</A>
(08:42) Demo: Multitasking i praksis

<BR><A ID="tex2html170"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os6del15.mp4">os6del15.mp4</A>
(01:09) Spørsmål: Hvilke prosesser er ikke CPU-avhengige?

<BR>
<P>

<H2><A ID="SECTION00072000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sist</A>
</H2>

<UL>
<LI>En C-linje kan gi mange linjer assembly/maskinkode
</LI>
<LI>Kompilering av høynivåkode til maskinkode er komplisert og ikke entydig
</LI>
<LI>Kompilering av assembly til maskinkode er direkte og entydig
</LI>
<LI>En enkelt assembly instruksjon er delt inn i mikro-operasjoner og utføres i parallelle pipelines
</LI>
</UL>

<P>

<H2><A ID="SECTION00073000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> branch prediction</A>
</H2>

<UL>
<LI>Ved en branch i programmet (if-test), vet man ikke hva neste instruksjon er  
</LI>
<LI>Stort problem for pipelining, må vente på resultatet fra forrige instruksjon
</LI>
<LI>Gjetter, basert på erfaring, hvilken branch (gren) som følges i programmet og utfører den
</LI>
<LI>Speculative execution, må gjøres om hvis feil
</LI>
<LI>I et superskalær arkitektur kan begge grener delvis utføres på forhånd
</LI>
</UL>

<P>
Følgende <code>C++</code> program inneholder kode som viser hva konsekvensene av branch prediction kan være. I starten av programmet lages et data-array med tilfeldig trukkede heltall mellom 0 og 255. De 10 første tallene blir skrevet ut og så gjentas en ytre løkke 100.000 ganger for at man skal få mer nøyaktige målinger av hvor lang tid den indre løkken tar. Den indre løkken består av at man går igjennom hvert element i det store arrayet og legger til verdien <code>data[c]</code> til en variable sum hvis verdien er større enn 127. I praksis vil dette skje omtrent halvparten av gangene.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{
   // Lager et data-array
   int i,c;
   int arraySize = 32768;
   int data[arraySize];
   
   for (c = 0; c &lt; arraySize; ++c)
     {
       data[c] = rand() % 256;
     }
   
   // Gir tilfeldig tall mellom 0 og 255
   // Gir samme array med tall for hver kjøring
	
   // sort(data, data + arraySize);
   // sorterter data-arrayet
   
   // Skriver ut de 10 første verdiene
   for (c = 0; c &lt; 10; c++)
     cout &lt;&lt; data[c] &lt;&lt; "\n";
   
   // Legger sammen alle tall større enn 127
   long sum = 0;
   
   // Ytre løkke for at det skal ta litt tid...
   for (i = 0; i &lt; 100000; ++i)
     {
        // Indre løkke
        for (c = 0; c &lt; arraySize; ++c)
           {
             if (data[c] &gt; 127)
             sum += data[c];
           }
     }
   
   cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; "\n";
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Deretter kompileres <code>C++</code> programmet og kjøres på en Linux-maskin:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ g++ b.cpp
$ time ./a.out 
103
198
105
115
81
255
74
236
41
205
sum = 314931600000
Real:17.095 User:17.096 System:0.000 100.00%
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>Kommandoen <code>time</code> tar tiden på programmet som kjøres og gir som resultat at programmet har brukt 17.096 sekunder CPU-tid og at det har brukt CPU-en hele tiden (100%). Utskriften av de 10 første tallene viser at verdiene kommer i en tilfeldig rekkefølge og at de er over og under 127, slik at if-testen vil slå til en gang i blant og i gjennomsnitt ca halvparten av gangene.

<P>
Deretter gjøres en enkelt endring på koden ved at kommentartegnet foran linjen
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

sort(data, data + arraySize);
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>fjernes, slik at data-arrayet blir sortert før programmet kjører de to løkkene. Dette vil endre rekkefølgen for når if-testen slår til og dataene adderes til sum-variabelen, men det vil skje nøyaktig like mange ganger og som vi ser blir også summen nøyaktig den samme:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

0
0
0
0
0
0
0
0
0
sum = 314931600000
Real:6.285 User:6.280 System:0.000 99.91%
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>Utskriften av de første 10 elementene viser at data-arrayet er sortert og starter med alle 0-verdiene. Men det overraskende er at denne kjøringen går mer en dobbelt så fort og nesten bare tar en tredjedel av tiden til den første kjøringen. Og dette til tross for at nøyaktig de samme instruksjonene blir utført i begge tilfeller og det samme regnestykket gir samme resultat. Hva kan dette skyldes?

<P>

<H2><A ID="SECTION00074000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Meltdown</A>
</H2>

<UL>
<LI>Et hardware-sikkerhetshull funnet i 2018
</LI>
<LI>Rammet Intel, ARM og IBM-prosessorer
</LI>
<LI>Meltdown utnytter at både koden som sjekker om prosessen kan lese fra RAM og lesingen fra RAM delvis utføres
</LI>
<LI>Meltdown kan dermed lese data fra andre prosesser som er cache't men ennå ikke fjernet pga feil branch 
</LI>
<LI>Spectre brukte lignende metoder til å lese passord og sensitive data
</LI>
<LI>Betegnet som sikkerhets-katastrofe
</LI>
<LI>Både CPU design og operativsystemer ble endret for å hindre Meltdown og Spectre i å virke
</LI>
</UL>

<P>

<H2><A ID="SECTION00075000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Viktig å huske fra datamaskinarkitektur</A>
</H2>
På veien videre er det viktigste å huske fra datamaskinarkitektur at alt CPU-en gjør er å slavisk utføre maskininstruksjoner en for en i en evigvarende løkke; ihvertfall til maskinen skrus av. Legg også merke til at det ikke er noen en til en forbindelse mellom instruksjoner i høynivåkode og maskinkode. En linje kode i høynivåspråk fører ofte til mange maskininstruksjoner i det kompilerte programmet. 

<P>

<H2><A ID="SECTION00076000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> OS historie</A>
</H2>
Det er nyttig å vite litt om historien til noen av de mest brukte operativsystemene.

<P>

<H3><A ID="SECTION00076100000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Microsoft Desktop-OS</A>
</H3>

<P>
<DL>
<DT><STRONG>MS-DOS</STRONG></DT>
<DD>1981, 16-bit
</DD>
<DT><STRONG>Windows</STRONG></DT>
<DD>1.0 i 1985, 3.0 i 1990, GUI på toppen av DOS
</DD>
<DT><STRONG>Windows 95</STRONG></DT>
<DD>Noe 32-bit kode, mye 16-bit Intel assembler,DOS-filsystem, bruker DOS 
til å boote
</DD>
<DT><STRONG>Windows 98</STRONG></DT>
<DD>essensielt som 95, desktop/Internett integrert
</DD>
<DT><STRONG>Windows Me</STRONG></DT>
<DD>essensielt som 98, mer multimedia og nettverk support
</DD>
<DT><STRONG>Windows 2000</STRONG></DT>
<DD>Første (ikke så vellykkede) forsøk med Desktop OS basert på NT (5.0). 
</DD>
<DT><STRONG>Windows XP</STRONG></DT>
<DD>Oktober 2001, Desktop-OS som kombinerer NT 5.1 kode med Win 9x. Home edition: 1 CPU, 
XP Professional: 2CPU-er, logge inn utenfra, 32 og 64 bit
</DD>
<DT><STRONG>Windows Vista</STRONG></DT>
<DD>januar 2007. Kernel NT 6.0, Booter raskere, bedre filsøk, Ingen suksess. 
</DD>
<DT><STRONG>Windows 7</STRONG></DT>
<DD>oktober 2009, kjernen er Windows NT 6.1, PowerShell 2.0 default, 7 editions, Service Pack 1
</DD>
<DT><STRONG>Windows 8</STRONG></DT>
<DD>oktober 2012, NT 6.2, Start Screen, touch screen, USB 3.0, Windows Store, Windows RT for ARM
</DD>
<DT><STRONG>Windows 8.1</STRONG></DT>
<DD>oktober 2013, NT 6.3
</DD>
<DT><STRONG>Windows 10</STRONG></DT>
<DD>July 2015, NT 10.0(!), Microsoft Edge, virtual desktops, native Ubuntu bash shell(samarbeid med Canonical) gjennom Windows Subsystem for Linux
</DD>
<DT><STRONG>Windows 11</STRONG></DT>
<DD>October 2021, NT 10.0(!), ikke lenger støtte for 32-bit x86 CPUs, Internet Explorer ikke inkludert

<P>
</DD>
</DL>

<P>
<EM>Intels første 32-bit maskin var 386 fra 1985. 
Generelt problem før XP: Windows er bakover-kompatibelt til DOS, alle Win-prosesser kan ødelegge 
for kjernen og ta ned OS.</EM>

<P>

<H3><A ID="SECTION00076200000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Microsoft Server-OS</A>
</H3>
<DL>
<DT><STRONG>NT 3.1</STRONG></DT>
<DD>1993 32-bit, skrevet fra scratch i C (lite assembler), David Cutler (VAX-VMS designer), mye bedre sikkerhet og stabilitet enn Windows. 3.1 millioner linjer kode.
</DD>
<DT><STRONG>NT 4.0</STRONG></DT>
<DD>1996, Samme GUI som Win-95, 16 millioner linjer, portabelt <code>-&gt;</code> alpha, PowerPC
</DD>
<DT><STRONG>Windows 2000</STRONG></DT>
<DD>NT 5.0, opp til 32 CPU'er, features fra Win-98,
  Plug and Play, <code>\winnt\system32\ntoskrnl.exe</code>. 29 millioner
  linjer. <EM>MS-DOS borte, men 32-bits kommando-interface med samme
    funksjonalitet.</EM>
</DD>
<DT><STRONG>Windows Server 2003</STRONG></DT>
<DD>bygger på 2000
  server, NT 5.2, design med tanke på .NET: web, XML, C#, 32 og 64 bit, SP1, SP2, R2 i 2006
</DD>
<DT><STRONG>Windows Server 2008</STRONG></DT>
<DD>februar 2008, felles basis med Vista, første OS med PowerShell, Kan installeres som <B>Server core</B> og styres fra CLI (Command Line Interface), Hyper-V virtualisering
</DD>
<DT><STRONG>Windows Server 2008 R2</STRONG></DT>
<DD>oktober 2009, NT 6.1 (som Win 7), PowerShell 2.0 default, kun 64 bit
</DD>
<DT><STRONG>Windows Server 2012</STRONG></DT>
<DD>september 2012, NT 6.2 (som Win 8), cloud computing, oppdatert Hyper-V, nytt filsystem: ReFS
</DD>
<DT><STRONG>Windows Server 2012 R2</STRONG></DT>
<DD>oktober 2013, NT 6.3 (som Win 8.1)
</DD>
<DT><STRONG>Windows Server 2016</STRONG></DT>
<DD>september 2016, NT 10.0, Windows Defender, nano server: uten gui, fjernstyres med PowerShell
</DD>
<DT><STRONG>Windows Server 2019</STRONG></DT>
<DD>oktober 2018, NT 10.0, Windows Admin Center
</DD>
<DT><STRONG>Windows Server 2022</STRONG></DT>
<DD>August 2021, NT 10.0.2
</DD>
</DL>

<P>

<H3><A ID="SECTION00076300000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Unix operativsystemer</A>
</H3>
Dagens Unix-versjoner har utviklet seg fra to som dominerte rundt 1980:

<UL>
<LI>system V (AT&amp;T Bell Labs)
</LI>
<LI>BSD (University of California at Berkely )
</LI>
</UL>
De fleste av dagens varianter er bygd på SVR4 som er en blanding.
Følgende er kommersielle 64 bit Unix-OS for RISC-prosessorer som var 
dominerende i server-markedet et stykke inn på 2000-tallet:
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="LEFT">OS</TH>
<TH CLASS="LEFT">Eier</TH>
<TH CLASS="LEFT">hardware</TH>
</TR>
<TR><TD CLASS="LEFT">AIX</TD>
<TD CLASS="LEFT">IBM</TD>
<TD CLASS="LEFT">RS6000, Power</TD>
</TR>
<TR><TD CLASS="LEFT">Solaris</TD>
<TD CLASS="LEFT">Sun</TD>
<TD CLASS="LEFT">Sparc, intel-x86</TD>
</TR>
<TR><TD CLASS="LEFT">HP-UX</TD>
<TD CLASS="LEFT">Hewlett-Packard</TD>
<TD CLASS="LEFT">PA-RISC, Itanium(IA-64)</TD>
</TR>
<TR><TD CLASS="LEFT">Tru64 UNIX(Digital Unix)</TD>
<TD CLASS="LEFT">HP(Compaq(DEC))</TD>
<TD CLASS="LEFT">Alpha</TD>
</TR>
<TR><TD CLASS="LEFT">IRIX</TD>
<TD CLASS="LEFT">Silicon Graphics</TD>
<TD CLASS="LEFT">SGI</TD>
</TR>
</TABLE> 
<BR>
<BR>
Oracle stanset vidreutviklingen av Solaris, det største av Unix-operativsystemene, i 2017. 
Idag er det x86 servere som dominerer og de fleste med Linux.
Frie Unix-kloner for mange plattformer:
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="LEFT">OS</TH>
<TH CLASS="LEFT">hardware</TH>
</TR>
<TR><TD CLASS="LEFT">FreeBSD</TD>
<TD CLASS="LEFT">x86, Alpha, Sparc</TD>
</TR>
<TR><TD CLASS="LEFT">OpenBSD</TD>
<TD CLASS="LEFT">(sikkerhet) x86, Alpha, Sparc, HP, PowerPC, mm</TD>
</TR>
<TR><TD CLASS="LEFT">NetBSD</TD>
<TD CLASS="LEFT">x86, Alpha, Sparc, HP, PowerPC (Mac),  PlayStation, mm</TD>
</TR>
<TR><TD CLASS="LEFT">Darwin</TD>
<TD CLASS="LEFT">(basis for Mac OS X og iOS, kjernen, XNU, bygger på FreeBSD og Mach 3 microkernel) , intel x86, ARM, PowerPC</TD>
</TR>
<TR><TD CLASS="LEFT">Linux</TD>
<TD CLASS="LEFT">x86, Alpha, Sparc, HP, PowerPC, PlayStation 3, Xbox, stormaskin, mm</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION00076400000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interrupts (avbrytelser)</A>
</H3>

<P>

<UL>
<LI>Signal fra hardware
</LI>
<LI>CPU-en avbrytes for å håndtere signalet
</LI>
<LI>Lagrer adressen til neste instruksjon på stack og hopper til interrupt-rutinen
</LI>
<LI>Hvert interrupt-nr (IRQ) har sin rutine
</LI>
</UL>

<P>

<H2><A ID="SECTION00077000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> Singletasking OS</A>
</H2>

<P>
Basis for flerprosess-systemer.

<P>

<H3><A ID="SECTION00077100000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Internminne-kart</A>
</H3>

<P>
<IMG
  WIDTH="403" HEIGHT="438" STYLE=""
 SRC="./minnekart.png"
 ALT="Image minnekart">
<EM>Stack: brukes bl. a. til å lagre adressen som skal returneres til ved subrutinekall.</EM>

<P>

<H2><A ID="SECTION00078000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> Multitasking-OS</A>
</H2>

<P>
<EM>For å lage et system som kan kjøre n programmer samtidig, må vi få en enprosess maskin til 
å se ut som n maskiner. 
</EM>
<P>
<EM>Bruker software til å fordele tid mellom n programmer og å dele ressurser; minne, disk, skjerm etc. 
OS-kjernen utfører denne oppgaven.</EM>

<P>
Samtidige prosesser må tildeles hver sin del av minne:

<P>

<DIV class="CENTER"><A ID="multiminnekart"></A><A ID="949"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Minnekart for et multitasking system</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="707" HEIGHT="475" STYLE=""
 SRC="./minnekartMulti.png"
 ALT="Image minnekartMulti"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00079000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> Multitasking</A>
</H2>
Multitasking gjør at man kan kjøre flere programmer samtidig selvom man bare har en CPU. 
I prinsippet er CPU-en meget enkel på den måten at den gjør en og en maskinistruksjon av gangen. 
Som for eksempel å legge sammen to tall, å sammenligne to bit-strenger (1010001101101110 = 1010001100101110?)
  eller å lagre en streng med binære tall i internminnet(RAM). Et multitasking operativsystem får det til 
å se ut som om mange programmer kan kjøre samtidig ved å dele opp tiden i små biter (timeslices) og la hver 
prosess som kjører få en bit CPU-tid (typisk et hundredels sekund) av gangen i et køsystem 
(såkalt <SPAN  CLASS="textbf">Round Robin</SPAN> kø). 
Metoden som alle moderne OS bruker er Preemptive multitasking. Metoden består i at en hardware timer (klokke) 
jevnlig sender et interrupt-signal som gjør at første OS-instruksjon legges inn i CPU-en. Dermed unngås det at 
vanlige brukerprosesse tar over kontrollen. 
OS lar hver prosess etter tur bruke CPU-en i et kort tidsintervall. 
Alle prosesser ser da ut til å kjøre samtidig. 
Når OS switcher fra prosess P1 til prosess P2 utføres en såkalt Contex Switch (kontekst svitsj). 
<BR>
<DIV class="CENTER"><A ID="fig_contextswitch"></A><A ID="958"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Prosessene P1, P2 og P3 kjører samtidig under et multitasking OS. En 
Context Switch utføres hver gang en prosess gis CPU-tid.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="707" HEIGHT="206" STYLE=""
 SRC="./contextswitch.png"
 ALT="Image contextswitch"> 

</DIV></TD></TR>
</TABLE>
</DIV>
Typisk tid for context-switch: 0.001 ms (ms = millisekunder = tusendels sekund). 
Timeslice = 10 ms for Linux på Intel.

<P>

<H2><A ID="SECTION000710000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN>  PCB -Process Control Block</A>
</H2> 
Process Control Block (PCB) er Prosessens tilstandsbeskrivelse: prioritet, 
prosessormodus, minne, stack, åpne filer, I/O, etc.
PCB inneholder bl. a. følgende:

<UL>
<LI>CPU registre
</LI>
<LI>pekere til stack
</LI>
<LI>prosesstilstand (sleep, run, ready, wait, new, stopped)
</LI>
<LI>navn (PID)
</LI>
<LI>eier (bruker)
</LI>
<LI>prioritet (styrer hvor mye CPU-tid den får)
</LI>
<LI>parent prosess
</LI>
<LI>ressurser (åpne filer, etc.)
</LI>
</UL>

<P>

<H2><A ID="SECTION000711000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> Timesharing og Context Switch</A>
</H2>
CPU-scheduling = å fordele CPU-tid mellom prosessene = Time Sharing
<BR>
Metoden som alle moderne OS bruker er Preemptive multitasking med en <SPAN  CLASS="textbf">Round Robin</SPAN> kø. 
OS lar hver prosess etter tur bruke CPU-en i et kort tidsintervall (timeslice). 
Alle prosesser ser da ut til å kjøre samtidig. 
Når OS switcher fra prosess P1 til prosess P2 utføres en Contex Switch. 

<DIV class="CENTER"><A ID="fig_contextswitch"></A><A ID="970"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Prosessene P1, P2 og P3 kjører samtidig under et multitasking OS. En 
Context Switch utføres hver gang en prosess gis CPU-tid.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="707" HEIGHT="206" STYLE=""
 SRC="./contextswitch.png"
 ALT="Image contextswitch"> 

</DIV></TD></TR>
</TABLE>
</DIV>
Typisk tid for context-switch: 0.001 ms. Timeslice = 10 ms for Linux på Intel.

<P>
<EM>All PCB-info må lagres i en Context Switch <code>-&gt;</code> tar tid  <code>-&gt;</code> systemoverhead</EM>

<DIV class="CENTER"><A ID="CSminne"></A><A ID="978"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">CPU info lagres i PCB ved en Context Switch</SPAN></CAPTION>
<TR><TD><P>
<DIV class="CENTER">
<IMG
  WIDTH="806" HEIGHT="462" STYLE=""
 SRC="./PCB1toPCB2.png"
 ALT="Image PCB1toPCB2"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000712000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> Multitasking i praksis, CPU-intensive programmer</A>
</H2>
Et program som oversetter kildekode til maskinkode (kompilator) eller et program som hele 
tiden regner med tall, vil bruk så mye CPU-tid som det klarer å få tak i. Prosesser som kjører slike 
programmer kalles CPU-intensive. De fleste vanlige 
programmer som browsere, tekstbehandlingsprogrammer, tengeprogram etc. bruker lite CPU og det 
er dette som gjør at multitasking av hundretalls samtidige prosesser går helt greit uten at brukeren 
oppfatter datamaskinen som treg. Vi skal nå se hva som skjer når vi kjører flere instanser av et mulititasking program på systmer med en eller flere CPU'er. 

<P>
Programmet vi bruker er et lite shell-script som står i en løkke og regner og regner. Da vil det hele tiden ha behov for CPU-en. Siden prosessen aldri har behov for å vente på data fra disk, tastatur eller andre prosesser, kan den regne uten stans. Programmet heter <code>regn</code> og ser slik ut:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

#! /bin/bash

# regn (bruker CPU hele tiden)

(( max = 100000 ))
(( i = 0  ))
(( sum = 0  ))

echo $0 : regner....
while (($i &lt; $max))
do
        (( i += 1 ))
        (( sum += i  ))
done
echo $0, resultat: $sum
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000713000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> Multitasking eksempel</A>
</H2>
<EM>Bare rene regneprosesser bruker CPU hele tiden. Vanlige prosesser
  venter mye på I/O (Input/Output fra disk, nettverk etc.) og
  multitasking gir da mer effektiv utnyttelse av CPU.</EM>

<DIV class="CENTER"><A ID="multitasking"></A><A ID="990"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Prosessene A og B kjørt med single og multitasking</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="499" HEIGHT="149" STYLE=""
 SRC="img60.png"
 ALT="\includegraphics[width=11cm]{fig/multitasking.pdf}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000714000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> CPU-intensiv prosess på system med èn CPU</A>
</H2>
Med kommandoen <code>lscpu</code> kan man hente ut mye nyttig informasjon om cpu og cache:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

user@chokeG7:~$ lscpu 
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
Address sizes:       40 bits physical, 48 bits virtual
CPU(s):              1
On-line CPU(s) list: 0
Thread(s) per core:  1
Core(s) per socket:  1
Socket(s):           1
NUMA node(s):        1
Vendor ID:           AuthenticAMD
CPU family:          15
Model:               65
Model name:          Dual-Core AMD Opteron(tm) Processor 2216
Stepping:            3
CPU MHz:             2400.114
BogoMIPS:            4800.22
Hypervisor vendor:   Xen
Virtualization type: full
L1d cache:           64K
L1i cache:           64K
L2 cache:            1024K
NUMA node0 CPU(s):   0
Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm 3dnowext 3dnow rep_good nopl cpuid extd_apicid pni cx16 x2apic hypervisor lahf_lm cr8_legacy 3dnowprefetch vmmcall
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette viser at denne Linux-maskinen har èn enkelt 64-bits CPU med en klokkefrekvens på 2.4 GHz. Utskriften viser også at dette er en virtuell maskin, man kan se at den er virtualisert med Xen utifra de to linjene

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Hypervisor vendor:   Xen
Virtualization type: full
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Videre kan man se størrelsen på L1 og L2 cache. En rask og tydelig oversikt kan man få med kommandoen <code>lstopo</code>:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

lstopo --no-io
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
som gir følgende figur

<P>

<DIV class="CENTER"><A ID="1005"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">CPU-topologi generert av lstopo den virtuelle maksinen chokeG7.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="182" HEIGHT="309" STYLE=""
 SRC="img61.png"
 ALT="\includegraphics[width=4cm]{fig/1cpu.pdf}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Vi starter en instans av programmet <code>regn</code> som er CPU-intensivt og bruker så mye CPU det kan få:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

mroot@chokeG7:~$ ./regn 
./regn, resultat: 3125001250000
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Samtidig startes <code>top</code> og man kan se at prosessen med PID (Process ID) 18908 forsyner seg grovt av CPU-en og klarer å karre til seg 99.3% av CPU-tiden. Verdien som vises er gjennomsnittsverdien for de siste 3 sekunder.
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

top - 14:32:39 up 10 days, 23:56,  2 users,  load average: 0,09, 0,12, 0,05
Tasks:  74 total,   1 running,  73 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  0,7 sy,  0,0 ni, 99,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,3 st

PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                    
18908 mroot     20   0    9504   3244   3008 R  99,3   0,7   0:07.16 regn                                       
18903 mroot     20   0   16668   4668   3536 S   0,3   1,0   0:00.04 sshd
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Vi starter så en instans til av programmet som regner i vei, uavhengig av den første. Da ser vi at OS fordeler CPU-en likt mellom de to prosessene og de får i underkant av 50% hver av CPU-tiden. 

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                    
18912 mroot     20   0    9504   3224   2988 R  49,8   0,7   0:13.14 regn                                       
18913 mroot     20   0    9504   3312   3080 R  49,8   0,7   0:12.84 regn
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette betyr at reelt sett er det til enhver tid bare en prosess som kjører, men det oppleves som om de kjører samtidig fordi OS deler opp tiden i små biter(1-10 hundredels sekunder) og lar dem bruke CPU-en annenhver gang. Husk at for en prosess er ett hundredels sekund lang tid, den kan rekke å utføre millioner av maskininstruksjoner på den tiden.

<P>

<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2025-05-07
</ADDRESS>
</BODY>
</HTML>
