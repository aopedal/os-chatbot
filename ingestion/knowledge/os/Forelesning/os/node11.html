<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>10 Forelesning 26/3-24(2 timer). Plattformavhengighet og Threads</TITLE>
<META NAME="description" CONTENT="10 Forelesning 26/3-24(2 timer). Plattformavhengighet og Threads">
<META NAME="keywords" CONTENT="os">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY  bgcolor="#ffffff">
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html1063"
  HREF="node11.html#SECTION000111000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Video av forelesningen</A>
<LI><A ID="tex2html1064"
  HREF="node11.html#SECTION000112000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sist</A>
<LI><A ID="tex2html1065"
  HREF="node11.html#SECTION000113000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Å kjøre Java, C og bash-programmer under forskjellige OS</A>
<UL>
<LI><A ID="tex2html1066"
  HREF="node11.html#SECTION000113100000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Hello.java</A>
<LI><A ID="tex2html1067"
  HREF="node11.html#SECTION000113200000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> hello.c</A>
<LI><A ID="tex2html1068"
  HREF="node11.html#SECTION000113300000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> hello.bash</A>
</UL>
<BR>
<LI><A ID="tex2html1069"
  HREF="node11.html#SECTION000114000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Test av C, Java, Python og bash på 5 plattformer</A>
<LI><A ID="tex2html1070"
  HREF="node11.html#SECTION000115000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> Threads (tråder)</A>
<LI><A ID="tex2html1071"
  HREF="node11.html#SECTION000116000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Definisjoner av threads</A>
<LI><A ID="tex2html1072"
  HREF="node11.html#SECTION000117000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Fordeler med threads</A>
<LI><A ID="tex2html1073"
  HREF="node11.html#SECTION000118000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> Java-threads</A>
<UL>
<LI><A ID="tex2html1074"
  HREF="node11.html#SECTION000118100000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> Prioritet</A>
<LI><A ID="tex2html1075"
  HREF="node11.html#SECTION000118200000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> Java på Linux</A>
<LI><A ID="tex2html1076"
  HREF="node11.html#SECTION000118300000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> Variabler</A>
</UL>
<BR>
<LI><A ID="tex2html1077"
  HREF="node11.html#SECTION000119000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">9</SPAN> Java thread eksempel: Calc.java</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION000110000000000000000">
<SPAN CLASS="arabic">10</SPAN> Forelesning 26/3-24(2 timer).  Plattformavhengighet og Threads</A>
</H1>

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Avsnitt fra Tanenbaum: 2.2
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<A ID="tex2html258"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/10.pdf">Slides brukt i forelesningen</A>
<P>

<H2><A ID="SECTION000111000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Video av forelesningen</A>
</H2>
<A ID="tex2html260"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10time1.mp4">Uredigert opptak av hele første time av forelesningen ( 00:35:31)</A>
<P>
<A ID="tex2html261"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10time2.mp4">Uredigert opptak av hele andre time av forelesningen ( 00:43:06)</A>
<P>
Opptak av forelesningen inndelt etter temaer:

<P>
<A ID="tex2html262"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del1.mp4">os10del1.mp4</A>
(04:18) Intro om dagens temaer, plattformavhengighet og threads, oppsummering av det vi gjorde sist

<BR><A ID="tex2html263"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del2.mp4">os10del2.mp4</A>
(13:52) Web-notater: Å kjøre Java, C og bash-programmer under forskjellige OS

<BR><A ID="tex2html264"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del3.mp4">os10del3.mp4</A>
(23:12) Demo: Test av C, Java, Python og bash på 5 plattformer (desverre blir lydkvaliteten plutselig dårlig 14 minutter ut i dette opptaket)

<BR><A ID="tex2html265"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del4.mp4">os10del4.mp4</A>
(02:57) Gjennomgang av spørsmålene til poll om plattformavhengighet  (se figur under)

<BR><A ID="tex2html266"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del5.mp4">os10del5.mp4</A>
(03:37) Spørsmål om python2 vs python3 og print med og uten parenteser.

<BR><A ID="tex2html267"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del6.mp4">os10del6.mp4</A>
(04:03) Gjennomgang av svarene til poll om plattformavhengighet (se figur under)

<BR><A ID="tex2html268"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del7.mp4">os10del7.mp4</A>
(02:00) Demo: ARM assembly instruksjoner for sum.c

<BR><A ID="tex2html269"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del8.mp4">os10del8.mp4</A>
(15:43) Slides: Tråder (threads) vs prosesser, definisjoner, single og multithreading, fordeler med threads

<BR><A ID="tex2html270"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del9.mp4">os10del9.mp4</A>
(05:09) Slides: Java-threads og scheduling, variabler og tråder

<BR><A ID="tex2html271"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os10del10.mp4">os10del10.mp4</A>
(02:16) Notater: Om hvordan Calc.java starter og kjører to tråder

<BR>
<P>

<DIV class="CENTER"><A ID="1549"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Spørsmål og resultater fra poll om plattformuavhengighet.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="605" HEIGHT="1047" STYLE=""
 SRC="./poll16_03_2021.png"
 ALT="Image poll16_03_2021"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000112000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sist</A>
</H2>

<UL>
<LI>Systemkall
</LI>
<LI>Prioritet
</LI>
<LI>Nice
</LI>
<LI>Prosessforløp
</LI>
<LI>OS-arkitektur
</LI>
</UL>

<P>

<H2><A ID="SECTION000113000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Å kjøre Java, C og bash-programmer under forskjellige OS</A>
</H2>
Utgangspunktet er det samme "Hello world!" programmet skrevet i C, Java og Bash. Vi skal prøve 
å kjøre disse på tre systemer:

<UL>
<LI>Operativsystemet Linux kjørt på en vanlig PC med Intel Pentium prosessor som kun forstår X86 maskin-instruksjoner
</LI>
<LI>Operativsystemet Windows  kjørt på den samme Intel-PC-en
</LI>
<LI>Operativsystemet Solaris kjørt på en Sun Sparcstation 20 med en sparc-prosessor som kun forstår Sparc maskin-instruksjoner
</LI>
</UL>

<P>
Idag er Sun og sparc-prosessor en utdøende rase og det finnes ikke så mange av dem lenger. Men det er et eksempel på en datamaskinarkitektur som er helt forskjellig fra x86 og Sparc CPUer var tidligere veldig mye i bruk i Unix-servere. Nå har dette markedet i stor grad blitt tatt over av Linux- og Windows-servere som stort sett kjører på Intel og AMD CPUer med x86-arkitektur.

<P>

<H3><A ID="SECTION000113100000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Hello.java</A>
</H3>
 Dette Java-programmet ser slik ut
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ cat Hello.java
class Hello
{ 
    public static void main(String args[])
    {
        System.out.println("Java: Hello world!");
    }
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>og som de to andre, skriver det bare ut en linje til skjermen.
For å kjøre dette programmet må det kompileres og vi gjør det på Linux-maskinen:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ javac Hello.java
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>da lages det en binær fil med navn <code>Hello.class</code> som inneholder såkalt bytekode. Denne koden er 
instruksjoner til en såkalt Java Virtual Machine (JVM) som er et program som kjører bytekoden og får det 
underliggende systemet til å utføre det denne koden sier skal gjøres. For hvert operativsystem er det en 
egen JVM som sørger for dette slik som vi ser i figuren:

<P>

<DIV class="CENTER"><A ID="1566"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Java er plattformuavhengig og samme Hello.class fil kan kjøres på alle de tre plattformene. </SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
</DIV>
<P>
<DIV class="CENTER"><IMG
  WIDTH="605" HEIGHT="416" STYLE=""
 SRC="./plattformerJava.png"
 ALT="Image plattformerJava"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Dermed kan <code>Hello.class</code> filen som ble kompilert på en Linux-maskinen faktisk kjøre på alle 
de tre plattformene. Enheten OS + Hardware blir ofte omtalt som en plattform. På grunn av dette 
sier vi at Java er plattformuavhengig. Det samme er også Perl og C#, deres kompilerte kode kjøres av virtuelle maskiner.

<P>

<H3><A ID="SECTION000113200000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> hello.c</A>
</H3>
Dette programmet ser slik ut
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

cube$ cat hello.c
#include &lt;stdio.h&gt;
main()
{
    printf("c: Hello world!\n");
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>For å kjøre dette programmet må det kompileres og vi gjør det på Linux-maskinen:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ gcc hello.c
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>da lages det en binær fil med navn <code>a.out</code> som inneholder maskin-instruksjoner og deler av disse 
kan lastes inn og kjøres direkte på CPU-en til plattformen den er kompilert på. Nå har vi kompilert programmet på 
en X86-prosessor og da vil <code>a.out</code> inneholde X86-instruksjoner som på assembler-form kan se ut som 
f. eks. <code>mov %eax,%ebx</code> og henviser til registrene denne CPU-en har. 
Kompilatoren oversetter direkte fra kildekode til maskinkode. Assembly er et språk i mellom disse, men som ligger 
svært nær maskinkoden, og som gjør at vi enkelt kan se nøyaktig hva maskinkoden gjør. For å få kjørbar kode som 
er veldig kompakt og eller gjør nøyaktig det vi ønsker, er det mulig å skrive programmer direkte i assembly og så få 
en assembler til å oversette dette til maskinkode og dermed et kjørbart program.  

<P>
Ved hjelp av reverse engineering kan man 
prøve å se hva binærkoden til et kompilert program (ofte kalt objekt-kode) inneholder. Programmet <code>objdump</code> 
er en disassembler som oversetter maskinkoden til en for mennesker mer leselig assembly-kode. 
Dette er det motsatte av hva en assembler gjør.
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Linux$ objdump -d a.out 

8048278:       83 ec 04                     sub    $0x4,%esp
 804827b:       e8 00 00 00 00          call   8048280 &lt;_init+0xc&gt;
 8048280:       5b                      pop    %ebx
 8048281:       81 c3 d8 12 00 00       add    $0x12d8,%ebx
 8048287:       8b 93 fc ff ff ff       mov    -0x4(%ebx),%edx
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>Dette er bare et lite utsnitt av koden og det sentrale i vår sammenheng er at dette er instruksjoner fra 
det såkalte X86-instruksjonssettet som alle vanlige Intel og AMD-prosessorer bruker.

<P>
Dermed kan det umulig gå bra å kjøre 
 <code>a.out</code> på en Sparc-prosessor, for den forstår overhode ikke maskin-instruksjonene som blir gitt. Det er 
rett og slett helt gresk for Sparc-prosessoren. Den forstår bare Sparc-instruksjoner som er et helt annent 
instruksjonessett som vi kan se hvis vi kompilerer programmet og dumper objekt koden under Solaris:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

Solaris$  gcc a.out
Solaris$  objdump -d a.out
   10440:       e0 03 a0 40     ld  [ %sp + 0x40 ], %l0
   10444:       a2 03 a0 44     add  %sp, 0x44, %l1
   10448:       9c 23 a0 20     sub  %sp, 0x20, %sp
   1044c:       80 90 00 01     tst  %g1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>Dette ligner, men instruksjonene er delvis forskjellige og definsjonene av hvilke bit-strenger som betyr en 
bestemt instruksjon eller et bestemt register er helt forskjellige. 

<P>
I tillegg inneholder <code>a.out</code> kode 
som ber Linux-operativsystemet om å skrive ut til skjermen og dette er spesielle systemkall som er helt 
spesifikke for Linux og som andre OS ikke forstår. Dermed går det heller ikke å kjøre dette programmet på 
Windows-maskinen, selvom maskin-instruksjonene er de samme, alle er hentet fra X86-instruksjonssettet.

<DIV class="CENTER"><A ID="1581"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">C er ikke plattformuavhengig og samme a.out fil kan ikke kjøres på alle de tre plattformene.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="605" HEIGHT="411" STYLE=""
 SRC="./plattformerLinux.png"
 ALT="Image plattformerLinux"> 

</DIV></TD></TR>
</TABLE>
</DIV>
Som vi ser i figuren er det kun på plattformen programmet er kompilert at det kan kjøres og vi sier at C er 
plattformavhengig. Om vi skal kjøre dette programmet på de to andre plattformen, må det kompileres på nytt 
med en C-kompilator på både Windowsmaskinen og på Solaris-maskinen. På Windows kan det gjøres for eksempel med tinyCC (tcc), 
eller med en komersiell kompilator som Visual C++. På Solaris finnes det som regel en C-kompilator, det er vesentlig for 
Unix-maskiner. Da lages det instruksjoner som snakker med det rette OS'et og som inneholder de rette maskininstruksjonene, slik som i figuren.

<DIV class="CENTER"><A ID="1587"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">C-programmet må kompileres på hver av de tre plattformene, først da kan de kjøres.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="605" HEIGHT="413" STYLE=""
 SRC="./plattformerOK.png"
 ALT="Image plattformerOK"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H3><A ID="SECTION000113300000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> hello.bash</A>
</H3>
Dette programmet ser slik ut
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

cube$ cat hello.bash
#! /bin/bash
echo "bash: Hello world!"
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>og er avhengig av at shellet bash er installert på plattformen det skal kjøres. Dette programmet tolker da 
linje for linje og utfører den. Dette er delvis analogt til Java, bortsett fra at mellomleddet med å kompilere og 
lage bytekode er fjernet. Programmet bash erstatter JVM og kjører koden. Dermed er også bash-script plattformuavhengig. 
Tidligere var det ikke mulig å kjøre bash på Windows, men i de siste årene har Microsoft samarbeidet mye med Ubuntu og det
er nå mulig å aktivere et fullverdig bash-shell i Windows. Men det er ikke aktivert som default.

<P>

<H2><A ID="SECTION000114000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Test av C, Java, Python og bash på 5 plattformer</A>
</H2>
I forelesningen ble et Python 'Hello world' program testet i tillegg til de tre språkene beskrevet over. De fem forskjellige plattformene som var involvert i testen var de følgende.

<P>

<UL>
<LI>Linux Ubuntu 18.04, Intel Xeon, Java 11 Python 3.6 (HP laptop)
</LI>
<LI>MacOS X Darwin Kernel, Intel Core Duo, Java 6 (1.6) Python 2.6 (Gammel MacBook Pro)
</LI>
<LI>Linux Ubuntu 16.04, AMD Opteron, Java 8 (1.8) Python 2.7 (Dell server med 48 CPUer)
</LI>
<LI>Linux Ubuntu 20.04, ARM Neoverse-N1, Java 14 Python 3.8 (Amazon EC2, London)
</LI>
<LI>Windows server 2019, Intel Xeon CPU, Java 8 (1.8) Python 3.9 (Amazon EC2, London)
</LI>
</UL>

<P>
Utganspunktet varr at alle programmene ble kompilert og kjørt på den førstnevnte HP-laptopen som kjører Ubuntu 18.04. Kompileringen av programmene ble gjort med

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

gcc hello.c
javac Hello.java
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
og kjøringen med

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

./a.out
java Hello
python hello.py
bash hello.bash
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000115000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> Threads (tråder)</A>
</H2>

<UL>
<LI>prosess = At en kokk lager en porsjon middag i et kjøkken
</LI>
<LI>CPU = kokk
</LI>
<LI>ressurser = kjøkken, matvarer, oppskrift
</LI>
<LI>thread/tråd = den sammenhengende serien av hendelser som skjer når kokken lager en porsjon
</LI>
</UL>
Når porsjonen er ferdig er porsessen avsluttet.
Alternativer:

<OL>
<LI>To uavhengige prosesser = to kjøkken, kokken løper frem og tilbake og lager en porsjon i hvert kjøkken. Følger en oppskrift i hvert kjøkken(men oppskriften er den samme).
</LI>
<LI>En prosess med to threads = Ett kjøkken, kokken bytter på å jobbe med de to porsjonene og lager to porsjoner fra samme oppskrift med felles ressurser for de to porsjonene.
</LI>
</OL>
Med en tradisjonell prosess kan kun en kokk jobbe i et kjøkken og der lage kun en porsjon. Ønsker man å lage flere porsjoner, så må man lage flere kjøkken. 
Innfører man tråder kan flere kokker jobbe i samme kjøkken med flere porsjoner på en gang.

<H2><A ID="SECTION000116000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Definisjoner av threads</A>
</H2>

<UL>
<LI>den sammenhengende rekken av hendelser/instruksjoner som utføres når et program kjøres 
</LI>
<LI>"tråden" som følges når et program utføres
</LI>
<LI>Lettvekts prosess
</LI>
</UL>
Programmereren (og ikke OS) vet hva som skal gjøres. Han kan detaljstyre threads til å samarbeide 
om oppgaver som skal utføres. 

<P>

<DIV class="CENTER"><A ID="threadDeling"></A><A ID="1611"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Single og multithreading</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="806" HEIGHT="399" STYLE=""
 SRC="./osaThreadDeling.png"
 ALT="Image osaThreadDeling"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Figur <A HREF="#threadDeling">64</A> viser for en single threaded prosess hvordan programmet gjennom å utføre instruksjoner beveger seg igjennom koden og også frem og tilbake og til RAM. Om man tegner opp denne bevegelsen får man en enkelt "tråd" som beveger seg rundt og illustrerer hvordan programmet kjøres. Om man kjører et program flere ganger, kan det følge forskjellige tråder hvis for eksempel input er forskjellig fra gang til gang. Hvis man kjører en prosess som kan ha flere tråder kan man istedet for å kjøre et program tre ganger, kjøre tre tråder samtidig inne i den samme koden. Den høyre delen av figuren viser en multi threaded prosess hvor tre instanser av samme program kjører samtidig og følger hver sin tråd under utførelsen. Det meste av koden kan deles med de andre trådene, men alle data som er spesielle for den enkelte kjøringen må lagres hver for seg, slik som PCB for tråden. For eksempel vil disse tre trådene hele tiden ha forskjellige verdier i registerene og de vil kunne gjøre kall til forskjellige metoder. Dermed må de ha hver sin stack definert i RAM (hvor metode-kallene og metode-variabler lagres) og de må ha sine helt egne verdier i registerene som lagres i PCB når de ikke kjører. Den vanligste måten for operativsystemet å schedulere tråder er å betrakte dem som uavhengig enheter slik at tre tråder innen samme prosess kan kjøre på tre forskjellige CPUer.  

<P>

<H2><A ID="SECTION000117000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Fordeler med threads</A>
</H2>
<DL>
<DT><STRONG>Ressursdeling</STRONG></DT>
<DD>Flere tråder eksisterer innenfor samme prosess. Deler på kode, data 
og delvis PCB. 
</DD>
<DT><STRONG>Respons</STRONG></DT>
<DD>Interaktive applikasjoner kan ha en tråd med høy prioritet som kommuniserer 
med brukere og lavprioritettråder som gjør grovarbeid.
</DD>
<DT><STRONG>Effiktivitet</STRONG></DT>
<DD>Tar mindre tid å lage nye threads og mindre tid å context-switche mellom 
threads. Kan typisk ta 30x så lang tid å lage en ny prosess som å lage en ny thread. Context switch 
kan ta 5x så lang tid.
</DD>
<DT><STRONG>Multiprosessor</STRONG></DT>
<DD>Hver tråd kan tildeles en egen CPU.
</DD>
<DT><STRONG>Felles variabler</STRONG></DT>
<DD>Ofte nyttig med felles minne for prosesser, men det er tungvint å 
sette opp. Dette er trivielt for threads.
</DD>
</DL>

<P>

<H2><A ID="SECTION000118000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> Java-threads</A>
</H2>
For å lage Java-threads må man arve klassen Thread. Viktige Thread-metoder:
<DL>
<DT><STRONG>start()</STRONG></DT>
<DD>Allokerer minne, stack etc. og kaller run().
</DD>
<DT><STRONG>run()</STRONG></DT>
<DD>Her uføres jobben tråden skal gjøre.
</DD>
<DT><STRONG>yield()</STRONG></DT>
<DD>Tråden gir fra seg CPU-en.
</DD>
<DT><STRONG>setPriority()</STRONG></DT>
<DD>Setter thread-prioritet. Min = 1, Max = 10, default = 5.
</DD>
<DT><STRONG>sleep(ms)</STRONG></DT>
<DD>Tråden sover i ms millisekunder
</DD>
</DL>

<P>

<H3><A ID="SECTION000118100000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> Prioritet</A>
</H3>
Vanligvis scheduleres to Java-tråder av OS, etter en-til-en modellen slik at de to trådene 
kjører uavhengig av hverandre og samtidig. Dette kalles native threads. 
Det finnes implementasjoner hvor Java kjører en prosess og schedulerer trådene selv, såkalte green-threads. 
jdk1.1 var implementert slik på Linux. 

<P>
Det går ikke klart frem av spesifikasjonene for 
JVM (Java Virtual Machine) hvordan prioritet skal implementeres og her kan det være 
forskjeller. 

<P>

<H3><A ID="SECTION000118200000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> Java på Linux</A>
</H3>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

$ emacs Calc.java&amp;
$ javac Calc.java   # Calc.class lages; bytecode
$ java Calc         # Starter JVM (Java Virtual Machine) som kjører byte-koden
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H3><A ID="SECTION000118300000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> Variabler</A>
</H3>
Variabler som blir definert som static vil være felles for alle trådene.
Andre vil kun kunne brukes av den enkelte tråd.
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

   static int count;
   int id;
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>I eksempelet oppdateres <code>count</code> av begge trådene, mens det eksisterer 
en <code>id</code> for hver tråd.

<P>

<DIV class="CENTER"><A ID="threadVariabler"></A><A ID="1632"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Deklareres en variabel som static blir den felles for alle tråder.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="252" HEIGHT="320" STYLE=""
 SRC="./threadVariabler.png"
 ALT="Image threadVariabler"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000119000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">9</SPAN> Java thread eksempel: Calc.java</A>
</H2>

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

import java.lang.Thread;

class CalcThread extends Thread
{
   static int count = 0;
   int id;

   CalcThread()
        {
         count++;
         id = count;
        }

   public void run()
        {
         System.out.println("Thread nr." + id + " is starting");
         System.out.println("Thread nr." + id + " calculated " + work());
        }

   private float work()
        {
         int i,j;
           float res = 0;
            System.out.println("Thread nr." + id + " calculating");
            for(j = 1;j &lt; 5;j++)
                {
                    for(i = 1;i &lt; 30000000;i++)
                        {
                            res += 1.0/(1.0*i*i);
                        }
                     System.out.println("Thread nr." + id + " calculating" + j);
                }
         return(res);
        }
}

class Calc
{
   public static void main(String args[])
   {
    System.out.println("Starts two threads !\n");
    CalcThread s = new CalcThread();
    System.out.println("Thread s has id " + s.id + "\n");
    s.start(); // Allokerer minne og kaller s.run()

    CalcThread s2 = new CalcThread();
    System.out.println("Thread s2 has id " + s2.id + "\n");
    s2.start();
    System.out.println("s2 started !\n");

    }
}
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Kjører man dette programmet på en maskin med to CPU'er, vil de to trådene kunne kjøre på hver 
sin CPU og dermed utnytte ressursene optimalt. Et java-program med en tråd vil kun kunne utnytte 
en av CPU-ene.

<P>

<P>
<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2025-05-07
</ADDRESS>
</BODY>
</HTML>
