<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>13 Forelesning 9/4-26. Internminne</TITLE>
<META NAME="description" CONTENT="13 Forelesning 9/4-26. Internminne">
<META NAME="keywords" CONTENT="os">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY  bgcolor="#ffffff">
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html1116"
  HREF="node14.html#SECTION000141000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
<LI><A ID="tex2html1117"
  HREF="node14.html#SECTION000142000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Internminne</A>
<LI><A ID="tex2html1118"
  HREF="node14.html#SECTION000143000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">3</SPAN> Virtuelt adresserom</A>
<LI><A ID="tex2html1119"
  HREF="node14.html#SECTION000144000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">4</SPAN> Internminnet/RAM</A>
<LI><A ID="tex2html1120"
  HREF="node14.html#SECTION000145000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">5</SPAN> C++ library</A>
<LI><A ID="tex2html1121"
  HREF="node14.html#SECTION000146000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">6</SPAN> Layout av en prosess sitt adresserom/segmentation</A>
<LI><A ID="tex2html1122"
  HREF="node14.html#SECTION000147000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">7</SPAN> Minneadressering og MMU</A>
<LI><A ID="tex2html1123"
  HREF="node14.html#SECTION000148000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">8</SPAN> Eksempel på MMU-tabell</A>
<LI><A ID="tex2html1124"
  HREF="node14.html#SECTION000149000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">9</SPAN> Paging</A>
<LI><A ID="tex2html1125"
  HREF="node14.html#SECTION0001410000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">10</SPAN> Pages</A>
<LI><A ID="tex2html1126"
  HREF="node14.html#SECTION0001411000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">11</SPAN> MMU eksempel med 4k page-størrelse</A>
<LI><A ID="tex2html1127"
  HREF="node14.html#SECTION0001412000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">12</SPAN> Paging og swapping</A>
<LI><A ID="tex2html1128"
  HREF="node14.html#SECTION0001413000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">13</SPAN> Page Table entry</A>
<LI><A ID="tex2html1129"
  HREF="node14.html#SECTION0001414000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">14</SPAN> TLB - Translation Lookaside Buffer</A>
<LI><A ID="tex2html1130"
  HREF="node14.html#SECTION0001415000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">15</SPAN> Typisk TLB ytelse</A>
<LI><A ID="tex2html1131"
  HREF="node14.html#SECTION0001416000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">16</SPAN> Internminnet og Cache</A>
<LI><A ID="tex2html1132"
  HREF="node14.html#SECTION0001417000000000000000"><SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">17</SPAN> Paging-algoritmer</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION000140000000000000000">
<SPAN CLASS="arabic">13</SPAN> Forelesning 9/4-26. Internminne</A>
</H1>

<P>
<A ID="tex2html318"
  HREF="https://www.cs.oslomet.no/~haugerud/mem.pdf">Slides brukt i forelesningen</A>
<P>

<H2><A ID="SECTION000141000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
</H2>

<P>
<A ID="tex2html319"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13time1.mp4">Uredigert opptak av hele første time av forelesningen ( 00:44:25)</A>
<P>
<A ID="tex2html320"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13time2.mp4">Uredigert opptak av hele andre time av forelesningen ( 00:55:46)</A>
<P>
<A ID="tex2html321"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del5.mp4">os13del5.mp4</A>
(07:59) Slide: Internminne og Cache

<BR><A ID="tex2html322"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del6.mp4">os13del6.mp4</A>
(03:21) Slides: Minnepyramiden, Internminnet

<BR><A ID="tex2html323"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del7.mp4">os13del7.mp4</A>
(00:07) Slide: Adresserommet

<BR><A ID="tex2html324"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del8.mp4">os13del8.mp4</A>
(07:21) Slides: Virtuelt adresserom

<BR><A ID="tex2html325"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del9.mp4">os13del9.mp4</A>
(01:26) Spørsmål: Hva er GDDR? Graphics DDR som brukes sammen med GPU-er

<BR><A ID="tex2html326"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del10.mp4">os13del10.mp4</A>
(03:33) Spørsmål: Hva slags registere lagrer adresser? Vanlige CPU-registere. Demo av hvordan det ser ut i simulerings-CPUen

<BR><A ID="tex2html327"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del11.mp4">os13del11.mp4</A>
(09:52) Slides: Virtuelle (logiske) adresser, Internminnet og kompilering, linking og loading

<BR><A ID="tex2html328"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del12.mp4">os13del12.mp4</A>
(08:10) Demo: Generering og bruk av statisk og dynamisk bibliotek i C++

<BR><A ID="tex2html329"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del13.mp4">os13del13.mp4</A>
(01:30) Slide: Linux-prosess segmentation

<BR><A ID="tex2html330"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del14.mp4">os13del14.mp4</A>
(05:56) Slides: Minneadressering og MMU med lite eksempel

<BR><A ID="tex2html331"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del15.mp4">os13del15.mp4</A>
(05:41) Slides: Paging, pages og page table entry

<BR><A ID="tex2html332"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del16.mp4">os13del16.mp4</A>
(04:43) Slides: TLB - Translation Lookaside Buffer, ytelse og TLB-cache

<BR><A ID="tex2html333"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del17.mp4">os13del17.mp4</A>
(05:54) Slides: Konkret eksempel med MMU-oversettelse med 64K virtuelt og 32K fysisk internminne

<BR><A ID="tex2html334"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del18.mp4">os13del18.mp4</A>
(02:25) Slides: Paging og swapping, paging-algoritmer

<BR><A ID="tex2html335"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del19.mp4">os13del19.mp4</A>
(01:04) Spørsmål: Er load 32 den designerte start-adressen? Ja, dette er en virtuell adresse som må oversettes

<BR><A ID="tex2html336"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del20.mp4">os13del20.mp4</A>
(01:03) Spørsmål: Hva om en prosess bruker adresse som ikke er egne? Segmentation fault

<BR><A ID="tex2html337"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/os13del21.mp4">os13del21.mp4</A>
(03:20) Spørsmål: Hvorfor lager man ikke større L1, for eksempel 1 GB?

<BR>
<P>

<H2><A ID="SECTION000142000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Internminne</A>
</H2>
Om internminnet bruker man ofte betegnelsen RAM som er en forkortelse for Random Access Memory. Det kalles 'Random' fordi hvilken som helst byte kan leses ut eller aksesseres like raskt som enhver annen byte. Men som vi skal se vil det i praksis ikke alltid stemme at det tar like lang tid å laste inn to forskjellige byte fra RAM. En årsak til dette som gjelder for de aller fleste systemer er cache som mellomlagrer data. Hvis vi henter inn verdine på en variabel og denne ligger i cache, går inntil ti ganger raskere enn om den må hentes helt fra RAM. En annen årsak som gjelder større servere er at servere med flere titalls CPU-er ofte er delt inn i såkale numanodes som kommuniserer raskere med enkelte tilordnede deler av RAM. Dette kan utgjøre en hastighetsforskjell på inntil to tre ganger. 

<P>
Vi så i avsnitt <A HREF="node8.html#IogC">7.3</A> at både CPU-registre og cache er laget av SRAM (Static RAM), men det er ikke en del av internminnet. Aksess til SRAM er ekstremt hurtig og SRAM er statisk i den betydning at det ikke trenger å oppfriskes. Internminnet er laget av DRAM som står for Dynamic RAM. Mer en 10 ganger i sekundet må DRAM opplades, ellers forsvinner informasjonen. SRAM består av 6 transistorer for hver bit som lagres. Men DRAM trenger bare en transistor og en kapasitator(lagrer elektrisk ladning) for å lagre en bit. Derfor er DRAM billigere, mindre, bruker mindre effekt og kan lages i større enheter. Internminnet består derfor av DRAM eller forbedrede varianter av DRAM. DDR5 SDRAM (Double-Data Rate generation 5 Synchronus Dynamic RAM) er et av de foreløpig siste leddene av kjedene av forbedrede utgaver av DRAM.

<P>
I samme avsnitt viste Fig. <A HREF="#Cache2">78</A> noen typiske størrelser og aksesstider for de sentrale lagringsmedien som finnes i en datamaskin, fra registre til harddisk. Legg spesielt merke til den store forskjellen i aksesstid mellom internminnet og harddisk, selv moderne superraske SSD-disker er tusen ganger tregere. 

<P>

<DIV class="CENTER"><A ID="Cache2"></A><A ID="1971"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Minne-pyramiden. Størrelsen og tiden det tar å hente data øker nedover pyramiden.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="531" HEIGHT="301" STYLE=""
 SRC="img64.png"
 ALT="\includegraphics[width=12cm]{fig/osaCache.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Internminnet (RAM, Random Access Memory/arbeidsminne) er et stort array av bytes:
<DIV class="CENTER">
<IMG
 WIDTH="180" HEIGHT="163" STYLE=""
 SRC="img89.png"
 ALT="\includegraphics[width=4cm]{fig/minne.eps}"> 

</DIV>
Alle disse adressene utgjør tilsammen det <EM>fysiske minnet</EM> siden det er adresser til fysisk DRAM enheter som lagrer bit.

<P>
I følgende tabell kan man se hvor mange adresser det er plass til for forskjellige størrelser av registre. Det totalet antall adresser som finnes for en gitt størrelse av et register kalles et adresserom. 
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="CENTER">Registerstørrelse (i bit)</TH>
<TH CLASS="LEFT">antall mulige adresser</TH>
</TR>
<TR><TD CLASS="CENTER">16</TD>
<TD CLASS="LEFT"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.96ex; vertical-align: -0.12ex; " SRC="img90.png"
 ALT="$2^{16}$"></SPAN> = 64 K, Kilo, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.12ex; " SRC="img91.png"
 ALT="$10^{3}$"></SPAN></TD>
</TR>
<TR><TD CLASS="CENTER">32</TD>
<TD CLASS="LEFT">4 G, Giga, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.12ex; " SRC="img63.png"
 ALT="$10^{9}$"></SPAN></TD>
</TR>
<TR><TD CLASS="CENTER">48</TD>
<TD CLASS="LEFT">256 T, Tera, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.12ex; " SRC="img92.png"
 ALT="$10^{12}$"></SPAN></TD>
</TR>
<TR><TD CLASS="CENTER">64</TD>
<TD CLASS="LEFT">20 E,Exa, <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.12ex; " SRC="img93.png"
 ALT="$10^{18}$"></SPAN></TD>
</TR>
</TABLE> 

<P>

<H2><A ID="SECTION000143000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">3</SPAN> Virtuelt adresserom</A>
</H2>
Generelt er det ikke plass til alle programmer i internminnet på en gang. Derfor gir man hvert 
enkelt program sitt eget virtuelle adresserom fra 0 til det programmet måtte trenge. Er adresse-registeret 32 bit, 
er typisk det virtuelle adresserommet opp til 4Gbyte. Det vil da virke for prosessen som den har tilgang til 
alt dette minnet. Men i virkeligheten er ikke nødvendigvis alt i bruk og av det som er i bruk kan noe ligge i RAM og andre deler på disk. 

<P>
Disse virtuelle eller logiske adressene brukes overalt hvor programmet refererer til seg selv, for eksempel i en instruksjon som 
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

mov (1023), %al
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>som betyr last inn byte nummer 1023 i det 8 bit store registeret %al. 1023 er da den virtuelle adressen.
Når programmet lastes inn 
i internminnet og kjøres vil det variere hvor i det fysiske minnet programmet legges. Det må derfor være mulig 
å oversette mellom virtuelle og fysiske adresser.

<H2><A ID="SECTION000144000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">4</SPAN> Internminnet/RAM</A>
</H2>
Et kjørbart program ligger i utgangspunktet på harddisken, men må lastes inn 
i internminnet før det kan kjøres. 
Skjematisk må kildekode gjennom prosessen i Fig. <A HREF="#loading">69</A> før den kan kjøres.

<DIV class="CENTER"><A ID="loading"></A><A ID="1995"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Loading av et brukerprogram/en prosess</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="543" HEIGHT="456" STYLE=""
 SRC="img94.png"
 ALT="\includegraphics[width=12cm]{fig/loading.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000145000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">5</SPAN> C++ library</A>
</H2>
Hvis man lager C++-prosjekter og har metoder man ofte bruker, kan man lage sin egen 
library-fil som man kobler sammen med hovedprogrammet når man skal bruke det. 
Kompileringen av biblioteksfilen kan se slik ut: 
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

g++ -c calcTools.cpp                         # Lager maskinkode calcTools.o
g++ -c randTools.cpp                         # Lager maskinkode randTools.o
ar rcv libTools.a  calcTools.o   randTools.o # Lager lib-filen libTools.a
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>Senere kan dette biblioteket brukes i et prosjekt:
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

g++ -c -I../Tools mainsim.cpp       # Lager maskinkode mainsim.o
g++ -c -I../Tools simulation.cpp    # Lager maskinkode simulation.o
g++ -c  -I../Tools user.cpp         # Lager maskinkode user.o
g++ -o sim mainsim.o simulation.o user.o  -lm  -L../Tools -lTools
sim  # Kjører programmet
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>Dette linker (limer sammen) de 3 programmene med libTools.a (som loaderen finner pga -L../Tools) og 
andre biblioteker (-lm tar med et matte-bibliotek) og lager en kjørbar fil med navn sim. 
Man kan også lage et dynamisk (shared) library med filendelse so.
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

g++ -fpic -c randTools.cpp
g++ -fpic -c calcTools.cpp
g++ -shared -o libsTools.so randTools.o calcTools.o

g++ -o sim mainsim.o simulation.o user.o  -lm  -L../sTools -lsTools
export LD_LIBRARY_PATH="../sTools"
sim  # Kjører programmet
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
<SPAN CLASS="SPAN"></SPAN>
<P>

<H2><A ID="SECTION000146000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">6</SPAN> Layout av en prosess sitt adresserom/segmentation</A>
</H2>
Det virtuelle adresserommet til en prosess er delt opp i regioner eller segmenter og de følgende er de viktigste:

<UL>
<LI>Den statiske binære koden som prosessen kjører, text segmentet, ofte bare kalt text
</LI>
<LI>Heap`en  hvor globale variabler og data som dynamisk generers lagres
</LI>
<LI>Stack`en hvor de lokale variablene lagres, brukes også til funksjonskall
</LI>
<LI>MMAP, minneavbildninger av filer(og devicer) på disk direkte i det virtuelle minnet
</LI>
</UL>

<P>

<DIV class="CENTER"><A ID="2012"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Layout for det virtuelle adresserommet for en Linux-prosess.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="362" HEIGHT="345" STYLE=""
 SRC="img95.png"
 ALT="\includegraphics[width=8cm]{fig/memlayout.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000147000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">7</SPAN> Minneadressering og MMU</A>
</H2>
Et programs virtuelle adressering til variabler, subrutiner, bibliotek, data og så videre 
må knyttes til fysiske adresser. Dette kunne skjedd ved loading, men ville vært svært tidkrevende og tungvint. 
I moderne OS 
gjøres dette dynamisk mens programmene kjører. Dette muligjør at programmer og biblioteker 
kan flyttes til og fra harddisk og bare loades når det er behov for dem. 
Om OS skulle oversette fysiske adresser til logiske/virtuelle, ville det belaste CPU-en for mye, så 
dette tar en egen enhet, MMU (Memory Managment Unit), seg av.

<DIV class="CENTER"><A ID="mmu"></A><A ID="2019"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">MMU oversetter logiske adresser fra CPU til fysiske RAM-adresser i realtime</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="452" HEIGHT="272" STYLE=""
 SRC="img96.png"
 ALT="\includegraphics[width=10cm]{fig/MMU.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<H2><A ID="SECTION000148000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">8</SPAN> Eksempel på MMU-tabell</A>
</H2>
Anta at de to programmene Prog1 og Prog2 skal kjøre på en maskin. Som i Fig. <A HREF="#prog12">72</A> 
vil adressene i de kompilerte programmene være logiske og ikke til en fastlagt adresse i minne. 
Dette fordi man da bare trenger å oppdatere MMU-tabellene når programmene plasseres eller omplasseres i RAM.

<DIV class="CENTER"><A ID="prog12"></A><A ID="2028"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Den kompilerte Prog1 og Prog2 maskinkoden inneholder logiske adresser</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="452" HEIGHT="444" STYLE=""
 SRC="img97.png"
 ALT="\includegraphics[width=10cm]{fig/prog12.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>
Når CPU utfører instruksjonen 'load 32' for Prog1 som refererer til minnet sendes 
den logiske adressen 32 til MMU som bruker sin tabell for Prog1-adresser til å oversette til
den fysiske adressen 132, slik at riktig byte blir loadet. MMU trenger da tabeller som 
ser slik ut:
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TH CLASS="CENTER" COLSPAN=2><SPAN>Prog1</SPAN></TH>
<TH CLASS="CENTER" COLSPAN=2><SPAN>Prog2</SPAN></TH>
</TR>
<TR><TD CLASS="LEFT">0</TD>
<TD CLASS="LEFT">100</TD>
<TD CLASS="LEFT">0</TD>
<TD CLASS="LEFT">150</TD>
</TR>
<TR><TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
</TR>
<TR><TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
</TR>
<TR><TD CLASS="LEFT">24</TD>
<TD CLASS="LEFT">124</TD>
<TD CLASS="LEFT">28</TD>
<TD CLASS="LEFT">178</TD>
</TR>
<TR><TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
</TR>
<TR><TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
</TR>
<TR><TD CLASS="LEFT">32</TD>
<TD CLASS="LEFT">132</TD>
<TD CLASS="LEFT">36</TD>
<TD CLASS="LEFT">186</TD>
</TR>
<TR><TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
<TD CLASS="LEFT">.</TD>
</TR>
<TR><TD CLASS="LEFT">40</TD>
<TD CLASS="LEFT">140</TD>
<TD CLASS="LEFT">40</TD>
<TD CLASS="LEFT">190</TD>
</TR>
</TABLE> 
<BR>
<BR>
<BR>
Men det vil være alt for minnekrevende å ha en linje i tabellen for 
hver adresse! Det logiske minnet deles derfor opp i pages som legges 
i det fysiske minnet hver for seg. I eksempelet over kunne en page 
f. eks. utgjøre 50 adresser. MMU trengte da bare å vite at Prog1 
starte på adresse 100 og at Prog2 startet på adresse 150.

<P>

<H2><A ID="SECTION000149000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">9</SPAN> Paging</A>
</H2>
Ved å dele inn minnet i like store biter (pages/sider), vil man effektivt kunne laste disse sidene 
inn og ut av minnet og samtidig enkelt holde oversikt over hvor hver side er i en page-tabell. Dette gjør at det er 
enkelt og plassbesparende å dynamisk allokere (sette av) nytt minne til en prosess. Man unngår den fragmentering som ville 
oppstått om vilkårlig store biter av minnet ble tildelt en prosess. Når prosessen ble avluttet, ville det da blit et hull 
med tilgjengelig med akkurat denne størrelsen. Ved å bruke faste sidestørrelser, unngår man slike ujevnt store hull. 
Inndelingen i sider gjør at deler av programmer effektivt kan lastes inn og ut av minnet og dermed 
gjør det enkelt å implementere virtuelt minne. En viktig fordel for OS er at med full oversikt over en prosess sitt minnet i en 
page-tabell, er det lett å kontrollere at prosessen bare skriver til det minnet den er tildelt. Oppsummert har 
bruk av logiske eller virtuelle minneadresser og inndeling av disse i sider av samme størrelse har følgende fordeler:

<UL>
<LI>Fast sidestørrelser hindrer fragmentering
</LI>
<LI>Dynamisk flytting av deler av prosesser til og fra disk
</LI>
<LI>Full kontroll for OS over prosessers minnebruk
</LI>
<LI>Mulliggjør å bruke diskplass til å utvide minnet, virtuelt minne
</LI>
</UL>

<P>

<H2><A ID="SECTION0001410000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">10</SPAN> Pages</A>
</H2>
En page har en størrelse <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.61ex; vertical-align: -0.12ex; " SRC="img98.png"
 ALT="$2^n$"></SPAN> bytes og typisk er n = 12 eller 13 og 
page-størrelsen er dermed 4 eller 8 Kbytes. Den konkrete størrelsen avhenger av prosessorens arkitektur. 
4Kbytes er vanlig for X86-prosessorer. Figur <A HREF="#paging">73</A> hviser et eksempel på 
hvordan pages kan fordeles i minnet og hvor enkel MMU-tabellen da blir. Ved en context switch 
lagres tabellen for den gamle prosessen i dens PCB og tabellen til den nye prosessen 
lastes inn i MMU.

<P>

<DIV class="CENTER"><A ID="paging"></A><A ID="2049"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Logisk minne og paging</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="447" HEIGHT="390" STYLE=""
 SRC="img99.png"
 ALT="\includegraphics[width=10cm]{fig/paging.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
En prosess som bruker 100Mbyte minne vil med 4Kbyte page størrelse bestå av omtrent 25.000 sider men en prosess som bruker 4GByte RAM vil ha en million sider i MMU. Det er ikke plass til å lagre 
adressen til alle disse sidene i selve MMU og den fullstendige tabellen ligger selv i internminnet. Men MMU bruker en 
Translation Lookaside Buffer (TLB) som er hurtig cache minne som inneholder en del av page-tabellen. Ved oppslag på adresser til 
sider som ikke ligger her, hentes de fra minnet, men da tar det vesentlig lenger tid.

<P>

<H2><A ID="SECTION0001411000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">11</SPAN> MMU eksempel med 4k page-størrelse</A>
</H2>
I Figur <A HREF="#paging1">74</A> som er hentet fra Tanenbaum, ser man et eksempel på en avbilding fra det virtuelle 64K store virtuelle adresserrommet til det 32K store fysiske adresserommet. Vanligvis er begge adresserom mye større. Og man må huske at hver prosess får tildelt sitt eget adresserom og dette peker på fysiske adresser i RAM. Andre prosesser vil da peke til andre steder i RAM. Hver gang det gjøres en context switch og en annen prosess starter å kjøre på en CPU, må denne prosessens MMU-tabell lastes inn før den kan begynne å kjøre. Dette er eksempel på en slik tabell etter at den er lastet inn. Vi ser at det er åtte (0-7) virtuelle pages som peker på åtte fysiske page-frames i RAM.

<P>

<DIV class="CENTER"><A ID="paging1"></A><A ID="2058"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Figure 3-9 i Tanenbaum. Forholdet mellom virtuelle og fysiske adresser</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="451" HEIGHT="636" STYLE=""
 SRC="img100.png"
 ALT="\includegraphics[width=10cm]{fig/03-09.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Når MMU mottar en innkommende virtuell adresse, 8196 i eksempelet i Figur <A HREF="#paging2">75</A>, må denne adressen ekstremt hurtig oversettes til en fysisk adresse. I dette tilfellet er side-størrelsen 4K og 12 bit vil da kunne brukes til å adressere hele siden. Det virtuelle adresserommet er på 64k og man trenger da 16 bit for å adressere hele dette adresserommet. 

<P>

<DIV class="CENTER"><A ID="paging2"></A><A ID="2066"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Figure 3-10 i Tanenbaum. Slik oversetter MMU virtuelle(logiske) adresser til fysiske.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="451" HEIGHT="501" STYLE=""
 SRC="img101.png"
 ALT="\includegraphics[width=10cm]{fig/03-10.eps}">

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Vi ser at de fire første bit'ene brukes til å angi hvilket nummer i rekken av 16 pages som en adresse hører til. I eksempelet er de fire første bit'ene 0010 = 2 og det betyr dermed virtuell page nr. 2. MMU-tabellen viser hvilken fysisk frame hver av de 16 virtuelle sidene peker på og vi ser at page 2 peker på fysisk frame nummer 110 = 6. Dette kan vi også se i Figur <A HREF="#paging">73</A>, der en pil viser at page nummer 2 peker på fysisk frame nummer 6 (man starter å telle på null). Oversettelsen skjer lynraskt ved at de tre bit'ene i indeks 2 i MMU-tabellen, 110, hektes på foran de 12 bit'ene som forteller hvor i den 4K store framen byte'en som ønskes ligger. Dette gir dermed øyeblikkelig den utgående adressen 24580. Det fysiske adresserommet er på 32k og 15 bit er da nok til å dekke hele adresserommet. 

<P>
Hver page har 2<code>^</code>12 = 4096 adresser. Page 0 begynner på 0, page 1 begynner på 4096, page 2 begynner på 8192 og så videre. Inkommende adresse er 8196, fordi den er 2x4096 (første byte page 2, 0010) + offset 4 (100) som tilsammen blir 8192 + 4 = 8196. Den utgående adressen til fysisk frame blir 24580, fordi den er 6*4096 (første byte page 6, 110) + offset 4 (100) som tilsammen blir 24576 + 4 = 24580. 

<P>

<H2><A ID="SECTION0001412000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">12</SPAN> Paging og swapping</A>
</H2>
Å dele in det logiske minnet i pages gjør det mulig å dynamisk laste inn og ut deler av en 
prosess. Dermed kan minnet til det samlede antall prosesser på en maskin være 
større enn det fysiske minnet, resten lagres page for page på harddisk på swap-området.  
Det virtuelle minnet til en prosess kan da fysisk lagres både i RAM og på disk. I Fig. <A HREF="#virtuelt">77</A> har fysisk minne 
bare plass til 3 pages og resten må lagres på disk. Det å laste pages til og fra swap-området 
på disken kalles "paging".

<P>

<DIV class="CENTER"><A ID="virtuelt"></A><A ID="2076"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Virtuelt minne. Bare en page av Prog2 ligger i minne. Om data fra 
page 5 eller 6 blir spurt etter, må disse lastes inn.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="543" HEIGHT="361" STYLE=""
 SRC="img102.png"
 ALT="\includegraphics[width=12cm]{fig/virtuelt.eps}"> 
g
</DIV></TD></TR>
</TABLE>
</DIV>

<P>
Tidligere var swapping eneste måte å bruke disk til virtuelt minne; da blir hele prosessen lastet ut på disk. 
Med en disk med lesehastighet på 100MByte/s tar det 10 sekunder å swappe en prosess på 1 GByte. 
Swapping brukes i moderne OS oftest bare når det er ekstrem mangel på minne. Er det fysiske 
minnet altfor lite, vil OS bruke nesten all sin tid på å flytte sider til og fra disk; dette 
kalles trashing. Det er viktig å huske at det kan ta flere hundere tusen ganger så lang tid å hente 
pages fra en disk som å aksessere RAM, så virtuelt minne kan på ingen måte fullt ut erstatte RAM.

<P>

<H2><A ID="SECTION0001413000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">13</SPAN> Page Table entry</A>
</H2>

<P>

<DIV class="CENTER"><A ID="virtuelt"></A><A ID="2084"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Page table entry.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="543" HEIGHT="154" STYLE=""
 SRC="img103.png"
 ALT="\includegraphics[width=12cm]{fig/pageEntry.pdf}"> 
g
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<UL>
<LI>Page Frame nummer: Fysisk frame-nummer i RAM
</LI>
<LI>Present: Hvis 0 blir det en page-fault
</LI>
<LI>Endret: Hvis 1 er siden dirty og må skrives til disk om den fjernes
</LI>
<LI>Rettigheter: lese, skrive, kjøre
</LI>
<LI>Referenced: settes hvis brukt, brukes av paging-algoritmer
</LI>
</UL>

<P>

<H2><A ID="SECTION0001414000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">14</SPAN> TLB - Translation Lookaside Buffer</A>
</H2>

<UL>
<LI>En prosess som bruker 100Mbyte minne vil med 4Kbyte page størrelse bestå av omtrent 25.000 sider
</LI>
<LI>4GByte prosess gir en million sider i MMU
</LI>
<LI>Ikke plass til å lagre adressen til alle disse sidene i MMU
</LI>
<LI>Den fullstendige tabellen ligger selv i internminnet
</LI>
<LI>MMU bruker en Translation Lookaside Buffer (TLB) som er hurtig cache minne
</LI>
<LI>Inneholder en liten del av page-tabellen, 
</LI>
<LI>Ved oppslag på adresser til sider som ikke ligger i TLB, hentes de fra RAM
</LI>
<LI>Kalles TLB-miss eller soft-miss. Tar vesentlig lenger tid enn om adressen er i TLB   
</LI>
</UL>

<P>

<H2><A ID="SECTION0001415000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">15</SPAN> Typisk TLB ytelse</A>
</H2>

<UL>
<LI>størrelse: 16 - 4096 linjer  (1 - 256 kBytes)
</LI>
<LI>En cache linje er vanligvis 64 bytes
</LI>
<LI>oppslagstid: 0.5 - 1 klokke-sykel
</LI>
<LI>ekstra tid ved TLB-miss: 10-100 klokke-sykler
</LI>
<LI>TLB-miss frekvens: 0.01 - 1% 
</LI>
</UL>

<P>

<H2><A ID="SECTION0001416000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">16</SPAN> Internminnet og Cache</A>
</H2>
Vi har tidligere sett at for å kunne fore en hurtig prosessor med instruksjoner og data raskt nok, bruker man 
flere nivåer av mellomlagring av data, såkalt cache-minne. Det går vesentlig 
raskere å hente minne fra cache-minnet enn fra internminnet. I Fig. <A HREF="node8.html#Cache">45</A> så vi  
noen typiske størrelser og aksesstider for de sentrale lagringsmedien som finnes i en datamaskin, fra registre til harddisk. 
Spesielt bemerket vi den store forskjellen i aksesstid mellom internminnet og harddisk. 

<P>
Cache inneholder både data, instruksjoner og deler av MMU page-tables i TLB (Translation Lookaside Buffer). I L1 cache er 
ofte disse egne enheter, mens L2 cache pleier å være en enhet. I de senere årene har man klart å få plass til L2 på selve  
prosessorchip'en (den lille brikken som utgjør mikroprosessoren, bare noen kvadratcentimeter stor). Arkitekturen til en 
moderne prosessor kan da i grove trekk se ut som i Fig. <A HREF="#Cache2">78</A>.

<P>

<DIV class="CENTER"><A ID="Cache2"></A><A ID="2102"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Level 1 cache (L1) bestående av tre deler. I AMD Athlon 64 er TLB i tillegg delt i to deler, en for 
adresser til instruksjoner og en for adresser til data.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="544" HEIGHT="240" STYLE=""
 SRC="img66.png"
 ALT="\includegraphics[width=12cm]{fig/osaCache2.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>
Noen arkitekturer har 
i tillegg enda et lag i minnehierarkiet, en offchip L3 cache som sitter mellom mikroprosessoren og RAM. 
For Intel Core i7 og AMD Opteron K10 har også L3 cache fått plass på prosessor-chip'en.

<P>

<H2><A ID="SECTION0001417000000000000000">
<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">17</SPAN> Paging-algoritmer</A>
</H2>

<OL>
<LI>Page-fault (En page mangler i minnet; ligger på swap på disk)
</LI>
<LI>Ingen ledig frame i minnet
</LI>
<LI>OS må velge hvilken page som skal legges på disk
</LI>
<LI>Gjøres av paging-algoritme
</LI>
</OL>

<P>

<P>
<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2026-01-13
</ADDRESS>
</BODY>
</HTML>
