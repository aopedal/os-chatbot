<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>5 Forelesning 12/2-26(2 timer). Bash-scripting</TITLE>
<META NAME="description" CONTENT="5 Forelesning 12/2-26(2 timer). Bash-scripting">
<META NAME="keywords" CONTENT="linux">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY >
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html559"
  HREF="node6.html#SECTION00061000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
<LI><A ID="tex2html560"
  HREF="node6.html#SECTION00062000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Passord-kryptering</A>
<UL>
<LI><A ID="tex2html561"
  HREF="node6.html#SECTION00062100000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Hashing-algoritmer</A>
<LI><A ID="tex2html562"
  HREF="node6.html#SECTION00062200000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Passord-cracking</A>
</UL>
<BR>
<LI><A ID="tex2html563"
  HREF="node6.html#SECTION00063000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> find</A>
<LI><A ID="tex2html564"
  HREF="node6.html#SECTION00064000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> sed</A>
<LI><A ID="tex2html565"
  HREF="node6.html#SECTION00065000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> sort</A>
<UL>
<LI><A ID="tex2html566"
  HREF="node6.html#SECTION00065100000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Sortert alfabetisk</A>
<LI><A ID="tex2html567"
  HREF="node6.html#SECTION00065200000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sortert alfabetisk etter andre kolonne</A>
<LI><A ID="tex2html568"
  HREF="node6.html#SECTION00065300000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sortert numerisk etter tredje kolonne</A>
</UL>
<BR>
<LI><A ID="tex2html569"
  HREF="node6.html#SECTION00066000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> head og tail</A>
<LI><A ID="tex2html570"
  HREF="node6.html#SECTION00067000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> cut</A>
<LI><A ID="tex2html571"
  HREF="node6.html#SECTION00068000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> Input fra bruker</A>
<LI><A ID="tex2html572"
  HREF="node6.html#SECTION00069000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> Lese filer og output med while og read</A>
<LI><A ID="tex2html573"
  HREF="node6.html#SECTION000610000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> Arrays</A>
<LI><A ID="tex2html574"
  HREF="node6.html#SECTION000611000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> Et vanlig problem med pipe til while og read</A>
<LI><A ID="tex2html575"
  HREF="node6.html#SECTION000612000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> Assosiative array</A>
<LI><A ID="tex2html576"
  HREF="node6.html#SECTION000613000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> funksjoner</A>
<LI><A ID="tex2html577"
  HREF="node6.html#SECTION000614000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> funksjoner og parametre</A>
<LI><A ID="tex2html578"
  HREF="node6.html#SECTION000615000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> Signaler og trap</A>
<LI><A ID="tex2html579"
  HREF="node6.html#SECTION000616000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> Oversikt over shell-typer</A>
<LI><A ID="tex2html580"
  HREF="node6.html#SECTION000617000000000000000"><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> Oppstartsfiler</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION00060000000000000000">
<SPAN CLASS="arabic">5</SPAN> Forelesning 12/2-26(2 timer).   Bash-scripting</A>
</H1>

<H2><A ID="SECTION00061000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Forelesningsvideoer</A>
</H2>
Denne forelesningen ble ikke holdt live, men opptak av forelesningene er samlet her. 
Opptak av forelesningen inndelt etter temaer:

<P>
<A ID="tex2html60"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del1.mp4">linux5del1.mp4</A>
(07:32) Demo: Passord-kryptering

<BR><A ID="tex2html61"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del2.mp4">linux5del2.mp4</A>
(06:17) Slides: Passord-cracking

<BR><A ID="tex2html62"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del3.mp4">linux5del3.mp4</A>
(05:23) Demo: find

<BR><A ID="tex2html63"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del4.mp4">linux5del4.mp4</A>
(04:11) Demo: Sed og sort

<BR><A ID="tex2html64"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del5.mp4">linux5del5.mp4</A>
(06:43) Demo: head og tail

<BR><A ID="tex2html65"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del6.mp4">linux5del6.mp4</A>
(03:20) Demo: cut

<BR><A ID="tex2html66"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del7.mp4">linux5del7.mp4</A>
(01:18) Demo: Input fra bruker til script

<BR><A ID="tex2html67"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del8.mp4">linux5del8.mp4</A>
(03:29) Demo: Lese en fil linje for linje med while og read

<BR><A ID="tex2html68"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del9.mp4">linux5del9.mp4</A>
(03:25) Demo: Lese passordfilen linje for linje med while og read og trekke ut kolonner

<BR><A ID="tex2html69"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del10.mp4">linux5del10.mp4</A>
(06:23) Demo: Gå igjennom ps aux linje for linje med while og read og trekke ut kolonner

<BR><A ID="tex2html70"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del11.mp4">linux5del11.mp4</A>
(06:45) Demo: Array i bash

<BR><A ID="tex2html71"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del12.mp4">linux5del12.mp4</A>
(04:02) Demo: Et vanlig problem med pipe til while og read

<BR><A ID="tex2html72"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del13.mp4">linux5del13.mp4</A>
(05:00) Demo: Assosiative array

<BR><A ID="tex2html73"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del14.mp4">linux5del14.mp4</A>
(05:56) Demo: Funksjoner og parametre

<BR><A ID="tex2html74"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/2021/linux5del15.mp4">linux5del15.mp4</A>
(04:51) Demo: Signaler og trap

<P>

<H2><A ID="SECTION00062000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Passord-kryptering</A>
</H2>

<P>
Alle brukere på en Linux server har en linje i /etc/passwd. For eksempel: 

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
rex:~$ grep haugerud /etc/passwd
haugerud:x:285:1001:Hårek Haugerud,,,:/home/haugerud:/bin/bash
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Tidligere stod det en hash av passordet der istedet for x i andre kolonne. Denne hashen er en kryptert versjon av passordet og ligger nå i <code>/etc/shadow</code> og kan bare leses av root. Det er kun hashen som lagres og dette gjør at man kan logge inn på en datamaskin uten at passordet er lagret i klartekst noe sted. Om en slik liste med passord i klartekst blir lekket, ville det vært katastrofe. Men det er også alvorlig om en liste med passord-hasher blir fritt tilgjengelig.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
rex:~$ sudo grep haugerud /etc/shadow
[sudo] passord for haugerud: 
haugerud:$6$WXQf3H3AUREz8y$IRYwxMcpK/aTX4oF.xEJrol.Va7cjGY4V.93wkKCc3Tcd9JV0mPIPjyqBuljB3UPw6.VPJx/ymiCJlxsk5lBv.:17835:0:99999:7:::
</PRE><SPAN CLASS="SPAN"></SPAN>

<P>
Hashen kan (med rett 'salt') genereres med kommandoen <code>mkpasswd</code>:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>              
rex:~$ mkpasswd -m sha-512 -S WXQf3H3AUREz8y
Passord: 
$6$WXQf3H3AUREz8y$IRYwxMcpK/aTX4oF.xEJrol.Va7cjGY4V.93wkKCc3Tcd9JV0mPIPjyqBuljB3UPw6.VPJx/ymiCJlxsk5lBv.
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Hvilken kryptografisk hashing-metode som er brukt kan sees av de første tegnene i hashen:

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Første tegn</TD>
<TD CLASS="LEFT">Algoritme</TD>
</TR>
<TR><TD CLASS="LEFT">To tegn</TD>
<TD CLASS="LEFT">DES (13 totalt)</TD>
</TR>
<TR><TD CLASS="LEFT">$1$</TD>
<TD CLASS="LEFT">md5</TD>
</TR>
<TR><TD CLASS="LEFT">$5$</TD>
<TD CLASS="LEFT">sha256</TD>
</TR>
<TR><TD CLASS="LEFT">$6$</TD>
<TD CLASS="LEFT">sha512</TD>
</TR>
</TABLE> 
<BR>
<BR>
<P>
Saltet er de etterfølgende tegnene frem til $-tegnet. Dette saltet gjør det vanskeligere å bruke enkelte brute force metoder som rainbow tables for å cracke passord om man kjenner en hash for et passord. Ved login skjer følgende:

<P>

<OL>
<LI>Man taster passord
</LI>
<LI>Login-shellet krypterer passordet
</LI>
<LI>Sjekker mot /etc/shadow
</LI>
<LI>Hvis likt <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.05ex; vertical-align: -0.12ex; " SRC="img4.png"
 ALT="$\rightarrow$"></SPAN> login
</LI>
</OL>
 
<DIV class="CENTER"><A ID="748"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Passordkryptering</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="544" HEIGHT="152" STYLE=""
 SRC="img13.png"
 ALT="\includegraphics[width=12cm]{unixFig/passord.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>
For 4 år siden lå alle bruker-hashene i <code>/etc/shadow</code>, men nå autentiseres den som logger seg inn på studssh ved
 hjelp av PAM (pluggable authentication module) mot AD (Active Directory) sentralt på OsloMet.

<P>

<H3><A ID="SECTION00062100000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Hashing-algoritmer</A>
</H3>
Med <code>mkpasswd</code> kan man velge hvilken hashing-metode man vil bruke:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ mkpasswd -m help
Available methods:
des	standard 56 bit DES-based crypt(3)
md5	MD5
sha-256	SHA-256
sha-512	SHA-512
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette er enveisalgoritmer som for et gitt passord generere en entydig lengre streng av tegn. DES var tidligere standard, men ble  så 
avløst av MD5 som er noe bedre, og nå er sha-512 standard metode for Linux. De samme prinsippene gjelder for Windows-innlogging, der lagres hash-strengene i SAM-databasen på en lokal Windows-maskin eller på en sentral server i Active Directory. 
 Tidligere var LM-hash(DES) standard, men den ble etterhvert avløst av NTLM-hash(MD5) og etterhvert av kraftigere algoritmer som AES(Advanced Encryption Standard).

<H3><A ID="SECTION00062200000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Passord-cracking</A>
</H3>
Hvis man har tilgang til shadowfilen på Linux eller SAM-databasen på Windows, kan et crack-program
kryptere alle ord og kombinasjoner av ord i en ordbok og sammenligne med de krypterte passordene.  Hvis ett av de riktige passordene velges, vil det avsløres ved at det gir en av hashene. Slike program kan teste hundretusner av passord 
per sekund, slik at passord fra ordbøker veldig raskt kan knekkes. Jo lengre passordene er og jo flere tegn som brukes i passordene, desto mer tidkrevende er det for passord-cracker program å teste ut alle mulige kombinasjoner.

<P>
Hvis man går ut ifra 52 tegn (a-z og A-Z), 10 tall og 32 spesialtegn, har man totalt 94 mulige tegn i et passord. Og om man har en kraftig GPU-server kan man regne ut en million hasher i sekundet for algortimer som sha512, mange flere for enklere algortimer. For åtte tegn i passordet er det <!-- MATH
 $8^{62} = 2.18 \cdot 10^{14}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.03ex; vertical-align: -0.12ex; " SRC="img14.png"
 ALT="$8^{62} = 2.18 \cdot 10^{14}$"></SPAN> eller 218 billioner mulige kombinasjoner. For å finne hash'ene for alle mulige kombinasjoner, tar det da i underkant av 7 år om man regner ut en million hash i sekundet. Tid for forskjellige lengder av passord er vist i følgende tabell:

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Lengde</TD>
<TD CLASS="LEFT">tid (36 tegn)</TD>
<TD CLASS="LEFT">tid (62 tegn)</TD>
<TD CLASS="LEFT">tid (94 tegn)</TD>
</TR>
<TR><TD CLASS="LEFT">4</TD>
<TD CLASS="LEFT">1.7 sekunder</TD>
<TD CLASS="LEFT">15 sekunder</TD>
<TD CLASS="LEFT">78 sekunder</TD>
</TR>
<TR><TD CLASS="LEFT">6</TD>
<TD CLASS="LEFT">36 minutter</TD>
<TD CLASS="LEFT">16 timer</TD>
<TD CLASS="LEFT">192 timer</TD>
</TR>
<TR><TD CLASS="LEFT">8</TD>
<TD CLASS="LEFT">32 dager</TD>
<TD CLASS="LEFT">6.9 år</TD>
<TD CLASS="LEFT">193 år</TD>
</TR>
<TR><TD CLASS="LEFT">10</TD>
<TD CLASS="LEFT">116 år</TD>
<TD CLASS="LEFT">26.6 tusen år</TD>
<TD CLASS="LEFT">1.7 millioner år</TD>
</TR>
</TABLE> 
<BR>
<BR>
<P>
Til sammenligning er det ca en million ord i en norsk ordbok som tar med alle varianter av norske ord, slik at det kun tar ett sekund å finne et passord som er med i en ordbok om man kjenner hashen for passordet. 

<P>
Man ser at lengden på passordet er veldig viktig for hvor raskt det kan være å gjette ved hjelp av et brute force angrep på en hash. I tillegg hjelper det at store bokstaver og spesialtegn tas med. 

<P>

<H2><A ID="SECTION00063000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> find</A>
</H2>
Denne kommandoen kan brukes til å finne filer på systemet. Det er mulig å spesifisere en rekke kriterier. Ønsker man å finne alle filer (og mapper) i hjemmekatalogen som har filendelse c, kan man bruke

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
haugerud@studssh:~$ find ~ -name "*.c"
/iu/nexus/ua/haugerud/os/funk.c
/iu/nexus/ua/haugerud/os/old/main.c
/iu/nexus/ua/haugerud/os/old/sum.c
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
For å finne alle filer og mapper som ble endret mer nylig enn 4 februar 2019 kl 19:55, kan man gjøre

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
haugerud@studssh:~$ find . -newermt "4 Feb 2019 19:55"  -ls 
     9714      4 drwxr-xr-x  20 haugerud drift        4096 feb.  5 10:28 .
    29479      4 -rw-------   1 haugerud drift         318 feb.  5 10:28 ./.Xauthority
    29374      4 -rw-r--r--   1 haugerud drift          10 feb.  5 20:07 ./fil
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
der <code>-ls</code> gir en mer detaljert listing. Tilsvarende kan man finne alle filer som har blitt endret mellom to tidspunkt med 

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
haugerud@studssh:~$ find . -type f -newermt "29 Jan 2019 19:55" ! -newermt "29 Jan 2019 22:55" -ls 
    29422      4 -rwx------   1 haugerud drift          56 jan. 29 22:40 ./mappe/arg.sh~
    29423      4 -rwx------   1 haugerud drift          58 jan. 29 22:42 ./mappe/arg.sh
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
hvor <code>-type f</code> gir kun filer.

<P>

<H2><A ID="SECTION00064000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> sed</A>
</H2>
Kommandoen sed kan brukes til å bytte ut forekomster av ord i setninger:
<SPAN CLASS="SPAN"></SPAN><PRE>
echo dette er en test | sed s/test/fisk/
echo test og test | sed s/test/fisk/
echo test og test | sed s/test/fisk/g
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<P>

<H2><A ID="SECTION00065000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> sort</A>
</H2>
I tillegg til at man kan sende output fra en Linux-kommando inn til input for en annen, kan man også legge til en rekke opsjoner. På denne måten kan man få til veldig mye med enlinjers sammensatte kommandoer. Manualsiden til sort avslører at opsjonen -k gjør at man kan velge hvilken kolonne man vil sortere med hensyn på, mens -n gjør at man sorterer numerisk slik følgende eksempel viser. Utgangspunktet er filen <code>biler</code> som ser slik ut:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ cat biler
student bmw 500000
haugerud berlingo 150000
kyrre elbil 90000
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Denne filen kan man nå sortere som man ønsker med de rette opsjoner.

<H3><A ID="SECTION00065100000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Sortert alfabetisk</A>
</H3>

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ sort biler
haugerud berlingo 150000
kyrre elbil 90000
student bmw 500000
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H3><A ID="SECTION00065200000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Sortert alfabetisk etter andre kolonne</A>
</H3>

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ sort -k 2 biler
haugerud berlingo 150000
student bmw 500000
kyrre elbil 90000
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H3><A ID="SECTION00065300000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sortert numerisk etter tredje kolonne</A>
</H3>

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ sort -n -k 3 biler
kyrre elbil 90000
haugerud berlingo 150000
student bmw 500000
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Default sender sort output til shellet, hvis man ønsker at reaultatet skal lagres i en fil må man be om det

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
 sort -n -k 3 biler &gt; sortertFil
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION00066000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> head og tail</A>
</H2>
Hvis man ønsker å se kun de 6 første linjene av en utgave av passordfilen på studssh sortert etter femte kolonne kan man bruke <code>head</code> for å få til det:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
studssh:~$  sort -t: -k 5 /etc/passwd | head -n 6
aasej:x:2748:1001:Aase Jenssen:/iu/nexus/uc/aasej:/bin/bash
s137153:x:2603:100:Aasmund Solberg:/iu/cube/u2/s137153:/bin/bash
s103726:x:1089:100:Abdi Farah Ahmad:/iu/cube/u3/s103726:/bin/false
s133988:x:1695:100:Abdi Hassan Abdulle:/iu/cube/u2/s133988:/bin/bash
s123860:x:1090:100:Abdinasir Omar Kahiye:/iu/cube/u2/s123860:/bin/bash
s141546:x:3449:100:Abdiqadir Said Jama:/iu/cube/u3/s141546:/bin/false
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Legg merke til at <code>-t:</code> gjør at tegnet : betraktes som skilleledd mellom kolonnene. Evalueringen av en slik pipeline går fra 
venstre til høyre så hvis man istedet ønsker å se en sortert utgave av de 6 første linjene, får man det med:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
studssh:~$ head -n 6 /etc/passwd | sort -t: -k 5 
bin:x:2:2:bin:/bin:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
games:x:5:60:games:/usr/games:/bin/sh
root:x:0:0:root:/root:/bin/bash
sync:x:4:65534:sync:/bin:/bin/sync
sys:x:3:3:sys:/dev:/bin/sh
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Kommandoen <code>tail</code> gir i motsetning til <code>head</code> de siste linjene. En spesielt nyttig bruk av <code>tail</code> er for 
å se på slutten av log-filer. Hvis man i tillegg tilføyer opsjonen -f vil man kontinuerlig følge med på om det kommer nye linjer til logfilen, for eksempel slik:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
 sudo tail -f /var/log/auth.log
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION00067000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> cut</A>
</H2>
Cut brukes til å klippe ut deler av linjer. Cut leser fra standard input. En vanlig anvendelse er å klippe ut enkelte kolonner fra en tabell.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$cat /etc/passwd | cut -d: -f2 | tail -n 4
group16
mroot
noob
munin
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Her "pipes" innholdet i /etc/passwd til cut, som bruker : som kolonneskille (gitt ved -d:) og som klipper ut kolonne 2 (gitt ved -f2). Dette pipes videre til head, som viser de fire nederst linjene.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$cat /etc/passwd | cut -c -3 | tail -n 4
gro
mro
noo
mun
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Med switchen -c angir vi at vi ønsker å klippe ut "`characters"'. Med -<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN>, der <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN> er et tall, klipper vi ut bare de <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN> første tallene. <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN>- tar tegnene fra tegn <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN> og ut linja, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN>-<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img16.png"
 ALT="$m$"></SPAN> tar alle tegnene mellom tegn <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img15.png"
 ALT="$n$"></SPAN> og <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.12ex; vertical-align: -0.12ex; " SRC="img16.png"
 ALT="$m$"></SPAN>.

<P>

<H2><A ID="SECTION00068000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> Input fra bruker</A>
</H2>
<SPAN CLASS="SPAN"></SPAN><PRE>
#!/bin/bash 

echo -en "svar: \a" # -n dropper linjeskift
read answer
echo "Du svarte $answer"
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
opsjonen <code>-e</code> muligjør bruk av kontrolltegn som <code>\a</code>, som gir ett pip.

<P>

<H2><A ID="SECTION00069000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> Lese filer og output med while og read</A>
</H2>
Veldig ofte ønsker man å gå igjennom og prosessere en fil eller tekstoutput fra en kommando linje 
for linje. Da kan while brukes til å lese input og read til å behandle linje for linje, som i skriptet read.sh:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash

i=0
while read LINE 
do
   (( i++ ))
   echo "Linje nr $i: $LINE"
done
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
read leser linje for linje fra STDIN slik at

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ read.sh &lt; /etc/passwd
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
vil lese passordfilen. <code> read LINE</code> returnerer 0 (alt OK) helt 
til EOF og da stopper while. 

<P>
IFS kan endre hvordan 
<code>read</code> leser inn dataene og filen kan også sendes til <code>read</code> inne i scriptet::

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash

#haugerud:x:285:102:Hårek Haugerud:/iu/nexus/ud/haugerud:/bin/bash
IFS=:
while read brnavn x ID GR NAVN HOME SHELL 
do
   echo "$brnavn: $NAVN"
done &lt; /etc/passwd
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
<code>read</code> leser fra STDIN og dit kan linjene også sendes med en pipe:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash

#haugerud 16662  0.0  0.1  2256 1280 pts/2    S    12:52   0:00 /bin/bash

# Sender all output fra ps aux til \verb+read+:
ps aux |  
   while read bruker PID x x x x x x x x prog
   do
      if [ "$bruker" = "haugerud" ]
      then
         echo "ProsessID = $PID $prog"
      fi
   done
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000610000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> Arrays</A>
</H2>
Et array kan i bash fylles inn med elementer uten å deklarere arrayet først:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
linux:~$ tall[0]=null
linux:~$ tall[1]=en
linux:~$ tall[2]=to
linux:~$ tall[3]=tre
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Den mest naturlige måten å skrive ut et array-element på fungerer ikke:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
linux:~$ echo $tall[1]
null[1]
linux:~$ echo $tall[2]
null[2]
linux:~$ echo ${tall[2]}
to
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Men man må legge inn et sett med krøll-parenteser rundt elementnanvnet for å få skrevet ut. 
Man kan også definere et array ved å skrive inn strenger innenfor en parentes adskilt av mellomrom:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ tall=(null en to tre)
$ echo ${tall[to]}
null
$ echo ${tall[2]}
to
$ tall[4]=fire
$ echo ${#tall[@]} # Antall elementer
5
$ echo ${tall[@]} # Alle verdier
null en to tre fire
$ echo ${!tall[@]} # Index
0 1 2 3 4
$ for t in ${!tall[@]}
&gt; do
&gt; echo "Tall nr $t er ${tall[$t]}"
&gt; done
Tall nr 0 er null
Tall nr 1 er en
Tall nr 2 er to
Tall nr 3 er tre
Tall nr 4 er fire
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000611000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> Et vanlig problem med pipe til while og read</A>
</H2>
Et naturlig forsøk på å sende output til en while-read løkke er følgende(se avsnittet nedenfor
om hvordan man lager et array):

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash
i=0
ps aux | awk '{print $2}' |
while read pid
do
   (( i++ ))
   pidArr[$i]=$pid
done 
echo Antall elementer: ${#pidArr[@]}
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
men om man kjører dette, får man følgende resultat:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ ./pipe.sh
Antall elementer: 0
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette skyldes at når den kommer etter en pipe vil while-konsturksjonen startes i en annen
prosess og variabler som blir laget i denne prosessen (arrayet i eksempelet over) vil forsvinne
når while-prosessen avsluttes. Dette kan løses ved å sende en fil direkte til konstruksjonen eller
mellomlagre output fra pipe'n i en fil:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash
ps aux | awk '{print $2}' &gt; tmp.txt
i=0
while read pid
do
   (( i++ ))
   pidArr[$i]=$pid
done &lt; tmp.txt
echo Antall elementer: ${#pidArr[@]}
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Da vil ønsket resultat oppnås:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ ./pipe.sh
Antall elementer: 742
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Med den spesielle konstruksjon <code>&lt;(kommando)</code> er det også mulig å direkte sende output fra <code>kommando</code>  til
while-read løkken som om det var en fil:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash
i=0
while read pid
do
   (( i++ ))
   pidArr[$i]=$pid
done &lt; &lt;(ps aux | awk '{print $2}')
echo Antall elementer: ${#pidArr[@]}
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Det gir samme ønskede resultat, dataene blir lagret i arrayet og kan brukes etter at løkken er
fullført. Konstruksjon <code>&lt;(kommando)</code> kalles "Process Substitution". 

<P>

<H2><A ID="SECTION000612000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> Assosiative array</A>
</H2>
Assosiative array har, istedet for tall, tekst-strenger som indeks. Et assosiativ array må
deklareres før bruk i bash:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
$ declare -A mann
$ mann[eva]=adam
$ mann[kari]=per
$ mann["Gunn Kari"]="Per Olav"
$ echo ${#mann[@]}
3
$ echo ${mann[@]}
adam Per Olav per
$ echo ${!mann[@]}
eva Gunn Kari kari
$ for k in "${!mann[@]}"
&gt; do
&gt; echo "$k sin mann er ${mann["$k"]}"
&gt; done
eva sin mann er adam
Gunn Kari sin mann er Per Olav
kari sin mann er per
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000613000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> funksjoner</A>
</H2>
En funksjon (function) brukes nesten på samme måte som et selvstendig script. Må inkluderes 
først i scriptet.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#!/bin/bash 

 users()         #deklarasjon av funksjon 
 { 
         date    #skriver ut dagens dato 
         who  # Må ha linjeskift før }
 } 

 users  # kall paa en funksjon; ETTER deklarasjon
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000614000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> funksjoner og parametre</A>
</H2>
Parametre overføres som til bash-script. Og som for script kan kun exit-verdier (tall) returneres, men med 
return og ikke exit.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#!/bin/bash 

 findUser()         #deklarasjon av funksjon
 {
    echo "funk-arg: $*"
    local bruker # Lokal variabel
    bruker=$1    # 1.u argument, dette er en lokal $1, uavhengig av den $1
                 # som er 1. argument til hovedscriptet
    funn=$(grep ^$bruker /etc/passwd)
    if [ "$funn" ]
    then
        return 0 # Alt ok
    fi
    return 1
 }

# Hovedprog 'user.sh', syntaks: $ user.sh bruker1 bruker 2 .....
echo "Script-arg: $*"
for user in $*
do
   echo -e "\nLeter etter $user" # -e tillater \n
   findUser $user    # $user blir $1 i prosedyren
   if [ $? = 0 ]     # Returnverdi fra findUser i $?
   then
      echo "$user finnes"
      echo $funn          # $funn er global
   else
      echo "$user finnes ikke"
   fi
done

echo -e "\nScript-arg: $*"

#BUG: $ user.sh haug -&gt; slår til på linjen haugerud i /etc/passwd
# Kan bruke 'while read'-konstruksjon for å trekke ut brukernavn fra linjene
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
<EM>Funksjoner kan også defineres direkte i et terminalvindu, men forsvinner når shellet avsluttes. 
Man kan lagre egne funskjoner i en fil, f. eks. <code>funk.bash</code> og inkludere funskjonene i flere script 
ved å starte scriptene med som følger:</EM>

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash

. funk.bash  # Alternativt 'source funk.bash' I begge tilfeller tilsvarer 
             # det å taste inn all koden i filen funk.bash inn i 
             # begynnelsen av dette scriptet
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000615000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> Signaler og trap</A>
</H2>
En prosess kan stoppes av andre prosesser og av kjernen. Det gjøres ved å sende 
et signal. Alle signaler bortsett fra SIGKILL (<code>kill -9</code>) kan stoppes og 
behandles av bash-script med kommandoen <code>trap</code>. Følgende script kan bare stoppes 
ved å sende (<code>kill -9</code>) fra et annent shell.

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
#! /bin/bash

# Definisjoner fra 
# /usr/src/linux-headers-3.13.0-106/arch/x86/include/uapi/asm/signal.h

#define SIGHUP          1       /* Hangup (POSIX).  */
#define SIGINT          2       /* Interrupt (ANSI).  */
#define SIGKILL         9       /* Kill, unblockable (POSIX).  */
#define SIGTERM         15      /* Termination (ANSI).  */
#define SIGTSTP         20      /* Keyboard stop (POSIX).  */

trap 'echo -e "\rSorry; ignores kill -1 (HUP)\r"' 1
trap 'echo -e "\rSorry; ignores kill -15 (TERM)\r"' 15
trap 'echo -e "\rSorry; ignores CTRL-C\r"' 2
trap 'echo -e "\rSorry; ignores CTRL-Z\r"' 20
trap 'echo -e "\rSorry; ignores kill - 3 4 5\r"' 3 4 5
trap 'echo -e "\rCannot stop kill -9\r"' 9

while [ true ]
do
   echo -en "\a quit? Answer y or n: "
   read answer
   if [ "$answer" = "y" ]
        then break
   fi
done
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000616000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> Oversikt over shell-typer</A>
</H2>
<EM>Det finnes mange forskjellige typer shell og det shellet som nå er mest brukt i
             Linux-distribusjoner og som brukes her ved OsloMet  
er bash (vi skiftet fra tcsh i 2001). 
Det er en forbedring og utvidelse av det originale Linux-shellet Bourne Shell (sh)</EM>
<BR>
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER" COLSPAN=2><SPAN>Bourne-shell type</SPAN></TD>
<TD CLASS="CENTER" COLSPAN=2><SPAN>C-shell type</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT">sh</TD>
<TD CLASS="LEFT">Bourne-shell, Det opprinnelige Linux-shell</TD>
<TD CLASS="LEFT">csh</TD>
<TD CLASS="LEFT">C-shell, C-syntaks</TD>
</TR>
<TR><TD CLASS="LEFT">bash</TD>
<TD CLASS="LEFT">Bourne-again-shell, forbedret sh</TD>
<TD CLASS="LEFT">tcsh</TD>
<TD CLASS="LEFT">forbedret csh, bedre interaktivt</TD>
</TR>
<TR><TD CLASS="LEFT">ksh</TD>
<TD CLASS="LEFT">Korn-shell, utvidet sh, mye fra csh</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>

<P>

<UL>
<LI>De fleste Linux/Linux system-script er skrevet i Bourne-shell, <code>/bin/sh</code>
</LI>
<LI>Bourne-again-shell (bash), er default Linux-shell
</LI>
<LI>bash kan kjøre alle Bourne-shell script
</LI>
<LI>bash er Free Software Foundation's (FSF) Linux-shell
</LI>
</UL>
Under Linux: 

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
haugerud@studssh:~$ ls -l /bin/sh
lrwxrwxrwx 1 root root 4 feb.  19  2014 /bin/sh -&gt; dash
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Debian Almquist shell (dash) er et mindre og hurtigere shell enn bash. Det ligger nærmere det 
originale Bourne-shell og har for Ubuntu blitt brukt som Bourne-substitutt siden 2006.

<H2><A ID="SECTION000617000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> Oppstartsfiler</A>
</H2>
Hver gang et nytt terminalvindu (f. eks. xterm) startes, startes bash og 
du får et prompt som du kan taste inn kommandoer ved. Hver gang bash startes leses en 
konfigurasjonsfil som ligger øverst i brukerens hjemmemappe og heter <code>.bashrc</code>. 
Alle kommandoer som 
står der blir utført. Hver gang du logger inn, utføres kommandoene i <code>/etc/profile</code> 
og  <code>~/.bash_profile</code>. 

<P>
Et nytt shell startes hver gang

<UL>
<LI>man logger inn på en maskin (ssh, telnet)
</LI>
<LI>et nytt terminalvindu åpnes (xterm)
</LI>
<LI>et nytt shell startes eksplisitt($ bash)
</LI>
</UL>
Shellet utfører først kommandoer i noen oppstartsfiler:

<UL>
<LI><code>/etc/profile</code> ved hver innlogging, systemfil
</LI>
<LI><code>~/.bash_profile</code> ved hver innlogging
</LI>
<LI><code>/etc/bash.bashrc</code> for hvert nytt shell, men ikke ved innlogging, systemfil
</LI>
<LI><code>~/.bashrc</code> for hvert nytt shell, men ikke ved innlogging
</LI>
</UL>
<EM>I disse filene kan f. eks. definisjoner av shell-variabler og alias'er legges.</EM>

<P>
Eksempel på innhold:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>
PS1="\h:\w$ "
alias move=mv
alias cp="cp -i"
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
Legges dette i <code>~/.bashrc</code> vil <code>move</code> alltid bety <code>mv</code> 
og promptet blir:

<P>
<SPAN CLASS="SPAN"></SPAN><PRE>              
$ bash                 
studssh:~/www/os$ exit    
exit                   
$ source ~/.bashrc     
studssh:~/www/os$
</PRE><SPAN CLASS="SPAN">
</SPAN>
<P>
<code>source</code> starter <B>ikke</B> et nytt shell, men utfører alt i det eksisterende shellet.

<P>
<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2026-01-13
</ADDRESS>
</BODY>
</HTML>
