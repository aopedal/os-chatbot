<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021 (Released January 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>10 Forelesning 2/4-24(2 timer). Docker Compose, virtuelle maskiner</TITLE>
<META NAME="description" CONTENT="10 Forelesning 2/4-24(2 timer). Docker Compose, virtuelle maskiner">
<META NAME="keywords" CONTENT="linux">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021">

<LINK REL="STYLESHEET" HREF="../../../os.css">

</HEAD>

<BODY >
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html615"
  HREF="node11.html#SECTION000111000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Docker Compose og docker-compose.yaml</A>
<LI><A ID="tex2html616"
  HREF="node11.html#SECTION000112000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Docker Compose hello-world</A>
<LI><A ID="tex2html617"
  HREF="node11.html#SECTION000113000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Docker Compose nginx</A>
<LI><A ID="tex2html618"
  HREF="node11.html#SECTION000114000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Tjenester med flere samtidige containere</A>
<LI><A ID="tex2html619"
  HREF="node11.html#SECTION000115000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> docker-compose build</A>
<LI><A ID="tex2html620"
  HREF="node11.html#SECTION000116000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Virtuelle maskiner</A>
<LI><A ID="tex2html621"
  HREF="node11.html#SECTION000117000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Forelesningsvideoer</A>
<LI><A ID="tex2html622"
  HREF="node11.html#SECTION000118000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> Virtualisering</A>
<LI><A ID="tex2html623"
  HREF="node11.html#SECTION000119000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">9</SPAN> Hvorfor virtualisering?</A>
<LI><A ID="tex2html624"
  HREF="node11.html#SECTION0001110000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">10</SPAN> Isolasjon</A>
<LI><A ID="tex2html625"
  HREF="node11.html#SECTION0001111000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">11</SPAN> Ressurssparing</A>
<LI><A ID="tex2html626"
  HREF="node11.html#SECTION0001112000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">12</SPAN> Fleksibilitet</A>
<LI><A ID="tex2html627"
  HREF="node11.html#SECTION0001113000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">13</SPAN> Skalering av ressurser</A>
<LI><A ID="tex2html628"
  HREF="node11.html#SECTION0001114000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">14</SPAN> Programvare-utvikling</A>
<LI><A ID="tex2html629"
  HREF="node11.html#SECTION0001115000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">15</SPAN> Skytjenester</A>
<LI><A ID="tex2html630"
  HREF="node11.html#SECTION0001116000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">16</SPAN> Historie</A>
<LI><A ID="tex2html631"
  HREF="node11.html#SECTION0001117000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">17</SPAN> Krav til virtualisering</A>
<LI><A ID="tex2html632"
  HREF="node11.html#SECTION0001118000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">18</SPAN> Hardware støttet virtualisering</A>
<LI><A ID="tex2html633"
  HREF="node11.html#SECTION0001119000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">19</SPAN> Type 1 hypervisor</A>
<LI><A ID="tex2html634"
  HREF="node11.html#SECTION0001120000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">20</SPAN> Type 2 hypervisor</A>
<LI><A ID="tex2html635"
  HREF="node11.html#SECTION0001121000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">21</SPAN> Binær oversettelse</A>
<LI><A ID="tex2html636"
  HREF="node11.html#SECTION0001122000000000000000"><SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">22</SPAN> Paravirtualisering</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION000110000000000000000">
<SPAN CLASS="arabic">10</SPAN> Forelesning 2/4-24(2 timer).   Docker Compose, virtuelle maskiner</A>
</H1>
Ingen videoer på forhånd om dette temaet, det vil bli gått igjennom på forelesningen på onsdag. Og det vil være noen tilhørende oppgvaer som vil være de siste obligatoriske 
oppgavene som skal med i oblig3 og dermed de siste obligatoriske oppgavene i kurset. 

<P>

<H2><A ID="SECTION000111000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Docker Compose og docker-compose.yaml</A>
</H2>
Vi har tidligere sett at det er en ryddigere og mer systematisk måte å bygge containere på ved å bruke en Dockerfile. Da kan man definere alt man ønsker skal være med når man starter containeren, som vilken programvare som skal være installert, hvilke filer som skal kopieres inn og så videre. Dette er et bedre alternativ enn å starte en container, installere det som trengs av programvare og innhold og så lagre denne containeren som et image og senere bruke denne. Da er det vanskligere å gjøre endringer, vanskligere å huske hva containeren egentlig inneholder og generelt vanskligere å gjenskape det samme imaget med noen endringer til å bruke i andre sammenhenger.

<P>
Docker compose med den tilhørende docker-compose.yaml filen er en metode som gjør noe av den samme forenklingen for å
kjøre containere som Dockerfile gjør for å bygge containere. Ofte trenger man å legge til mange flagg og opsjoner når man starter en container og dette kan gi lange og uoversiktlige docker container run-kommandoer. Man kan gjøre dette på en mye mer ryddig og systematisk måte ved å definere alt som skal skje når man starter en container i en docker-compose.yaml fil. Man kan i en slik fil også velge å starte flere samtidige containere som skal samarbeide om å gi den tjenesten man ønsker. For eksempel kan man med Docker compose samtidig starte både en webserver og en database-server som webserveren henter dataene sine fra. Generelt kan man bruke dette til å sette opp mange forskjellig typer oppsett av samtidige containere på en ryddig og 
oversiktlig måte. Dermed er det også enkelt å endre på konfigurasjonen og stoppe og starte hele clusteret av containere for å få alt til å virke som man ønsker.

<P>
YAML sto opprinnelig for "Yet Another Markup Language" og er som XML et maskinlesbart format som også er inspirert av Python i den forstand at riktig innrykk i teksten er viktig og det fører til feilmeldinger om dette ikke er riktig definert. Derfor må man være svært nøye med innrykk/antall mellomrom og også med å ha mellomrom på riktige steder. Dette gir noe av de samme syntaks-problemene som ved bash-scripting, derfor er det også her en god strategi å sakte bygge opp en docker-compose.yaml fil og teste hver gang man gjør endringer.

<P>

<H2><A ID="SECTION000112000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Docker Compose hello-world</A>
</H2>
Det gir kanskje ikke så mye mening å bruke Docker compose for å kjøre en hello-world container, 
men det kan være nyttig å teste ut for å gjøre seg kjent med konseptene. 
En docker-compose.yaml som starter en hello-world container kan se slik ut:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  hello:
    image: hello-world:latest
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Tidligere var det vanlig å starte med en linje av typen <code>version: '3.0'</code> som forteller hvilken Yaml-versjon som
skal brukes, men det er ikke lenger nødvendig. Filen viser alle services som skal være med. I dette er det kun en som vi gir navnet 'hello'. 
Deretter følger hvilket image som skal brukes. Dermed er man klar til å kjøre hello-world containeren med:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose up
[+] Running 1/1
 ✔ Container compose-hallo-1  Created
Attaching to hallo-1
hallo-1  | 
hallo-1  | Hello from Docker!
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Tidligere var kommandoen <code>docker-compose up</code> og hvis man prøver det får man nå en feilmelding.

<P>
Hvis man her ikke markerer at 'hello' er en av tjenestene og skriver filen slik:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  hello:
  image: hello-world:latest
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
får man med en gang en feilmelding:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose up
services.image must be a mapping
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>

<H2><A ID="SECTION000113000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Docker Compose nginx</A>
</H2>
Hvis man ønsker å starte en nginx-container kan man bruke følgende yaml-fil:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  nginx:
    image: nginx:latest
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
og starte tjenesten med

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose up -d
[+] Running 1/1
 ✔ Container compose-ng1-1  Started
root@os180:~/compose# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS	       PORTS     NAMES
14d123a939af   nginx:latest   &ldquo;/docker-entrypoint.…&rdquo; 8 seconds ago Up 7 seconds    80/tcp    compose-ng1-1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Hvis dette er første gang man laster ned nginx-imaget, vil det først lastes ned på samme måte som når 
man kjører <code>docker run nginx</code>. Deretter kan man stoppe det hele med:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose down
[+] Running 2/2
 ✔ Container compose-ng1-1  Removed
 ✔ Network compose_default  Removed
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Docker compose rydder opp etter seg ved å fjerne containeren som ble kjørt. 

<P>
Hvis man ønsker at port 80 som nginx default bruker som source port skal vises som port 8080 på host'en som kjører containeren, kan man gjøre det ved å definere følgende i yaml-filen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  nginx:
    image: nginx:latest
    ports:
      - 8080:80
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Generelt kan alle parametre og opsjoner man kan gi til  <code>docker container run</code> defineres i yaml-filen. Deretter kan man starte nginx:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose up -d
[+] Running 0/1
 ⠙ Network compose_default  Creating
[+] Running 2/2d 
✔ Network compose_default  Created
✔ Container compose-ng1-1  Started
root@os180:~/compose# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS          PORTS                  NAMES
6ba1338871fa   nginx:latest   &ldquo;/docker-entrypoint.…&rdquo; 34 seconds ago Up 33 seconds   0.0.0.0:8080-&gt;80/tcp   compose-ng1-1
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
og  man vil kunne få en hilsen fra nginx:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

# curl localhost:8080
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Videre kan man på en enkel måte definere en mappe på host'en som nginx skal hente sine web-sider fra ved å legge til følgende rett under ports: i yaml-filen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

      volumes:
        - ./innhold:/usr/share/nginx/html:ro
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dette gjør at man nå vil få opp innhold/index.html filen på host'en når man starter nginx.

<P>

<H2><A ID="SECTION000114000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Tjenester med flere samtidige containere</A>
</H2>
Det er først og fremst med tanke på å sette opp flere samtidige containere som jobber sammen om å tilby en gitt tjeneste at docker compose virkelig er 
et kraftig verktøy. Hvis man definerer flere services innen samme docker.compose.yaml fil, vil docker compose også sette opp et lokalt privat 
nettverk som containerene kan kommunisere på. Dermed kan man for eksempel sette opp et lite nettverk med en database og en web-server som 
kommuniserer med hverandre.

<P>
Følgende yaml-fil definerer to containere som leverer forskjellig innhold på henholdsvis port 8080 og 8081:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  nginx:
    image: nginx:latest
      ports:
        - 8080:80
      volumes:
        - ./innhold:/usr/share/nginx/html:ro
  nginx2:
    image: nginx:latest
      ports:
        - 8081:80
      volumes:
        - ./innhold2:/usr/share/nginx/html:ro
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dermed kan man starte begge containerene samtidig og se at de virker som de skal. Og stoppe begge etterpå.

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

root@os180:~/compose# docker compose up -d --remove-orphans
[+] Running 3/3
 ✔ Network compose_default  Created                   0.4s 
 ✔ Container compose-ng1-1  Started                   0.9s 
 ✔ Container compose-ng2-1  Started                   0.8s 
root@os180:~/compose# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED       STATUS       PORTS                NAMES
f0343357eb3a   nginx:latest   &ldquo;/docker-entrypoint.…&rdquo; 6 seconds ago Up 6 seconds 0.0.0.0:8081-&gt;80/tcp compose-ng2-1
cc1dfa99cf5c   nginx:latest   &ldquo;/docker-entrypoint.…&rdquo; 6 seconds ago Up 6 seconds 0.0.0.0:8080-&gt;80/tcp compose-ng1-1

root@os180:~/compose# curl localhost:8080
hei 
root@os180:~/compose# curl localhost:8081
hei fra 2
root@os180:~/compose# docker compose down
[+] Running 3/3
 ✔ Container compose-ng2-1  Removed                  0.8s 
 ✔ Container compose-ng1-1  Removed                  0.9s 
 ✔ Network compose_default  Removed
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Om man går inn i den ene nginx og installerer ping og ifconfig (med apt install iputils-ping net-tools)  
vil man kunne se at man kan kommunisere over det lokale private nettverket med den andre containeren ved å bruke navnet som er definert i yaml-filen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

# docker exec -it f2 bash
root@f2d45f6e9bf5:/# ping nginx2
PING nginx2 (192.168.32.3) 56(84) bytes of data.
64 bytes from test_nginx2_1.test_default (192.168.32.3): icmp_seq=1 ttl=64 time=0.137 ms
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
De to containerene har IPer 192.168.32.3 og 192.168.32.2 og kan kommunisere med hverandre som på andre nettverk. 
Dette gjør det mulig å sette opp relistiske systemer, ikke minst for å teste kode som man utvikler for dette service-scenariet. 

<P>
Hvis man for eksempel ønsker å gi containeren et eget navn, kan man bruke variabelen container_name. 

<P>

<H2><A ID="SECTION000115000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> docker-compose build</A>
</H2>
Man kan kombinere docker-compose med en eller flere Dockerfiles ved å spesifisere en mappe der den tilhørende Dockerfile ligger ved å angi 'build' istedet for image i yaml-filen:

<P>
<SPAN CLASS="SPAN"></SPAN><TABLE><TR><TD><PRE >

services:
  nginx:
    build: ./nginx
    ports:
      - 8080:80
</PRE></TD></TR></TABLE><SPAN CLASS="SPAN">
</SPAN>
<P>
Dermed vil docker-compose prøve å bygge et image fra Dockerfile i mappen ./nginx og starte en container med det image't som er resultatet av denne byggingen. 
Og man kan sette opp en oversiktlig mappestruktur som definerer alle containerene som er med i et compose-prosjekt. 

<P>

<H2><A ID="SECTION000116000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Virtuelle maskiner</A>
</H2>
<A ID="tex2html134"
  HREF="https://www.cs.oslomet.no/~haugerud/vm.pdf">Slides brukt i forelesningen</A>
<P>

<H2><A ID="SECTION000117000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Forelesningsvideoer</A>
</H2>

<P>
Opptak av forelesningen inndelt etter temaer:

<P>
<A ID="tex2html135"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del1.mp4">linux10del1.mp4</A>
(04:26) Grunnleggende om hva virtualisering er. Hardware, hypervisor og gjeste-OS

<BR><A ID="tex2html136"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del2.mp4">linux10del2.mp4</A>
(17:30) Hvorfor virtualisering? Isolasjon, Ressurssparing, Fleksibilitet, Programvare-utvikling, Skytjenester

<BR><A ID="tex2html137"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del3.mp4">linux10del3.mp4</A>
(07:39) Historie, Sensitive og priviligerte instruksjoner

<BR><A ID="tex2html138"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del4.mp4">linux10del4.mp4</A>
(03:09) Hardwarestøttet virtualisering, hypervisor i kernel mode, gjeste-OS i user mode

<BR><A ID="tex2html139"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del5.mp4">linux10del5.mp4</A>
(02:56) Poll med gjennomgang av svar på hva som IKKE er en av fordelene vet virtualisering: effiktivitet

<BR><A ID="tex2html140"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del6.mp4">linux10del6.mp4</A>
(04:20) Oppsummering av hardwarestøttet virtualisering

<BR><A ID="tex2html141"
  HREF="https://www.cs.oslomet.no/~haugerud/os/Forelesning/video/linux10del7.mp4">linux10del7.mp4</A>
(08:01) Type 1 &amp; Type 2 hypervisor, binær oversettelse, paravirtualisering

<BR>
<P>

<H2><A ID="SECTION000118000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> Virtualisering</A>
</H2>

<P>

<UL>
<LI>Virtualisering av server/desktop hardware
</LI>
<LI>En hypervisor simulerer hardware ved å gi samme grensesnitt som virkelig hardware gir
</LI>
<LI>Operativsystemene som kjører på en virtuell maskin, tror de kjører på ekte hardware
</LI>
</UL>

<P>

<DIV class="CENTER"><A ID="1207"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="540" HEIGHT="266" STYLE=""
 SRC="img17.png"
 ALT="\includegraphics[width=12cm]{fig/virt.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION000119000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">9</SPAN> Hvorfor virtualisering?</A>
</H2>

<P>

<UL>
<LI>Isolasjon
</LI>
<LI>Ressurssparing
</LI>
<LI>Fleksibilitet
</LI>
<LI>Programvare-utvikling
</LI>
<LI>Skytjenester
</LI>
</UL>

<P>
Alle disse fordelene gjelder også for containere og Docker, bortsett fra den første, isolasjon og sikkerhet. Men fleksibiliteten blir enda større med containere.

<P>

<H2><A ID="SECTION0001110000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">10</SPAN> Isolasjon</A>
</H2>

<P>

<UL>
<LI>Tjenester og programmer kan kjøre på hver sin dedikerte server
</LI>
<LI>Unngår at de forskjellige tjenestene ødelegger for hverandre og gir ryddigere drift
</LI>
<LI>Men hva om den fysiske serveren eller hypervisor feiler?
</LI>
<LI>Det meste av nedetid og feil skyldes ikke hardware men software. Og software for en hypervisor
  er generelt mindre kompleks enn all programvaren på en hel maskin
</LI>
<LI>Sikkerhet: hvis en tjeneste blir hacket, vil det ikke påvirke de andre tjenestene
</LI>
<LI>Dette er fordi Operativsystemet og applikasjonene kun kommuniserer mot det virtuelle hardware-API'et som hypervisor gir dem tilgang til. De har ingen mulighet til å kommunisere med andre deler av en hypervisor eller andre VMer.
</LI>
</UL>

<P>

<H2><A ID="SECTION0001111000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">11</SPAN> Ressurssparing</A>
</H2>

<P>

<UL>
<LI>Man kan oppnå isolasjon ved å ha en fysisk server for hver tjeneste, men det gir store driftskostnader
</LI>
<LI>Med virtualisering kan det samme oppnås på en enkelt server
</LI>
<LI>Virtuelle maskiner (VMer) som for eksempel bruker lite CPU kan settes på samme fysiske server
</LI>
<LI>VMer kan enkelt flyttes til og fra fysiske servere og man kan dermed spare hardware og strøm 
</LI>
<LI>Hage, Thomas: <EM>The CERES project - A Cloud Energy Reduction System</EM>, Veileder: Kyrre Begnum (Masteroppgave i Nettverk og Systemadministrasjon, oslomet/UiO)
</LI>
<LI><SPAN CLASS="SPAN"><code>https://www.cs.oslomet.no/teaching/materials/MS100A/html/NSA.html</code> </SPAN>
</LI>
</UL>

<P>

<H2><A ID="SECTION0001112000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">12</SPAN> Fleksibilitet</A>
</H2>

<P>

<UL>
<LI>Kapasiteten kan enkelt økes ved å legge til flere VMer, lastbalansering blir enklere
</LI>
<LI>Elastisitet: Man kan dynamisk tildele CPUer og internminne til VMer
</LI>
<LI>Har en VM blitt ødelagt eller kompromittert kan man enkelt starte opp en ny kopi
</LI>
<LI>Tradisjonelt er det arbeidskrevende å flytte en tjeneste eller et softwareprosjekt til en ny server på grunn av avhengighet av operativsystemet og annen programvare: når noe er utviklet på en VM så kan hele VMen flyttes eller kopieres
</LI>
<LI>Live migration: Hele VM flyttes til annen fysisk server uten nedetid på tjenestene
</LI>
<LI>Ung, Fredrik: <EM>Towards efficient and cost-effective live migrations of virtual machines</EM>, NSA masteroppgave
</LI>
<LI>Ahmad, Bilal: <EM>Coordinating vertical and horizontal scaling for achieving differentiated QoS</EM>, NSA masteroppgave, Veiledere: Anis Yazidi og Hårek Haugerud
</LI>
</UL>

<P>

<H2><A ID="SECTION0001113000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">13</SPAN> Skalering av ressurser</A>
</H2>

<P>

<DIV class="CENTER"><A ID="1229"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
  WIDTH="1080" HEIGHT="564" STYLE=""
 SRC="./vmbilal.png"
 ALT="Image vmbilal"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION0001114000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">14</SPAN> Programvare-utvikling</A>
</H2>

<P>

<UL>
<LI>Man kan raskt teste ut programvare på forskjellige operativsystemer, Window, Linux, Mac, etc. ved å kjøre VMer med en rekke forskjellige OS
</LI>
<LI>Det er enklere å automatisere tester på flere  plattformer (Test Driven Development)
</LI>
<LI>Ønsker man å teste ut nye ideer, kan man raskt sette opp miljøer for å teste dem ut
</LI>
</UL>

<P>

<H2><A ID="SECTION0001115000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">15</SPAN> Skytjenester</A>
</H2>

<P>

<UL>
<LI>Virtualisering er grunnlaget for fleksible skytjenester
</LI>
<LI>Kunder kan gis egne VMer med et  antall CPUer, disk og minne
</LI>
<LI>Disse kundene kan dele fysiske servere, noe som gir store besparelser av hardware
</LI>
<LI>Nettbokhandelen Amazon startet med skytjenester fordi de bare hadde bruk for store mengder hardware til webserverene sine før jul og tenkte at de kunne leie ut hardware-ressursene resten av året
</LI>
</UL>

<P>

<H2><A ID="SECTION0001116000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">16</SPAN> Historie</A>
</H2>

<P>

<UL>
<LI>IBM startet med virtualisering av stormaskiner på 1960-tallet
</LI>
<LI>En VMM (Virtual Machine Monitor) styrte flere virtuelle maskiner på samme fysiske maskin
</LI>
<LI>Første virtualiseringsløsning for x86: VMware i 1999
</LI>
<LI>Deretter fulgte Xen, VirtualBox, KVM og mange andre
</LI>
<LI>Hardware-støtte for x86 virtualisering kom først i 2005
</LI>
</UL>

<P>

<H2><A ID="SECTION0001117000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">17</SPAN> Krav til virtualisering</A>
</H2>

<P>

<UL>
<LI>Popek og Goldberg, 1974: En maskin kan bare virtualiseres hvis alle <B>sensitive instruksjonene</B> også er <B>priviligerte instruksjoner</B> 
</LI>
<LI>En <B>Sensitiv instruksjon</B> kan bare utføres i kernel mode
</LI>
<LI>En <B>Priviligert instruksjon</B> forårsaker en trap til kernel mode hvis den gjøres i user mode
</LI>
</UL>

<P>
Eksempel: 

<UL>
<LI>X86 instruksjonen POPF (skrur av og på interrupts) er en sensitiv instruksjon
</LI>
<LI>Hvis den utføres i user mode vil ingenting skje, som for NOP (No Operation)
</LI>
<LI>Instruksjonen CLI (CLear Interupt flag) er en sensitiv instruksjon, men den er også priviligert. Hvis den utføres i user mode, gjøres en trap til kernel mode
</LI>
<LI>Vanlige instruksjoner som ADD, CMP og MOV er hverken sensitive eller priviligerte.
</LI>
</UL>

<P>

<H2><A ID="SECTION0001118000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">18</SPAN> Hardware støttet virtualisering</A>
</H2>

<P>

<UL>
<LI>Hardware-støtte for x86 virtualisering kom først i 2005
</LI>
<LI>Inntil da fantes det sensitive instruksjoner (som POPF) som bare ble droppet
</LI>
<LI>Gjeste-OS kjører i user mode og vil ikke fungere som på vanlig hardware om en slik instruksjon droppes. Det vil føre til uforutsigbar oppførsel og kan føre til at OS crasher i verste fall.
</LI>
<LI>Med Intel VT-x og AMD-V vil alle sensitive instruksjoner trap'e til kernel mode når de utføres i user mode
</LI>
</UL>

<P>

<DIV class="CENTER"><A ID="1256"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Hardware støttet virtualisering.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="538" HEIGHT="202" STYLE=""
 SRC="img18.png"
 ALT="\includegraphics[width=12cm]{fig/vmtrap.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION0001119000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">19</SPAN> Type 1 hypervisor</A>
</H2>

<P>

<UL>
<LI>En type 1 hypervisor kjører direkte på hardware som et OS
</LI>
<LI>Alle sensitive instuksjoner som utføres i user mode av gjeste-OS må trap'e til kernel mode og fanges opp av hypervisor
</LI>
<LI>Eksempler: VMware ESX og vSphere, Xen, Hyper-V(Microsoft)
</LI>
</UL>

<P>

<DIV class="CENTER"><A ID="1265"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Type 1 Hypervisor.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="540" HEIGHT="266" STYLE=""
 SRC="img19.png"
 ALT="\includegraphics[width=12cm]{fig/vmtype1.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION0001120000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">20</SPAN> Type 2 hypervisor</A>
</H2>

<P>

<UL>
<LI>En type 2 hypervisor kjører oppå et eksisternede OS
</LI>
<LI>Deler av hypervisor kan inngå i det underliggende OS'et i form av kjernemoduler
</LI>
<LI>Det kan være litt flytende grenser mellom type 1 og type 2
</LI>
<LI>KVM/Qemu(Linux), VirtualBox, VMware Fusion (Mac)
</LI>
</UL>

<P>

<DIV class="CENTER"><A ID="1274"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
<SPAN CLASS="FOOTNOTESIZE">Type 2 hypervisor.</SPAN></CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG
 WIDTH="540" HEIGHT="338" STYLE=""
 SRC="img20.png"
 ALT="\includegraphics[width=12cm]{fig/vmtype2.eps}"> 

</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION0001121000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">21</SPAN> Binær oversettelse</A>
</H2>

<P>

<UL>
<LI>Før 2005 måtte alternative metoder brukes, uten hardware-støtte
</LI>
<LI>VMware lagde en hypervisor som mens et program kjører scanner koden etter sensitive instruksjoner
</LI>
<LI>Dette gjøres for hver kodeblokk som ender i jump, call, trap eller lignende
</LI>
<LI>Sensitive instruksjoner oversettes til kall til VMware-prosedyrer i hypervisor
</LI>
<LI>De oversatte kodeblokkene cashes og dette gjør kjøringen effektiv
</LI>
<LI>Hardware med VT-støtte genererer mange traps og dette tar lang tid
</LI>
<LI>Noe binær oversettelse finnes også i VirtualBox
</LI>
</UL>

<P>

<H2><A ID="SECTION0001122000000000000000">
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">22</SPAN> Paravirtualisering</A>
</H2>

<P>

<UL>
<LI>Paravirtualisering krever at Gjeste-OS endres
</LI>
<LI>Alle sensitive instruksjoner erstattes med kall til hypervisor
</LI>
<LI>Gjeste-OS kan optimaliseres for virtualisering
</LI>
<LI>Ved å installere drivere laget for paravirtualisering, kan denne metoden bli meget effektiv 
</LI>
</UL>

<P>
<BR><HR>
<ADDRESS>
H&aring;rek Haugerud 2025-03-27
</ADDRESS>
</BODY>
</HTML>
