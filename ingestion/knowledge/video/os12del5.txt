{'text': ' Kritisk avsnitt er det avsnittet i koden som er helt avgjørende når det gjelder synkronisering. Og det er da typisk når man aksesserer en felles variabel. Vi har sett på en problemstilling hvor vi har en felles variabel saldo. Hvor vi hadde en felles variabel saldo som én prosess... Økte med 1 mill. og en annen prosess, P1, minket med 1 mill. Og så så vi da på hvordan dette kunne gjøre at saldoen... At det forsvant 1 mill. Og det er jo opplagt uheldig. Og akkurat den kodebiten hvor den millen forsvinner, det er når saldoen oppdateres. Og dette kalles kritisk avsnitt. Som er helt avgjørende, er at en prosess som er inni et kritisk avsnitt, den må kunne fullføre det helt alene, uten at da noen andre endrer på saldoen. Så serialiseringen, den må da sørge for at det kritiske avsnittet, det gjøres bare av én prosess av gangen. Og vi begynte å se på metoder som kan gjøre dette her, så vi hadde en lokkinstitusjon. Og den hindret da at andre prosesser endret på saldoen. Det gjorde vi med Petrads. Og det som også var avgjørende da, var at vi låste minnebussen. Altså bussen ut til RAM. For det er det som er avgjørende når du har tråder som kjører på forskjellige CPU-er. Så er det ikke så lett å koordinere dem, for da opererer de totalt samtidig og helt uavhengig av hverandre. Hvis begge kjører på samme CPU, så har du tross alt en context switch, sånn at da går det an å koordinere i litt større grad. Selv om det kan bli trøbbel, det òg. Men når du er på forskjellige CPU-er, så må minnebussen låses for at ikke to prosesser skal da... Samtidig hente ut en kode, eller samtidig endre. Det vil si at ikke begge skal hente ut den nåværende verdien, og så skrive tilbake uten å koordinere med den andre. Det er da problemene skjer. Men hvis vi kjører selv, hvis vi kjører på samme CPU, så har vi sett at én institusjon sånn som dette her... Den fører faktisk til minst to instruksjoner på maskinnivå. På assembly-nivå. Og det er det operativsystemet ser. Så når operativsystemet skedulerer to prosesser sånn som dette, selv på samme CPU, så kan det da komme en context switch midt inne i denne oppdateringen. Og da kan det som prosess 2... Utfører av institusjoner. Det kan da bli ødelagt av den andre fordi de ikke koordinerer. Og fordi det kan komme context-switch midt inn i kritisk avsnitt. For da blir kritisk avsnitt større enn én linje. Hvis kritisk avsnitt faktisk bare er én maskininstitusjon, så vil vi ikke få det problemet med context-switching på samme SPU. Men problemet kan likevel oppstå når vi har flere SPU. Nå skal jeg se på noen metoder for å behandle kritiske avsnitt. Og målet med disse metodene er at vi skal sikre oss at bare én prosess av gangen, eller én tråd av gangen, utfører sitt kritiske avsnitt før en annen prosess gjør det. I prinsippet så kan det være ti tråder som samtidig ønsker å gå inn i... Men det avgjørende her er bare én av gangene. En veldig direkte måte å sørge dette for, det er å skru av interrupts. For hvis man da skrur av interrupts, så er du sikker på at... Da er du sikker på at det ikke kommer noe context switch. Så kan det være trøbbel med andre CPU-er. Men hvis vi er på samme CPU, så kan vi sikre et kritisk avsnitt ved først å disable interrupts, så utføre det kritiske avsnittet, og så enable interrupts etterpå. For da er vi... Selv om dette kritiske avsnittet da består av flere maskininstitusjoner, så er man likevel sikker på at ingen... Det kan ikke skje noe kontekstuelt. For interrupt er skrudd av. Det skjedde ved at det kommer en timer-interrupt. Så om man ikke behandler timer-interrupten med en gang, men venter til koden er ferdig, så vil det ikke kunne skje... Da vil ingen kunne avbryte knyttet til avsnittet. Dette er OK for en OUS-kjerne. Det er kode i OUS-kjernen som skrur av interrupts. Være helt sikker på å fullføre et kritisk gassnitt. Men det ville vært veldig kritisk hvis brukerprosesser kunne gjøre dette her, for da kunne de straks ta over styringen. Så dette er OK for en O-stjerne, men generelt så kan man ikke gi en slik metode til en vanlig brukerprosess. Det er å lage en slags lås. Det er litt sånn som den lock-instruksjonen som vi har sett på. Man lager en lås sånn at bare én prosess av gangen har tilgang til fellesdata. Generelt så kalles en slik lås mutix. Det står da for mutual exclusion. På norsk betyr det gjensidig utelukkelse. man... Sørge for å utelukke hverandre. Og dette er den mest brukte metoden generelt. Og det fins mange implementasjoner av det. Og vi skal se noen eksempler på implementasjoner. Men det som er viktig her, er at man må da utelukke alle andre. Ja, en mutex... Den lockwill-funksjonen vi hadde, den gjelder bare for én institusjon. Men en mutex generelt, det er på en måte en nøkkel som man tar tak i. Og så lenge man beholder den nøkkelen, så er man inne i kritiske avsnitt, og da kan ingen andre komme inn i kritiske avsnitt og gjøre noe. Så det kan vare lenger enn en enkelt institusjon, og dermed så kan det Den kan også brukes til å serialisere kode, som har mer enn én institusjon i Kritisk avsnitt.', 'chunks': [{'timestamp': (0.0, 6.8), 'text': ' Kritisk avsnitt er det avsnittet i koden'}, {'timestamp': (6.8, 10.6), 'text': ' som er helt avgjørende når det gjelder synkronisering.'}, {'timestamp': (10.6, 15.8), 'text': ' Og det er da typisk når man aksesserer en felles variabel.'}, {'timestamp': (16.0, 23.72), 'text': ' Vi har sett på en problemstilling hvor vi har en felles variabel saldo.'}, {'timestamp': (23.72, 29.0), 'text': ' Hvor vi hadde en felles variabel saldo som én prosess...'}, {'timestamp': (30.0, 35.18), 'text': ' Økte med 1 mill. og en annen prosess, P1, minket med 1 mill.'}, {'timestamp': (35.18, 42.12), 'text': ' Og så så vi da på hvordan dette kunne gjøre at saldoen...'}, {'timestamp': (42.24, 48.68), 'text': ' At det forsvant 1 mill. Og det er jo opplagt uheldig.'}, {'timestamp': (49.54, 53.68), 'text': ' Og akkurat den kodebiten hvor den millen forsvinner,'}, {'timestamp': (53.8, 58.76), 'text': ' det er når saldoen oppdateres. Og dette kalles kritisk avsnitt.'}, {'timestamp': (60.0, 65.68), 'text': ' Som er helt avgjørende, er at en prosess som er inni et kritisk avsnitt,'}, {'timestamp': (65.76, 69.88), 'text': ' den må kunne fullføre det helt alene,'}, {'timestamp': (69.88, 74.0), 'text': ' uten at da noen andre endrer på saldoen.'}, {'timestamp': (74.0, 80.12), 'text': ' Så serialiseringen, den må da sørge for at det kritiske avsnittet,'}, {'timestamp': (80.2, 84.12), 'text': ' det gjøres bare av én prosess av gangen.'}, {'timestamp': (84.12, 89.92), 'text': ' Og vi begynte å se på metoder som kan gjøre dette her, så vi hadde en lokkinstitusjon.'}, {'timestamp': (90.0, 100.66), 'text': ' Og den hindret da at andre prosesser endret på saldoen.'}, {'timestamp': (100.66, 104.66), 'text': ' Det gjorde vi med Petrads.'}, {'timestamp': (104.68, 112.44), 'text': ' Og det som også var avgjørende da, var at vi låste minnebussen.'}, {'timestamp': (113.12, 114.8), 'text': ' Altså bussen ut til RAM.'}, {'timestamp': (114.88, 119.96), 'text': ' For det er det som er avgjørende når du har tråder som kjører på forskjellige CPU-er.'}, {'timestamp': (120.0, 122.4), 'text': ' Så er det ikke så lett å koordinere dem,'}, {'timestamp': (122.48, 128.68), 'text': ' for da opererer de totalt samtidig og helt uavhengig av hverandre.'}, {'timestamp': (128.76, 133.36), 'text': ' Hvis begge kjører på samme CPU, så har du tross alt en context switch,'}, {'timestamp': (133.44, 136.48), 'text': ' sånn at da går det an å koordinere i litt større grad.'}, {'timestamp': (136.48, 140.92), 'text': ' Selv om det kan bli trøbbel, det òg.'}, {'timestamp': (140.96, 147.44), 'text': ' Men når du er på forskjellige CPU-er, så må minnebussen låses'}, {'timestamp': (147.52, 149.96), 'text': ' for at ikke to prosesser skal da...'}, {'timestamp': (150.0, 153.72), 'text': ' Samtidig hente ut en kode, eller samtidig endre.'}, {'timestamp': (153.72, 159.14), 'text': ' Det vil si at ikke begge skal hente ut den nåværende verdien,'}, {'timestamp': (159.16, 163.28), 'text': ' og så skrive tilbake uten å koordinere med den andre.'}, {'timestamp': (163.28, 167.6), 'text': ' Det er da problemene skjer.'}, {'timestamp': (167.66, 171.32), 'text': ' Men hvis vi kjører selv, hvis vi kjører på samme CPU,'}, {'timestamp': (171.4, 177.16), 'text': ' så har vi sett at én institusjon sånn som dette her...'}, {'timestamp': (180.0, 187.24), 'text': ' Den fører faktisk til minst to instruksjoner på maskinnivå.'}, {'timestamp': (187.32, 191.48), 'text': ' På assembly-nivå. Og det er det operativsystemet ser.'}, {'timestamp': (191.56, 196.28), 'text': ' Så når operativsystemet skedulerer to prosesser sånn som dette,'}, {'timestamp': (196.36, 202.48), 'text': ' selv på samme CPU, så kan det da komme en context switch'}, {'timestamp': (202.56, 209.0), 'text': ' midt inne i denne oppdateringen. Og da kan det som prosess 2...'}, {'timestamp': (210.0, 214.8), 'text': ' Utfører av institusjoner. Det kan da bli ødelagt av den andre'}, {'timestamp': (214.88, 217.16), 'text': ' fordi de ikke koordinerer.'}, {'timestamp': (217.24, 222.48), 'text': ' Og fordi det kan komme context-switch midt inn i kritisk avsnitt.'}, {'timestamp': (222.48, 224.64), 'text': ' For da blir kritisk avsnitt større enn én linje.'}, {'timestamp': (224.72, 227.68), 'text': ' Hvis kritisk avsnitt faktisk bare er én maskininstitusjon,'}, {'timestamp': (227.68, 233.32), 'text': ' så vil vi ikke få det problemet med context-switching på samme SPU.'}, {'timestamp': (233.4, 238.6), 'text': ' Men problemet kan likevel oppstå når vi har flere SPU.'}, {'timestamp': (240.0, 246.58), 'text': ' Nå skal jeg se på noen metoder'}, {'timestamp': (246.66, 252.44), 'text': ' for å behandle kritiske avsnitt.'}, {'timestamp': (252.44, 258.08), 'text': ' Og målet med disse metodene er at vi skal sikre oss'}, {'timestamp': (258.16, 261.32), 'text': ' at bare én prosess av gangen, eller én tråd av gangen,'}, {'timestamp': (261.32, 265.48), 'text': ' utfører sitt kritiske avsnitt før en annen prosess gjør det.'}, {'timestamp': (265.48, 269.94), 'text': ' I prinsippet så kan det være ti tråder som samtidig ønsker å gå inn i...'}, {'timestamp': (270.0, 274.6), 'text': ' Men det avgjørende her er bare én av gangene.'}, {'timestamp': (274.6, 281.52), 'text': ' En veldig direkte måte å sørge dette for,'}, {'timestamp': (281.6, 285.4), 'text': ' det er å skru av interrupts.'}, {'timestamp': (285.4, 292.2), 'text': ' For hvis man da skrur av interrupts, så er du sikker på at...'}, {'timestamp': (293.0, 298.04), 'text': ' Da er du sikker på at det ikke kommer noe context switch.'}, {'timestamp': (300.0, 305.56), 'text': ' Så kan det være trøbbel med andre CPU-er.'}, {'timestamp': (305.64, 310.16), 'text': ' Men hvis vi er på samme CPU, så kan vi sikre et kritisk avsnitt'}, {'timestamp': (310.24, 315.76), 'text': ' ved først å disable interrupts, så utføre det kritiske avsnittet,'}, {'timestamp': (316.22, 318.02), 'text': ' og så enable interrupts etterpå.'}, {'timestamp': (318.02, 325.52), 'text': ' For da er vi... Selv om dette kritiske avsnittet da består av flere maskininstitusjoner,'}, {'timestamp': (325.6, 329.76), 'text': ' så er man likevel sikker på at ingen... Det kan ikke skje noe kontekstuelt.'}, {'timestamp': (330.0, 332.92), 'text': ' For interrupt er skrudd av.'}, {'timestamp': (333.0, 339.4), 'text': ' Det skjedde ved at det kommer en timer-interrupt.'}, {'timestamp': (339.48, 342.2), 'text': ' Så om man ikke behandler timer-interrupten med en gang,'}, {'timestamp': (342.2, 347.68), 'text': ' men venter til koden er ferdig, så vil det ikke kunne skje...'}, {'timestamp': (347.68, 352.12), 'text': ' Da vil ingen kunne avbryte knyttet til avsnittet.'}, {'timestamp': (352.12, 359.0), 'text': ' Dette er OK for en OUS-kjerne. Det er kode i OUS-kjernen som skrur av interrupts.'}, {'timestamp': (360.0, 363.42), 'text': ' Være helt sikker på å fullføre et kritisk gassnitt.'}, {'timestamp': (363.42, 369.3), 'text': ' Men det ville vært veldig kritisk hvis brukerprosesser kunne gjøre dette her,'}, {'timestamp': (369.38, 373.14), 'text': ' for da kunne de straks ta over styringen.'}, {'timestamp': (374.1, 376.78), 'text': ' Så dette er OK for en O-stjerne,'}, {'timestamp': (376.86, 384.14), 'text': ' men generelt så kan man ikke gi en slik metode til en vanlig brukerprosess.'}, {'timestamp': (390.0, 394.16), 'text': ' Det er å lage en slags lås.'}, {'timestamp': (394.16, 398.72), 'text': ' Det er litt sånn som den lock-instruksjonen som vi har sett på.'}, {'timestamp': (398.72, 405.08), 'text': ' Man lager en lås sånn at bare én prosess av gangen har tilgang til fellesdata.'}, {'timestamp': (405.1, 410.92), 'text': ' Generelt så kalles en slik lås mutix.'}, {'timestamp': (410.92, 415.36), 'text': ' Det står da for mutual exclusion.'}, {'timestamp': (415.36, 419.96), 'text': ' På norsk betyr det gjensidig utelukkelse. man...'}, {'timestamp': (420.0, 424.08), 'text': ' Sørge for å utelukke hverandre.'}, {'timestamp': (424.08, 428.4), 'text': ' Og dette er den mest brukte metoden generelt.'}, {'timestamp': (428.4, 432.08), 'text': ' Og det fins mange implementasjoner av det.'}, {'timestamp': (432.16, 437.2), 'text': ' Og vi skal se noen eksempler på implementasjoner.'}, {'timestamp': (437.2, 446.24), 'text': ' Men det som er viktig her, er at man må da utelukke alle andre.'}, {'timestamp': (450.0, 457.8), 'text': ' Ja, en mutex... Den lockwill-funksjonen vi hadde,'}, {'timestamp': (457.88, 460.88), 'text': ' den gjelder bare for én institusjon.'}, {'timestamp': (460.96, 466.32), 'text': ' Men en mutex generelt, det er på en måte en nøkkel som man tar tak i.'}, {'timestamp': (466.4, 471.2), 'text': ' Og så lenge man beholder den nøkkelen, så er man inne i kritiske avsnitt,'}, {'timestamp': (471.28, 475.68), 'text': ' og da kan ingen andre komme inn i kritiske avsnitt og gjøre noe.'}, {'timestamp': (475.76, 479.96), 'text': ' Så det kan vare lenger enn en enkelt institusjon, og dermed så kan det'}, {'timestamp': (480.02, 486.26), 'text': ' Den kan også brukes til å serialisere kode, som har mer enn én institusjon i Kritisk avsnitt.'}]}