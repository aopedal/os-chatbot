{'text': " Ja... Vi har allerede sett på Lock på X86-institusjonen Lock. Og som vi skal se senere, så trenger man... For å lage en effektiv løsning, så trenger man hjelp fra hardware. Men det går også an å lage software-løsninger som, selv om de kjører på... Selv om det kan komme en kontekst-witch som sørger for en Mutex. Hvis vi ønsker en software-løsning, da ønsker vi oss gjerne å ha to funksjoner eller metoder sånn som dette... GetMutex og releaseMutex. Og getMutex... Den metoden ønsker vi skal hente en lokk. Og så sier vi denne nøkkelen. Ingen andre må ta den. Ingen andre kan ta den. Så da kan jeg utføre mitt Kritiske avsnitt. Og så, etterpå, så kan jeg gi fra meg nøkkelen. Og dette virker jo enkelt og greit. Så da burde man egentlig ha løst hele problemet. Men vi skal se at det er ikke så enkelt som man skulle tro. Så dette er første forsøk på å lage en software music. De andre forsøkene er det oppgaver om denne uken. Så se på de oppgavene senere. Men vi skal se på dette første forsøket, som er liksom det... Enkleste man kan få til, og som tilsvarer det å lage... Vi kan lage en mail-lok. Vi hadde et eksempel hvor vi lagde en fil. Og så sjekker alle andre prosesser om den filen finnes. Dette er egentlig det tilsvarende, men vi får det samme problemet. Så vi tenker oss at vi har en static boolin-lok. Det er da en felles variabel som er true eller false. Og den er static i betydning... Av at to eller flere prosesser kan aksessere den. Så nå skal vi som programmerere ha kode som sikrer denne lokken. Og da kan vi gjøre det på denne måten her. Vi kan si... Getmutex-lokk. Den kan være sånn at... Dette er en litt spesiell konstruksjon, men den funker i Java, f.eks. Og det er vile lock, og så kommer det bare to parenteser. Og de to parentesene, de er... De gjør ingenting. Det er faktisk en maskininstitusjon som gjør ingenting. Og den heter NOP, No Operation. Så vile lock, og så ingenting. Det den gjør, det er at den bare tester om og om igjen. Om lock er true. Ja. Den tester om og om igjen om lock er true eller false. Og hvis lock er true, så går den inn i løkka og gjør ingenting. Og det den da gjør, er at den hele tiden sjekker om lock er true. Så den står her og gang på gang tester om er lock true, er lock true. Hele tiden, hvis lokket er truet, så står den og venter. Og da er det klart... Der vil den stå evig. Med mindre det er andre prosesser som aksesserer denne lokken og setter den til Folds. Så hvis ingen andre har satt denne til Folds før, så vil den første prosessen som gjør GetMuteX, den vil gå inn... Lokket er Folds, så da hopper den over denne her. Og da er det trygt, for da kan den gå inn i sitt kritisk avsnitt. For den har nå gått inn, satt locklig true... Akkurat som å skru på en lås. Det er som om man går inn på et toalett og vrir på låsen, for da er det et signal til alle andre. Da er det rødt. Ingen kan komme inn her. Så da er det safe. Så hvis en annen prosess kommer inn og også prøver å gjøre get mutex før det kritiske avsnittet, så vil den komme inn og så se... Oi, lokk er på. OK, da må jeg stå her og vente. Og den står da og venter helt til den første prosessen som kom inn, har gjort released mutex. For hvis vi husker det man... Først gjør man get mutex, henter låsen, så kritisk avsnitt, og så release mutex. Så når da... Prosess nummer to. Er ferdig med sett kritiske avsnitt, så vil den release mye av teksten, og det gjør den ved å sette locklick-fots. Og da vil de som måtte stå her og vente i en løkke, de vil da komme inn i kritiske avsnitt, og så vil de sette locklick, tror jeg. Så dette ser ut som det perfekte opplegg. Men her er det et problem. Jeg har stilt et spørsmål her. Dette burde sikre at to prosesser ikke er i kritisk asyl samtidig. Men vi kan få et problem her, og det er hvis... Hva skjer hvis det kommer en context switch? Vi tenker at disse kjører på samme CPU. Hva om det kommer en kontekst-witch rett etter at denne prosessen har testet om... Om lock er false. Hvis vi antar at lock er false... Og så vil det jo... En sånn veiløkke... En sånn test består av flere deler. Første del må hente inn verdien og legge et register. Truly Falls-register er typisk 0 eller 1. Og så må den, etter at den har hentet den inn, gjøre en compare. Sammenligne den verdien med 0, f.eks. Og så må den etter den compare hoppe, avhengig av verdien. Men det der utføres i minst to institusjoner. Så hva skjer om det kommer en context switch nøyaktig etter at den har hentet inn verdien, og sett at den er falsk? Jo, da fryser selv den prosessen. Det neste den vil gjøre, er å sette lock-click-through og gå inn i kreditskapsnitt. Men når den første prosessen som kommer inn, fryser, Da er jo lock fortsatt false. Så den prosess nummer to... Den vil enkelt og greit bare hoppe over den løkka. Lock er false. Og så vil den sette locklik, tror jeg. Men da er det for sent. For da er P1 allerede inne i kritiske avsnitt. Og så kommer P2 etter, og den går også inn i kritiske avsnitt. Og da er vi tilbake i de gamle problemene. Så kan begge to kjøre kritiske avsnitt samtidig. Så derfor så fungerer rett og slett ikke denne software-løsningen. Den vil fungere stort sett, bortsett fra hvis det kommer et kritisk avsnitt nøyaktig etter wild lock. Nøyaktig etter at verdien er hentet inn til registrene, men rett før den hopper på grunnlag av denne verdien. Er ikke denne god nok? Og i øvingsoppgavene så kommer det et par andre nye forsøk som er litt bedre. Og til slutt så kommer man fram til Peterson-algoritmen, som kom en gang på 80-tallet, som er en perfekt software-mytex-løsning. Men den er litt tungvint, og du trenger litt kode. Men den kan. Det kan man bruke. Men i praksis, sånn som med operativstemme og sånn som med Java-tråder osv., så bruker man metoder hvor man får hjelp fra Harvay. Og det sikrer i tillegg at man lokker databussen. Så de metodene er da enda bedre. I de softwareløsningene som vi har sett på, de krever litt kode. Og i tillegg så bruker de alle sammen bussy waiting. Bussy waiting er dette her med at man står og venter. Og da bruker man CPU-en. Man gjør NOP-institusjoner om og om igjen. Og det er en litt effektiv måte å vente på. Det kalles da generelt 'bussy waiting'.", 'chunks': [{'timestamp': (0.0, 11.6), 'text': ' Ja... Vi har allerede sett på Lock på X86-institusjonen Lock.'}, {'timestamp': (12.24, 16.92), 'text': ' Og som vi skal se senere, så trenger man...'}, {'timestamp': (16.92, 22.36), 'text': ' For å lage en effektiv løsning, så trenger man hjelp fra hardware.'}, {'timestamp': (22.36, 28.44), 'text': ' Men det går også an å lage software-løsninger som, selv om de kjører på...'}, {'timestamp': (30.0, 36.6), 'text': ' Selv om det kan komme en kontekst-witch som sørger for en Mutex.'}, {'timestamp': (36.68, 40.08), 'text': ' Hvis vi ønsker en software-løsning,'}, {'timestamp': (40.2, 47.68), 'text': ' da ønsker vi oss gjerne å ha to funksjoner eller metoder sånn som dette...'}, {'timestamp': (47.8, 50.04), 'text': ' GetMutex og releaseMutex.'}, {'timestamp': (50.04, 58.44), 'text': ' Og getMutex... Den metoden ønsker vi skal hente en lokk.'}, {'timestamp': (60.0, 66.12), 'text': ' Og så sier vi denne nøkkelen. Ingen andre må ta den.'}, {'timestamp': (66.66, 71.56), 'text': ' Ingen andre kan ta den. Så da kan jeg utføre mitt Kritiske avsnitt.'}, {'timestamp': (71.56, 75.64), 'text': ' Og så, etterpå, så kan jeg gi fra meg nøkkelen.'}, {'timestamp': (75.64, 80.16), 'text': ' Og dette virker jo enkelt og greit.'}, {'timestamp': (80.24, 84.34), 'text': ' Så da burde man egentlig ha løst hele problemet.'}, {'timestamp': (84.34, 89.8), 'text': ' Men vi skal se at det er ikke så enkelt som man skulle tro.'}, {'timestamp': (90.0, 98.18), 'text': ' Så dette er første forsøk på å lage en software music.'}, {'timestamp': (98.2, 102.92), 'text': ' De andre forsøkene er det oppgaver om denne uken.'}, {'timestamp': (104.22, 108.28), 'text': ' Så se på de oppgavene senere.'}, {'timestamp': (108.28, 114.6), 'text': ' Men vi skal se på dette første forsøket, som er liksom det...'}, {'timestamp': (114.6, 119.8), 'text': ' Enkleste man kan få til, og som tilsvarer det å lage...'}, {'timestamp': (120.0, 127.54), 'text': ' Vi kan lage en mail-lok. Vi hadde et eksempel hvor vi lagde en fil.'}, {'timestamp': (127.56, 131.44), 'text': ' Og så sjekker alle andre prosesser om den filen finnes.'}, {'timestamp': (131.46, 135.98), 'text': ' Dette er egentlig det tilsvarende, men vi får det samme problemet.'}, {'timestamp': (135.98, 142.06), 'text': ' Så vi tenker oss at vi har en static boolin-lok.'}, {'timestamp': (142.68, 149.8), 'text': ' Det er da en felles variabel som er true eller false. Og den er static i betydning...'}, {'timestamp': (150.0, 157.04), 'text': ' Av at to eller flere prosesser kan aksessere den.'}, {'timestamp': (159.14, 165.64), 'text': ' Så nå skal vi som programmerere ha kode som sikrer denne lokken.'}, {'timestamp': (165.72, 169.2), 'text': ' Og da kan vi gjøre det på denne måten her.'}, {'timestamp': (169.2, 173.32), 'text': ' Vi kan si... Getmutex-lokk. Den kan være sånn at...'}, {'timestamp': (173.32, 179.94), 'text': ' Dette er en litt spesiell konstruksjon, men den funker i Java, f.eks.'}, {'timestamp': (180.0, 186.84), 'text': ' Og det er vile lock, og så kommer det bare to parenteser.'}, {'timestamp': (186.84, 192.12), 'text': ' Og de to parentesene, de er... De gjør ingenting.'}, {'timestamp': (192.12, 197.2), 'text': ' Det er faktisk en maskininstitusjon som gjør ingenting.'}, {'timestamp': (197.28, 201.08), 'text': ' Og den heter NOP, No Operation.'}, {'timestamp': (201.1, 204.0), 'text': ' Så vile lock, og så ingenting.'}, {'timestamp': (204.08, 208.48), 'text': ' Det den gjør, det er at den bare tester om og om igjen.'}, {'timestamp': (210.0, 214.12), 'text': ' Om lock er true.'}, {'timestamp': (217.72, 222.56), 'text': ' Ja. Den tester om og om igjen om lock er true eller false.'}, {'timestamp': (222.58, 229.84), 'text': ' Og hvis lock er true, så går den inn i løkka og gjør ingenting.'}, {'timestamp': (229.84, 235.2), 'text': ' Og det den da gjør, er at den hele tiden sjekker om lock er true.'}, {'timestamp': (235.2, 239.76), 'text': ' Så den står her og gang på gang tester om er lock true, er lock true.'}, {'timestamp': (240.0, 246.7), 'text': ' Hele tiden, hvis lokket er truet, så står den og venter.'}, {'timestamp': (246.7, 251.34), 'text': ' Og da er det klart... Der vil den stå evig.'}, {'timestamp': (251.42, 256.26), 'text': ' Med mindre det er andre prosesser som aksesserer denne lokken'}, {'timestamp': (256.38, 258.1), 'text': ' og setter den til Folds.'}, {'timestamp': (258.12, 261.92), 'text': ' Så hvis ingen andre har satt denne til Folds før,'}, {'timestamp': (262.0, 266.28), 'text': ' så vil den første prosessen som gjør GetMuteX, den vil gå inn...'}, {'timestamp': (266.36, 269.72), 'text': ' Lokket er Folds, så da hopper den over denne her.'}, {'timestamp': (270.0, 275.38), 'text': ' Og da er det trygt, for da kan den gå inn i sitt kritisk avsnitt.'}, {'timestamp': (275.4, 280.16), 'text': ' For den har nå gått inn, satt locklig true...'}, {'timestamp': (280.16, 284.36), 'text': ' Akkurat som å skru på en lås.'}, {'timestamp': (284.36, 291.64), 'text': ' Det er som om man går inn på et toalett og vrir på låsen,'}, {'timestamp': (291.72, 295.88), 'text': ' for da er det et signal til alle andre. Da er det rødt.'}, {'timestamp': (295.88, 299.8), 'text': ' Ingen kan komme inn her. Så da er det safe.'}, {'timestamp': (300.0, 305.3), 'text': ' Så hvis en annen prosess kommer inn og også prøver å gjøre'}, {'timestamp': (305.32, 310.6), 'text': ' get mutex før det kritiske avsnittet, så vil den komme inn og så se...'}, {'timestamp': (311.56, 315.76), 'text': ' Oi, lokk er på. OK, da må jeg stå her og vente. Og den står da og venter'}, {'timestamp': (315.76, 320.7), 'text': ' helt til den første prosessen som kom inn, har gjort released mutex.'}, {'timestamp': (320.72, 326.0), 'text': ' For hvis vi husker det man... Først gjør man get mutex, henter låsen,'}, {'timestamp': (326.0, 327.16), 'text': ' så kritisk avsnitt, og så release mutex. Så når da...'}, {'timestamp': (330.0, 335.24), 'text': ' Prosess nummer to. Er ferdig med sett kritiske avsnitt,'}, {'timestamp': (335.32, 339.16), 'text': ' så vil den release mye av teksten, og det gjør den ved å sette locklick-fots.'}, {'timestamp': (339.16, 344.36), 'text': ' Og da vil de som måtte stå her og vente i en løkke,'}, {'timestamp': (344.44, 351.92), 'text': ' de vil da komme inn i kritiske avsnitt, og så vil de sette locklick, tror jeg.'}, {'timestamp': (352.24, 359.2), 'text': ' Så dette ser ut som det perfekte opplegg. Men her er det et problem.'}, {'timestamp': (360.0, 365.56), 'text': ' Jeg har stilt et spørsmål her.'}, {'timestamp': (365.68, 371.08), 'text': ' Dette burde sikre at to prosesser ikke er i kritisk asyl samtidig.'}, {'timestamp': (371.1, 376.6), 'text': ' Men vi kan få et problem her, og det er hvis...'}, {'timestamp': (377.64, 382.96), 'text': ' Hva skjer hvis det kommer en context switch?'}, {'timestamp': (382.96, 388.8), 'text': ' Vi tenker at disse kjører på samme CPU.'}, {'timestamp': (390.0, 400.2), 'text': ' Hva om det kommer en kontekst-witch rett etter at denne prosessen har testet om...'}, {'timestamp': (402.66, 410.2), 'text': ' Om lock er false. Hvis vi antar at lock er false...'}, {'timestamp': (410.2, 419.6), 'text': ' Og så vil det jo... En sånn veiløkke... En sånn test består av flere deler.'}, {'timestamp': (420.0, 430.92), 'text': ' Første del må hente inn verdien og legge et register.'}, {'timestamp': (431.04, 434.32), 'text': ' Truly Falls-register er typisk 0 eller 1.'}, {'timestamp': (434.32, 439.52), 'text': ' Og så må den, etter at den har hentet den inn, gjøre en compare.'}, {'timestamp': (439.52, 443.44), 'text': ' Sammenligne den verdien med 0, f.eks.'}, {'timestamp': (443.44, 448.44), 'text': ' Og så må den etter den compare hoppe, avhengig av verdien.'}, {'timestamp': (450.0, 454.6), 'text': ' Men det der utføres i minst to institusjoner.'}, {'timestamp': (454.62, 458.8), 'text': ' Så hva skjer om det kommer en context switch'}, {'timestamp': (458.84, 465.08), 'text': ' nøyaktig etter at den har hentet inn verdien, og sett at den er falsk?'}, {'timestamp': (465.08, 467.88), 'text': ' Jo, da fryser selv den prosessen.'}, {'timestamp': (467.88, 474.32), 'text': ' Det neste den vil gjøre, er å sette lock-click-through og gå inn i kreditskapsnitt.'}, {'timestamp': (474.88, 478.6), 'text': ' Men når den første prosessen som kommer inn, fryser,'}, {'timestamp': (480.0, 485.12), 'text': ' Da er jo lock fortsatt false. Så den prosess nummer to...'}, {'timestamp': (485.12, 490.96), 'text': ' Den vil enkelt og greit bare hoppe over den løkka. Lock er false.'}, {'timestamp': (490.96, 496.28), 'text': ' Og så vil den sette locklik, tror jeg. Men da er det for sent.'}, {'timestamp': (496.36, 500.36), 'text': ' For da er P1 allerede inne i kritiske avsnitt.'}, {'timestamp': (500.44, 505.76), 'text': ' Og så kommer P2 etter, og den går også inn i kritiske avsnitt.'}, {'timestamp': (505.76, 509.0), 'text': ' Og da er vi tilbake i de gamle problemene.'}, {'timestamp': (510.0, 514.8), 'text': ' Så kan begge to kjøre kritiske avsnitt samtidig.'}, {'timestamp': (514.88, 520.96), 'text': ' Så derfor så fungerer rett og slett ikke denne software-løsningen.'}, {'timestamp': (520.96, 524.24), 'text': ' Den vil fungere stort sett,'}, {'timestamp': (524.3, 529.84), 'text': ' bortsett fra hvis det kommer et kritisk avsnitt nøyaktig etter wild lock.'}, {'timestamp': (529.92, 534.72), 'text': ' Nøyaktig etter at verdien er hentet inn til registrene,'}, {'timestamp': (534.72, 539.08), 'text': ' men rett før den hopper på grunnlag av denne verdien.'}, {'timestamp': (540.0, 542.64), 'text': ' Er ikke denne god nok?'}, {'timestamp': (542.72, 549.84), 'text': ' Og i øvingsoppgavene så kommer det et par andre nye forsøk'}, {'timestamp': (549.86, 553.0), 'text': ' som er litt bedre.'}, {'timestamp': (553.0, 557.0), 'text': ' Og til slutt så kommer man fram til Peterson-algoritmen,'}, {'timestamp': (557.08, 562.12), 'text': ' som kom en gang på 80-tallet, som er en perfekt software-mytex-løsning.'}, {'timestamp': (562.12, 569.96), 'text': ' Men den er litt tungvint, og du trenger litt kode. Men den kan.'}, {'timestamp': (570.0, 572.96), 'text': ' Det kan man bruke.'}, {'timestamp': (572.96, 577.16), 'text': ' Men i praksis, sånn som med operativstemme'}, {'timestamp': (577.24, 580.36), 'text': ' og sånn som med Java-tråder osv.,'}, {'timestamp': (580.36, 585.88), 'text': ' så bruker man metoder hvor man får hjelp fra Harvay.'}, {'timestamp': (585.92, 590.52), 'text': ' Og det sikrer i tillegg at man lokker databussen.'}, {'timestamp': (590.52, 594.6), 'text': ' Så de metodene er da enda bedre.'}, {'timestamp': (600.0, 608.8), 'text': ' I de softwareløsningene som vi har sett på, de krever litt kode.'}, {'timestamp': (608.8, 613.72), 'text': ' Og i tillegg så bruker de alle sammen bussy waiting.'}, {'timestamp': (613.74, 619.16), 'text': ' Bussy waiting er dette her med at man står og venter.'}, {'timestamp': (619.16, 623.6), 'text': ' Og da bruker man CPU-en. Man gjør NOP-institusjoner om og om igjen.'}, {'timestamp': (623.68, 627.92), 'text': ' Og det er en litt effektiv måte å vente på.'}, {'timestamp': (630.02, 632.58), 'text': " Det kalles da generelt 'bussy waiting'."}]}