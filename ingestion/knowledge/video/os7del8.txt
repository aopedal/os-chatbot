{'text': ' Ellen og L2Cash. Denne figuren viser prinsippene for Cash og hvorfor man kan få til å kjøre programmet fortere ved å bruke Cash. Helt til venstre på figuren her så ser vi CPU-en. Og så her står det R0R1R2 etter det. Det kunne stått AXBXXX også. Det er da registrene inni CPU-en. Disse brukes hele tiden til å mate oss inn i aluen. Problemstillingen er at denne CPU-en kan kverne veldig fort institusjoner. Den kan kverne institusjoner fortere enn RAM kan levere det. Og dermed så legger vi til dette L1- og L2-cash. Som sagt, mange har L3-cash også inne på skipen, av moderne prosessorer. Prinsippet er det samme. Så LN-cash er litt mindre. Men vi ser her i stedet for de fire... Her er det ikke bite engang, men det er fire bit. La oss si det er bite som skal inn i registrene. De fire bitene, de får plass i registrene. Og da kunne det være at CPU-en gjør en instruksjon som sier hent bite nummer 2. Opprinnelig var CPU-en sånn at OK, bite nummer to. Da går vi ut i ram, og så henter vi bite nummer to, som er den 1101 som ligger her oppe, og så sender vi den inn igjen. Men på den tiden så var det ikke noe forskjell på CPU og ram av betydning, sånn at det fungerte greit. Men etter hvert så har CPU-en løpt ifra og blitt raskere enn ram. Og da, i stedet for å bare hente den ene, Den biten der ute i ram, så når man da henter noe i ram, så tar man like godt med et stort område i nærheten av den biten man skal hente. Og så legger man... Så legger man det i L2-cash, hele den, så mye man får plass til, og det varierer. Og cashing, det styres på Hardner-nivå. Så dette er ikke noe som operativsystemet... Så vi kommer ikke til å se på i detalj nøyaktig hvordan algoritmene for dette er. Men det styres på hardware-nivå. Så som operativstem får du ikke gjort så mye med hvordan cash virker. Men iallfall i prinsippet så virker det sånn at du tar med en stor bit av gangen. Og så tar du med en litt mindre bit, som får plass i LN-cash. Og så, inntil sepund, så tar du de nærmeste bitene. Men statistisk sett så er det veldig ofte at man trenger bite, eller data som ligger i nærheten av hverandre. Dette kan f.eks. være institusjoner som ligger rett etter hverandre. Og da er det ofte at man hopper fra institusjon 1 til 2 til 3 til 4 osv. Og da, hvis man gjør det, så vil jo alle de institusjonene ligge her i LN Cash. Og da går det veldig kjapt å hente de over til SPU. andre gang. Noen ganger er det kanskje et stort RAI som ligger i RAM, de dataene du jobber med, og da er det den samme fordelen. Jo, da ofte så skal du ha neste RAI-element. Og når du henter ut det, så går det raskt fordi du har hentet det inn i LNCash. Og det skal vi teste ut senere når vi skal se på RAM. Hvordan er forskjellen på f.eks. hvordan man indekserer en matrise? For i noen tilfeller så hopper man rundt i RAM og henter. Man rammer data som ligger rett etter hverandre i ramm. Og det går alltid mye raskere. Så dette er hovedprinsippet for cash. Dette viser det man kan kalle mikroarkitekturen for L1- og L2-cash. Igjen så er det som sagt vanlig å ha en eldre cash, men i prinsippet så er den tilsvarende som level 2-cash. Her ser vi at LN-Cash har en litt spesiell arkitektur. Her står det LN-dato og LN-instruksjoner. Det betyr at her er det to forskjellige veier inn til CPU-en. Det er dette som gjør at man kan si... Dette er egentlig ikke noen van Neumann-arkitektur, hvor både datainstruksjoner går på den samme bussen. Det er van Neumann-arkitektur inn hit. Den siste biten er Harvard-arkitekturen, hvor man deler opp. Institusjoner kommer inn på én buss eller rute til CPU-en, og data kommer inn på en annen. Så ser vi altså at vi har en tredje bit. TLB Transplation Look-Aside Buffer. Og det er... Nå skal vi komme tilbake til senere. Det er minneadressering. Det er en... Det bruker MMU. Og MMU, den virtualiserer minneadressene, sånn at CPU-en ikke trenger å vite nøyaktig hvor i ram enhver bite ligger. Men det kommer vi tilbake til senere, men det er også veldig viktig for effektivitet at det er hurtig. Så derfor så er det en egen bit av LNCash som er satt av til TLB, eller minneadressering.', 'chunks': [{'timestamp': (0.0, 7.7), 'text': ' Ellen og L2Cash. Denne figuren viser prinsippene for Cash'}, {'timestamp': (7.78, 14.82), 'text': ' og hvorfor man kan få til å kjøre programmet fortere ved å bruke Cash.'}, {'timestamp': (14.84, 20.4), 'text': ' Helt til venstre på figuren her så ser vi CPU-en.'}, {'timestamp': (20.42, 27.1), 'text': ' Og så her står det R0R1R2 etter det. Det kunne stått AXBXXX også.'}, {'timestamp': (27.18, 29.7), 'text': ' Det er da registrene inni CPU-en.'}, {'timestamp': (30.0, 34.2), 'text': ' Disse brukes hele tiden til å mate oss inn i aluen.'}, {'timestamp': (34.2, 40.6), 'text': ' Problemstillingen er at denne CPU-en kan kverne veldig fort institusjoner.'}, {'timestamp': (40.68, 46.04), 'text': ' Den kan kverne institusjoner fortere enn RAM kan levere det.'}, {'timestamp': (46.04, 52.56), 'text': ' Og dermed så legger vi til dette L1- og L2-cash.'}, {'timestamp': (52.56, 58.92), 'text': ' Som sagt, mange har L3-cash også inne på skipen, av moderne prosessorer.'}, {'timestamp': (60.0, 63.4), 'text': ' Prinsippet er det samme. Så LN-cash er litt mindre.'}, {'timestamp': (63.48, 68.2), 'text': ' Men vi ser her i stedet for de fire...'}, {'timestamp': (68.28, 72.48), 'text': ' Her er det ikke bite engang, men det er fire bit.'}, {'timestamp': (72.56, 76.56), 'text': ' La oss si det er bite som skal inn i registrene.'}, {'timestamp': (77.04, 80.52), 'text': ' De fire bitene, de får plass i registrene.'}, {'timestamp': (80.54, 87.96), 'text': ' Og da kunne det være at CPU-en gjør en instruksjon som sier hent bite nummer 2.'}, {'timestamp': (90.0, 98.28), 'text': ' Opprinnelig var CPU-en sånn at OK, bite nummer to.'}, {'timestamp': (98.36, 102.04), 'text': ' Da går vi ut i ram, og så henter vi bite nummer to,'}, {'timestamp': (102.12, 106.0), 'text': ' som er den 1101 som ligger her oppe, og så sender vi den inn igjen.'}, {'timestamp': (106.08, 110.52), 'text': ' Men på den tiden så var det ikke noe forskjell på CPU og ram av betydning,'}, {'timestamp': (110.6, 112.76), 'text': ' sånn at det fungerte greit.'}, {'timestamp': (112.84, 117.22), 'text': ' Men etter hvert så har CPU-en løpt ifra og blitt raskere enn ram.'}, {'timestamp': (117.22, 119.76), 'text': ' Og da, i stedet for å bare hente den ene,'}, {'timestamp': (120.0, 125.16), 'text': ' Den biten der ute i ram, så når man da henter noe i ram,'}, {'timestamp': (125.24, 129.4), 'text': ' så tar man like godt med et stort område i nærheten av den biten'}, {'timestamp': (129.48, 134.68), 'text': ' man skal hente. Og så legger man...'}, {'timestamp': (136.16, 141.28), 'text': ' Så legger man det i L2-cash, hele den, så mye man får plass til,'}, {'timestamp': (141.36, 147.0), 'text': ' og det varierer. Og cashing, det styres på Hardner-nivå.'}, {'timestamp': (147.08, 149.6), 'text': ' Så dette er ikke noe som operativsystemet...'}, {'timestamp': (150.0, 156.8), 'text': ' Så vi kommer ikke til å se på i detalj nøyaktig hvordan algoritmene for dette er.'}, {'timestamp': (156.88, 160.16), 'text': ' Men det styres på hardware-nivå.'}, {'timestamp': (160.24, 165.36), 'text': ' Så som operativstem får du ikke gjort så mye med hvordan cash virker.'}, {'timestamp': (165.92, 170.84), 'text': ' Men iallfall i prinsippet så virker det sånn at du tar med en stor bit av gangen.'}, {'timestamp': (170.84, 174.88), 'text': ' Og så tar du med en litt mindre bit, som får plass i LN-cash.'}, {'timestamp': (174.88, 179.0), 'text': ' Og så, inntil sepund, så tar du de nærmeste bitene.'}, {'timestamp': (180.0, 185.46), 'text': ' Men statistisk sett så er det veldig ofte'}, {'timestamp': (185.9, 191.1), 'text': ' at man trenger bite, eller data som ligger i nærheten av hverandre.'}, {'timestamp': (191.4, 195.8), 'text': ' Dette kan f.eks. være institusjoner som ligger rett etter hverandre.'}, {'timestamp': (195.8, 201.1), 'text': ' Og da er det ofte at man hopper fra institusjon 1 til 2 til 3 til 4 osv.'}, {'timestamp': (201.18, 206.14), 'text': ' Og da, hvis man gjør det, så vil jo alle de institusjonene ligge her i LN Cash.'}, {'timestamp': (206.16, 209.96), 'text': ' Og da går det veldig kjapt å hente de over til SPU. andre gang.'}, {'timestamp': (210.0, 213.58), 'text': ' Noen ganger er det kanskje et stort RAI som ligger i RAM,'}, {'timestamp': (213.6, 218.08), 'text': ' de dataene du jobber med, og da er det den samme fordelen.'}, {'timestamp': (218.08, 221.6), 'text': ' Jo, da ofte så skal du ha neste RAI-element.'}, {'timestamp': (221.64, 225.28), 'text': ' Og når du henter ut det, så går det raskt'}, {'timestamp': (225.36, 228.52), 'text': ' fordi du har hentet det inn i LNCash.'}, {'timestamp': (228.6, 231.8), 'text': ' Og det skal vi teste ut senere når vi skal se på RAM.'}, {'timestamp': (231.88, 235.76), 'text': ' Hvordan er forskjellen på f.eks. hvordan man indekserer en matrise?'}, {'timestamp': (235.76, 238.8), 'text': ' For i noen tilfeller så hopper man rundt i RAM og henter.'}, {'timestamp': (240.0, 243.48), 'text': ' Man rammer data som ligger rett etter hverandre i ramm.'}, {'timestamp': (243.64, 250.6), 'text': ' Og det går alltid mye raskere. Så dette er hovedprinsippet for cash.'}, {'timestamp': (252.0, 259.64), 'text': ' Dette viser det man kan kalle mikroarkitekturen for L1- og L2-cash.'}, {'timestamp': (259.64, 264.6), 'text': ' Igjen så er det som sagt vanlig å ha en eldre cash,'}, {'timestamp': (264.68, 269.84), 'text': ' men i prinsippet så er den tilsvarende som level 2-cash.'}, {'timestamp': (270.0, 277.6), 'text': ' Her ser vi at LN-Cash har en litt spesiell arkitektur.'}, {'timestamp': (277.68, 280.48), 'text': ' Her står det LN-dato og LN-instruksjoner.'}, {'timestamp': (280.48, 285.12), 'text': ' Det betyr at her er det to forskjellige veier inn til CPU-en.'}, {'timestamp': (285.12, 288.2), 'text': ' Det er dette som gjør at man kan si...'}, {'timestamp': (288.2, 292.92), 'text': ' Dette er egentlig ikke noen van Neumann-arkitektur,'}, {'timestamp': (293.2, 296.4), 'text': ' hvor både datainstruksjoner går på den samme bussen.'}, {'timestamp': (296.48, 299.0), 'text': ' Det er van Neumann-arkitektur inn hit.'}, {'timestamp': (300.0, 303.94), 'text': ' Den siste biten er Harvard-arkitekturen,'}, {'timestamp': (303.96, 310.88), 'text': ' hvor man deler opp. Institusjoner kommer inn på én buss eller rute til CPU-en,'}, {'timestamp': (310.9, 314.28), 'text': ' og data kommer inn på en annen.'}, {'timestamp': (314.36, 321.66), 'text': ' Så ser vi altså at vi har en tredje bit. TLB Transplation Look-Aside Buffer.'}, {'timestamp': (321.68, 327.32), 'text': ' Og det er... Nå skal vi komme tilbake til senere.'}, {'timestamp': (327.34, 329.98), 'text': ' Det er minneadressering. Det er en...'}, {'timestamp': (330.0, 333.5), 'text': ' Det bruker MMU.'}, {'timestamp': (333.52, 339.6), 'text': ' Og MMU, den virtualiserer minneadressene,'}, {'timestamp': (339.68, 344.36), 'text': ' sånn at CPU-en ikke trenger å vite nøyaktig hvor i ram enhver bite ligger.'}, {'timestamp': (344.36, 350.68), 'text': ' Men det kommer vi tilbake til senere, men det er også veldig viktig for effektivitet at det er hurtig.'}, {'timestamp': (350.76, 359.8), 'text': ' Så derfor så er det en egen bit av LNCash som er satt av til TLB, eller minneadressering.'}]}