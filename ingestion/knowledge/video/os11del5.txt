{'text': ' Blokkerende systemcall. Dette er opprinnelig den viktigste grunnen til at vi har tråder i det hele tatt. Blokkerende systemcall er systemcall som da blokkerer prosessen fordi den venter på en input-output-forespørsel. Det kan f.eks. være at man ønsker å lese noe fra en disk. Da er det jo naturlig at programmet ikke går videre før den har lest det som den har på disken. Og i alle denne type systemkall hvor man må vente på resultatet før programmet kan gå videre, det er da representert ved et blokkerende systemkall. For da gjør man et systemkall, og så blokkerer det prosessen, sånn at den ikke får kjøre videre. Det kan være veldig uheldig. For du ønsker gjerne at en applikasjon skal være responsiv, selv om den leser noe fra disk eller gjør noe annet som krever IO. Og derfor så... Det var på en måte en av hovedideene for å få inn tråder. Nemlig at programmereren ved hjelp av tråder kan styre de forskjellige arbeidsoppgavene. Det henger da ikke i å vente på blokkerende systemcall. Noen eksempler på den type systemcall er sånn som read and write, await, opplagt hvor du venter på andre toaletter, og sleep, altså opplagt blokkerende, for der venter du eksplisitt. Det mest typiske er sånn som read, hvor du leser noe fra disk, og da må du vente på å få resultatet. Så fins en del ikke-blokkerende systemkall også, eller veldig mange, sånn som GetPayDay og GetTimeOfDay f.eks. De eksekverer ferdig veldig raskt, og de blokkerer da ikke prosessen. Trådmodeller. Det finnes mange implementasjoner av tråder, og dette er det. De er de tre vanligste og mest brukte trådmodellene. Den som er aller vanligst med en gang, det er 1-1. Det er denne modellen her hvor for hver tråd brukeren starter... F.eks. vi starter et Java-program. JVM starter 20 tråder. Da vil det tilsvarende være 20 kjernetråder. Det betyr i praksis at du... Du har 20 tråder som skreduleres som 20 uavhengige regneoperasjoner. I tillegg har vi én til mange. Vi kan se litt på neste slide hvor disse blir beskrevet. Én til mange, det betyr at alle trådene skreduleres som én prosess. Tidligere fantes en del sånne implementasjoner. Det kalles ofte green threats. Den aller første implementasjonen på Linux av JVM var av green threats. Men det er jo litt upraktisk, for det som skjer da, er at programmeren selv må skedulere. Vi har f.eks. en metode som kalles Yield, som sier... Ok, nå vil jeg gi fra meg CPU-en. Og Yield er en sånn... Når man overlater til operativsystemet å skredulere. Men dette er da den trådmodellen. Så har vi 1-1, som er det mest vanlige, hvor alle tråder skreduleres uavhengig av hverandre av operativsystemet. Det er det som vi har i Java, og etter pausen skal vi se på Post-Ex-Treats eller P-Treats. De skreduleres også på den måten. En tredje måte er mange-til-mange. Og da skal du lese som én-til-én hvis det ikke er altfor mange tråder. Men så har det vært en del operativsystemer som har implementert mange-til-mange for tilfeller hvor det er ekstremt mange tråder. Altså mange hundre eller mange tusen tråder. Skreduleres hver for seg. Så lager man grupper, sånn at én kjernetråd tar hånd om et sett av tråder. Så kan det være 50 tråder som skreduleres av denne, og 50 av denne tråden. Da får de en intern skredulering seg imellom.', 'chunks': [{'timestamp': (0.0, 4.8), 'text': ' Blokkerende systemcall.'}, {'timestamp': (4.8, 9.52), 'text': ' Dette er opprinnelig den viktigste grunnen til'}, {'timestamp': (9.6, 13.42), 'text': ' at vi har tråder i det hele tatt.'}, {'timestamp': (13.44, 19.84), 'text': ' Blokkerende systemcall er systemcall som da blokkerer prosessen'}, {'timestamp': (19.92, 24.1), 'text': ' fordi den venter på en input-output-forespørsel.'}, {'timestamp': (24.1, 29.0), 'text': ' Det kan f.eks. være at man ønsker å lese noe fra en disk.'}, {'timestamp': (30.0, 35.42), 'text': ' Da er det jo naturlig at programmet ikke går videre'}, {'timestamp': (35.5, 39.46), 'text': ' før den har lest det som den har på disken.'}, {'timestamp': (39.54, 44.34), 'text': ' Og i alle denne type systemkall hvor man må vente på resultatet'}, {'timestamp': (44.42, 49.46), 'text': ' før programmet kan gå videre, det er da representert'}, {'timestamp': (49.9, 54.1), 'text': ' ved et blokkerende systemkall. For da gjør man et systemkall,'}, {'timestamp': (54.18, 59.18), 'text': ' og så blokkerer det prosessen, sånn at den ikke får kjøre videre.'}, {'timestamp': (60.0, 62.68), 'text': ' Det kan være veldig uheldig.'}, {'timestamp': (62.68, 67.84), 'text': ' For du ønsker gjerne at en applikasjon skal være responsiv,'}, {'timestamp': (67.92, 73.72), 'text': ' selv om den leser noe fra disk eller gjør noe annet som krever IO.'}, {'timestamp': (73.72, 82.56), 'text': ' Og derfor så... Det var på en måte en av hovedideene for å få inn tråder.'}, {'timestamp': (82.68, 88.48), 'text': ' Nemlig at programmereren ved hjelp av tråder kan styre de forskjellige arbeidsoppgavene.'}, {'timestamp': (90.0, 94.4), 'text': ' Det henger da ikke i å vente på blokkerende systemcall.'}, {'timestamp': (94.48, 98.84), 'text': ' Noen eksempler på den type systemcall er sånn som read and write,'}, {'timestamp': (99.4, 102.72), 'text': ' await, opplagt hvor du venter på andre toaletter,'}, {'timestamp': (103.6, 109.64), 'text': ' og sleep, altså opplagt blokkerende, for der venter du eksplisitt.'}, {'timestamp': (109.64, 115.44), 'text': ' Det mest typiske er sånn som read, hvor du leser noe fra disk,'}, {'timestamp': (115.52, 119.92), 'text': ' og da må du vente på å få resultatet.'}, {'timestamp': (120.0, 125.04), 'text': ' Så fins en del ikke-blokkerende systemkall også, eller veldig mange,'}, {'timestamp': (125.12, 130.56), 'text': ' sånn som GetPayDay og GetTimeOfDay f.eks.'}, {'timestamp': (130.64, 137.8), 'text': ' De eksekverer ferdig veldig raskt, og de blokkerer da ikke prosessen.'}, {'timestamp': (141.72, 147.8), 'text': ' Trådmodeller. Det finnes mange implementasjoner av tråder, og dette er det.'}, {'timestamp': (150.0, 155.92), 'text': ' De er de tre vanligste og mest brukte trådmodellene.'}, {'timestamp': (155.92, 161.68), 'text': ' Den som er aller vanligst med en gang, det er 1-1.'}, {'timestamp': (161.76, 167.16), 'text': ' Det er denne modellen her hvor for hver tråd brukeren starter...'}, {'timestamp': (167.16, 172.76), 'text': ' F.eks. vi starter et Java-program. JVM starter 20 tråder.'}, {'timestamp': (172.76, 179.96), 'text': ' Da vil det tilsvarende være 20 kjernetråder. Det betyr i praksis at du...'}, {'timestamp': (180.0, 188.8), 'text': ' Du har 20 tråder som skreduleres som 20 uavhengige regneoperasjoner.'}, {'timestamp': (192.6, 195.8), 'text': ' I tillegg har vi én til mange.'}, {'timestamp': (195.8, 202.28), 'text': ' Vi kan se litt på neste slide hvor disse blir beskrevet.'}, {'timestamp': (202.28, 208.8), 'text': ' Én til mange, det betyr at alle trådene skreduleres som én prosess.'}, {'timestamp': (210.0, 213.8), 'text': ' Tidligere fantes en del sånne implementasjoner.'}, {'timestamp': (213.8, 216.48), 'text': ' Det kalles ofte green threats.'}, {'timestamp': (216.48, 221.76), 'text': ' Den aller første implementasjonen på Linux av JVM var av green threats.'}, {'timestamp': (221.76, 226.28), 'text': ' Men det er jo litt upraktisk, for det som skjer da,'}, {'timestamp': (226.36, 229.08), 'text': ' er at programmeren selv må skedulere.'}, {'timestamp': (229.08, 234.0), 'text': ' Vi har f.eks. en metode som kalles Yield, som sier...'}, {'timestamp': (234.08, 238.8), 'text': ' Ok, nå vil jeg gi fra meg CPU-en. Og Yield er en sånn...'}, {'timestamp': (240.0, 245.4), 'text': ' Når man overlater til operativsystemet å skredulere.'}, {'timestamp': (245.4, 249.44), 'text': ' Men dette er da den trådmodellen.'}, {'timestamp': (249.44, 252.0), 'text': ' Så har vi 1-1, som er det mest vanlige,'}, {'timestamp': (252.0, 256.36), 'text': ' hvor alle tråder skreduleres uavhengig av hverandre'}, {'timestamp': (256.36, 258.04), 'text': ' av operativsystemet.'}, {'timestamp': (258.04, 264.56), 'text': ' Det er det som vi har i Java, og etter pausen skal vi se på'}, {'timestamp': (264.64, 269.6), 'text': ' Post-Ex-Treats eller P-Treats. De skreduleres også på den måten.'}, {'timestamp': (270.0, 274.64), 'text': ' En tredje måte er mange-til-mange.'}, {'timestamp': (274.64, 280.52), 'text': ' Og da skal du lese som én-til-én hvis det ikke er altfor mange tråder.'}, {'timestamp': (280.52, 284.1), 'text': ' Men så har det vært en del operativsystemer'}, {'timestamp': (284.1, 287.62), 'text': ' som har implementert mange-til-mange'}, {'timestamp': (287.62, 291.58), 'text': ' for tilfeller hvor det er ekstremt mange tråder.'}, {'timestamp': (291.58, 296.58), 'text': ' Altså mange hundre eller mange tusen tråder.'}, {'timestamp': (300.0, 304.08), 'text': ' Skreduleres hver for seg.'}, {'timestamp': (304.16, 309.64), 'text': ' Så lager man grupper, sånn at én kjernetråd'}, {'timestamp': (309.66, 313.24), 'text': ' tar hånd om et sett av tråder.'}, {'timestamp': (313.32, 317.8), 'text': ' Så kan det være 50 tråder som skreduleres av denne,'}, {'timestamp': (317.88, 321.08), 'text': ' og 50 av denne tråden.'}, {'timestamp': (321.08, 327.88), 'text': ' Da får de en intern skredulering seg imellom.'}]}