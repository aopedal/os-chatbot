{'text': ' Vi så før pause på hvordan vi kompilerte sammen disse to programmene her. Det var da et trådprogram som kjører to tråder, som hele tiden utfører én linje. Og én linje, det er bare å øke svar med én. Så når begge gjør dette her 100 millioner ganger, så bør svaret bli 200 millioner. Og vi kompilerte sammen på denne måten. Og så kjørte vi det på denne måten. Og så ser vi at svaret ble ikke 200 millioner. Og det er... Det skyldes da at man ikke synkroniserer. At disse to trådene... De kjører på hver sin CPU, og de går da ut og henter inn. Verdier fra ramm. Og så ødelegger de for hverandre. Men det som spørsmålet gjaldt, var om jeg tok tiden på disse her. Hvis jeg timer Adatat på den måten, så ser vi at de bruker... ja, ett sekund. Men mitt poeng var at det at det bruker 200 % CPU, det viser at her så bruker de de to sekundene imot. Hvis jeg eksplisitt med task-sett sier at nå skal begge trådene kjøre på samme superhjul... Da... Da ser vi at... tiden var raskere. Her ble faktisk sluttresultatet... riktig også. Og det var altså noe av det vi skulle se på. Men... At det går raskere her... Det kan nok skyldes at... At det tar mer tid å synkronisere mellom to CPU-er. Men svaret er kanskje ikke fullt så enkelt heller. For jeg testet det også. Ved å prøve å skru av den joinen som vi gjør til slutt. Men iallfall - det som kan ha en effekt, det må vi undersøke nærmere. Og det er tema for forelesningen neste uke. Og det er cashing. Neste uke skal vi se på minnet. Og det som kan ha en effekt her, som gjør at det går raskere når du kjører på Det er at... Ja, det kan ha med cashing å gjøre. At man mellomlagrer verdien og så gjør en endring før den er skrevet helt ut til dem. Vi kan prøve å se i neste uke om vi kan finne ut av det, for da kan vi se på hvor mange sånne cash-operasjoner som utføres. Så det kan ha en effekt når noe går raskere på samme CPU enn hvis man kjører på to forskjellige CPU-er. Vi så her at dette gikk på 0,34 sekunder, men så opp i 1 sekund her, selv om de kjørte på to forskjellige CPU-er. Men akkurat den biten, den ser vi på neste gang. Men nå skal vi konsentrere oss om ikke om timingen, men om det som kjører... Det som skjer når vi kjører på samme SIPU og på forskjellige SIPU-er... Vi kan gjenta det vi... det vi gjorde. Hvis jeg nå ikke tenker på tiden, bare kjører av-og-taut, så ser vi når jeg kjører dette programmet på to forskjellige SIPU-er. Så selv om dette her bare er én enkel institusjon, så blir sluttresultatet forskjellig hver gang. Fordi de driver og henter ut samme verdi og overskriver hverandres resultater. Men hvis jeg kjører på... på samme suppe, så ser vi... Da blir resultatet riktig hver gang. Og det er fordi når det bare er én institusjon her, så blir dette som en atomisk operasjon. Men forskjellen er at vi låser ikke minnebussen. Men vi kan ikke ha en contex-switch som ødelegger for denne atomiske operasjonen. For da... Hvis det skjer en contex-switch, så er enten så er denne institusjonen ferdig, eller så er den ikke ferdig. Så en contex-switch vil ikke kunne ødelegge for dette. Men hvis de kjører på to forskjellige CPU-er, som vi ser her... Da trenger det ikke å være kontekster som kommer midt inn i en kode. Da kommer de omtrent likt ut til ram for å hente inn verdien. Etterpå skal jeg prøve å tegne opp litt hvorfor dette skjer, og prøve å forklare enda litt mer i detalj. For det er viktig å få med seg akkurat den biten her. Men før vi kommer så langt, så skal vi se på et annet... Et annet eksempel hvor jeg har en ikke-minimal.s, men minimal-2.s. For å gjøre det litt enklere enn det jeg viste fram før pause. For der hadde jeg kode som var lagd av GCC. Men vi ser nå på... Dette er nå assembly-kode. Og assembly-kode og maskinkode... Jeg bruker ofte de ordene om hverandre, og det er fordi én linje assemblykode, sånn som dette, det fører til én linje maskinkode. Så hvis det er enkelprosent dax, det blir direkte oversatt til nulldeler og enere. Men det vil alltid være sånn at én assemblykodelinje, det blir én maskinkodelinje. Så dette kan man stole på at dette er det operativsystemet ser. Derimot, hvis du har høynivåkode, Så kan det være at én linje høynivåkode kan gi flere linjer maskinkode eller asemblykode. Men i dette tilfellet så ser vi, i stedet for å bare øke svar med én direkte i ramm, som man kan gjøre, så har jeg delt opp dette i tre institusjoner. Først en som henter svar og legger det i EAX. Og så en institusjon som øker EAX med én. Og så flyttes resultatet ut til svaret. Det er sånn som en kompilator kan finne på å lage kode. Det kan vi ikke være sikre på om dette skjer. Så hvis jeg nå prøver å kompilere med denne i stedet... Så jeg tar nå minimal... Ikke tre, men minimal to. Og så prøver jeg å kjøre med Task-sett. Og da ser vi igjen så oppstår problemet. Igjen så blir det nå trøbbel. Og det er fordi her er det tre linjer med kode. Man henter inn eksplisitt fra RAM, så hentes det inn til AAX. Så økes den, og så legges den ut igjen. Og da kan vi få problemet med Yrvis, og det er det som skjer. Hvis det kommer da en contact switch før den har øket verdien, så kan den hoppe til den andre tråden, som nå henter inn svar på nytt, gjør en rekke økninger og legger tilbake resultatet. Men da, i mellomtiden, så er denne første prosessen frosset her. Den vil øke da på... den verdien som den hentet inn, og så skrive den ut igjen. Og da blir det trøbbel. Da blir det trøbbel. Men hvis vi derfor i stedet bruker minimal.s, denne, med bare én enkelinstitusjon... Så komponere på nytt. Én enkelinstitusjon, så kjøre med Taset. Da vil hver eneste gang så får man riktig svar. Fordi det ikke kan komme en kontekst-witch inne i den operasjonen.', 'chunks': [{'timestamp': (0.0, 5.08), 'text': ' Vi så før pause på'}, {'timestamp': (5.08, 10.96), 'text': ' hvordan vi kompilerte sammen disse to programmene her.'}, {'timestamp': (10.96, 14.68), 'text': ' Det var da et trådprogram som kjører to tråder,'}, {'timestamp': (14.76, 17.22), 'text': ' som hele tiden utfører én linje.'}, {'timestamp': (17.22, 21.8), 'text': ' Og én linje, det er bare å øke svar med én.'}, {'timestamp': (21.84, 27.28), 'text': ' Så når begge gjør dette her 100 millioner ganger,'}, {'timestamp': (27.28, 29.46), 'text': ' så bør svaret bli 200 millioner.'}, {'timestamp': (30.0, 34.44), 'text': ' Og vi kompilerte sammen på denne måten.'}, {'timestamp': (34.44, 39.64), 'text': ' Og så kjørte vi det på denne måten.'}, {'timestamp': (40.88, 45.76), 'text': ' Og så ser vi at svaret ble ikke 200 millioner.'}, {'timestamp': (45.76, 51.0), 'text': ' Og det er... Det skyldes da at man ikke synkroniserer.'}, {'timestamp': (51.0, 59.88), 'text': ' At disse to trådene... De kjører på hver sin CPU, og de går da ut og henter inn.'}, {'timestamp': (60.0, 65.0), 'text': ' Verdier fra ramm. Og så ødelegger de for hverandre.'}, {'timestamp': (65.08, 69.94), 'text': ' Men det som spørsmålet gjaldt, var om jeg tok tiden på disse her.'}, {'timestamp': (69.94, 74.56), 'text': ' Hvis jeg timer Adatat på den måten,'}, {'timestamp': (74.58, 79.86), 'text': ' så ser vi at de bruker... ja, ett sekund.'}, {'timestamp': (79.86, 89.8), 'text': ' Men mitt poeng var at det at det bruker 200 % CPU, det viser at her så bruker de de to sekundene imot.'}, {'timestamp': (90.0, 96.08), 'text': ' Hvis jeg eksplisitt med task-sett sier'}, {'timestamp': (96.12, 100.76), 'text': ' at nå skal begge trådene kjøre på samme superhjul...'}, {'timestamp': (100.76, 109.48), 'text': ' Da... Da ser vi at... tiden var raskere.'}, {'timestamp': (109.48, 117.88), 'text': ' Her ble faktisk sluttresultatet... riktig også.'}, {'timestamp': (120.0, 125.92), 'text': ' Og det var altså noe av det vi skulle se på. Men...'}, {'timestamp': (125.92, 132.48), 'text': ' At det går raskere her... Det kan nok skyldes at...'}, {'timestamp': (134.54, 141.2), 'text': ' At det tar mer tid å synkronisere mellom to CPU-er.'}, {'timestamp': (141.2, 149.0), 'text': ' Men svaret er kanskje ikke fullt så enkelt heller. For jeg testet det også.'}, {'timestamp': (150.0, 157.68), 'text': ' Ved å prøve å skru av den joinen som vi gjør til slutt.'}, {'timestamp': (157.76, 163.28), 'text': ' Men iallfall - det som kan ha en effekt, det må vi undersøke nærmere.'}, {'timestamp': (163.36, 167.32), 'text': ' Og det er tema for forelesningen neste uke.'}, {'timestamp': (167.34, 173.04), 'text': ' Og det er cashing. Neste uke skal vi se på minnet.'}, {'timestamp': (173.04, 178.96), 'text': ' Og det som kan ha en effekt her, som gjør at det går raskere når du kjører på'}, {'timestamp': (180.0, 183.4), 'text': ' Det er at...'}, {'timestamp': (186.92, 190.52), 'text': ' Ja, det kan ha med cashing å gjøre.'}, {'timestamp': (191.4, 196.0), 'text': ' At man mellomlagrer verdien og så gjør en endring'}, {'timestamp': (196.08, 199.64), 'text': ' før den er skrevet helt ut til dem.'}, {'timestamp': (199.66, 204.4), 'text': ' Vi kan prøve å se i neste uke om vi kan finne ut av det,'}, {'timestamp': (204.48, 209.98), 'text': ' for da kan vi se på hvor mange sånne cash-operasjoner som utføres.'}, {'timestamp': (210.0, 215.68), 'text': ' Så det kan ha en effekt når noe går raskere på samme CPU'}, {'timestamp': (215.76, 219.4), 'text': ' enn hvis man kjører på to forskjellige CPU-er.'}, {'timestamp': (219.4, 225.28), 'text': ' Vi så her at dette gikk på 0,34 sekunder, men så opp i 1 sekund her,'}, {'timestamp': (225.38, 228.56), 'text': ' selv om de kjørte på to forskjellige CPU-er.'}, {'timestamp': (228.56, 233.4), 'text': ' Men akkurat den biten, den ser vi på neste gang.'}, {'timestamp': (233.4, 239.96), 'text': ' Men nå skal vi konsentrere oss om ikke om timingen, men om det som kjører...'}, {'timestamp': (240.0, 246.36), 'text': ' Det som skjer når vi kjører på samme SIPU og på forskjellige SIPU-er...'}, {'timestamp': (246.44, 251.04), 'text': ' Vi kan gjenta det vi... det vi gjorde.'}, {'timestamp': (251.04, 255.72), 'text': ' Hvis jeg nå ikke tenker på tiden, bare kjører av-og-taut,'}, {'timestamp': (255.72, 260.96), 'text': ' så ser vi når jeg kjører dette programmet på to forskjellige SIPU-er.'}, {'timestamp': (260.96, 264.68), 'text': ' Så selv om dette her bare er én enkel institusjon,'}, {'timestamp': (265.04, 269.96), 'text': ' så blir sluttresultatet forskjellig hver gang.'}, {'timestamp': (270.0, 274.3), 'text': ' Fordi de driver og henter ut samme verdi'}, {'timestamp': (274.38, 277.54), 'text': ' og overskriver hverandres resultater.'}, {'timestamp': (277.54, 287.62), 'text': ' Men hvis jeg kjører på... på samme suppe, så ser vi...'}, {'timestamp': (287.64, 291.0), 'text': ' Da blir resultatet riktig hver gang.'}, {'timestamp': (291.0, 296.08), 'text': ' Og det er fordi når det bare er én institusjon her,'}, {'timestamp': (296.08, 299.92), 'text': ' så blir dette som en atomisk operasjon.'}, {'timestamp': (300.0, 304.0), 'text': ' Men forskjellen er at vi låser ikke minnebussen.'}, {'timestamp': (304.0, 312.36), 'text': ' Men vi kan ikke ha en contex-switch som ødelegger for denne atomiske operasjonen.'}, {'timestamp': (312.36, 316.4), 'text': ' For da... Hvis det skjer en contex-switch,'}, {'timestamp': (316.48, 320.92), 'text': ' så er enten så er denne institusjonen ferdig, eller så er den ikke ferdig.'}, {'timestamp': (320.92, 326.48), 'text': ' Så en contex-switch vil ikke kunne ødelegge for dette.'}, {'timestamp': (326.48, 329.92), 'text': ' Men hvis de kjører på to forskjellige CPU-er, som vi ser her...'}, {'timestamp': (330.0, 336.64), 'text': ' Da trenger det ikke å være kontekster som kommer midt inn i en kode.'}, {'timestamp': (336.68, 343.8), 'text': ' Da kommer de omtrent likt ut til ram for å hente inn verdien.'}, {'timestamp': (343.8, 349.8), 'text': ' Etterpå skal jeg prøve å tegne opp litt hvorfor dette skjer,'}, {'timestamp': (349.88, 353.88), 'text': ' og prøve å forklare enda litt mer i detalj.'}, {'timestamp': (354.6, 356.96), 'text': ' For det er viktig å få med seg akkurat den biten her.'}, {'timestamp': (356.98, 359.8), 'text': ' Men før vi kommer så langt, så skal vi se på et annet...'}, {'timestamp': (360.0, 368.4), 'text': ' Et annet eksempel hvor jeg har en ikke-minimal.s, men minimal-2.s.'}, {'timestamp': (370.78, 375.04), 'text': ' For å gjøre det litt enklere enn det jeg viste fram før pause.'}, {'timestamp': (375.24, 378.64), 'text': ' For der hadde jeg kode som var lagd av GCC.'}, {'timestamp': (378.64, 386.0), 'text': ' Men vi ser nå på... Dette er nå assembly-kode.'}, {'timestamp': (386.0, 389.92), 'text': ' Og assembly-kode og maskinkode...'}, {'timestamp': (390.0, 393.44), 'text': ' Jeg bruker ofte de ordene om hverandre,'}, {'timestamp': (394.18, 398.16), 'text': ' og det er fordi én linje assemblykode, sånn som dette,'}, {'timestamp': (398.16, 400.94), 'text': ' det fører til én linje maskinkode.'}, {'timestamp': (400.94, 407.32), 'text': ' Så hvis det er enkelprosent dax, det blir direkte oversatt til nulldeler og enere.'}, {'timestamp': (407.32, 413.0), 'text': ' Men det vil alltid være sånn at én assemblykodelinje, det blir én maskinkodelinje.'}, {'timestamp': (413.5, 417.52), 'text': ' Så dette kan man stole på at dette er det operativsystemet ser.'}, {'timestamp': (417.52, 419.98), 'text': ' Derimot, hvis du har høynivåkode,'}, {'timestamp': (420.0, 426.18), 'text': ' Så kan det være at én linje høynivåkode kan gi flere linjer maskinkode'}, {'timestamp': (427.26, 428.42), 'text': ' eller asemblykode.'}, {'timestamp': (428.44, 436.2), 'text': ' Men i dette tilfellet så ser vi, i stedet for å bare øke svar med én direkte i ramm,'}, {'timestamp': (436.2, 440.68), 'text': ' som man kan gjøre, så har jeg delt opp dette i tre institusjoner.'}, {'timestamp': (440.68, 449.98), 'text': ' Først en som henter svar og legger det i EAX. Og så en institusjon som øker EAX med én.'}, {'timestamp': (450.0, 452.7), 'text': ' Og så flyttes resultatet ut til svaret.'}, {'timestamp': (452.7, 457.8), 'text': ' Det er sånn som en kompilator kan finne på å lage kode.'}, {'timestamp': (457.88, 462.48), 'text': ' Det kan vi ikke være sikre på om dette skjer.'}, {'timestamp': (465.2, 471.8), 'text': ' Så hvis jeg nå prøver å kompilere med denne i stedet...'}, {'timestamp': (474.76, 478.96), 'text': ' Så jeg tar nå minimal... Ikke tre, men minimal to.'}, {'timestamp': (480.0, 484.84), 'text': ' Og så prøver jeg å kjøre med Task-sett.'}, {'timestamp': (486.64, 491.56), 'text': ' Og da ser vi igjen så oppstår problemet.'}, {'timestamp': (492.02, 496.0), 'text': ' Igjen så blir det nå trøbbel.'}, {'timestamp': (496.0, 502.76), 'text': ' Og det er fordi her er det tre linjer med kode.'}, {'timestamp': (502.84, 509.0), 'text': ' Man henter inn eksplisitt fra RAM, så hentes det inn til AAX.'}, {'timestamp': (510.0, 512.64), 'text': ' Så økes den, og så legges den ut igjen.'}, {'timestamp': (512.72, 517.04), 'text': ' Og da kan vi få problemet med Yrvis, og det er det som skjer.'}, {'timestamp': (517.12, 521.56), 'text': ' Hvis det kommer da en contact switch før den har øket verdien,'}, {'timestamp': (521.64, 527.8), 'text': ' så kan den hoppe til den andre tråden, som nå henter inn svar på nytt,'}, {'timestamp': (528.32, 532.4), 'text': ' gjør en rekke økninger og legger tilbake resultatet.'}, {'timestamp': (533.12, 537.12), 'text': ' Men da, i mellomtiden, så er denne første prosessen frosset her.'}, {'timestamp': (540.0, 545.88), 'text': ' Den vil øke da på... den verdien som den hentet inn,'}, {'timestamp': (545.88, 552.08), 'text': ' og så skrive den ut igjen. Og da blir det trøbbel. Da blir det trøbbel.'}, {'timestamp': (552.16, 556.96), 'text': ' Men hvis vi derfor i stedet bruker minimal.s,'}, {'timestamp': (556.96, 563.48), 'text': ' denne, med bare én enkelinstitusjon... Så komponere på nytt.'}, {'timestamp': (563.48, 568.8), 'text': ' Én enkelinstitusjon, så kjøre med Taset. Da vil hver eneste gang så får man riktig svar.'}, {'timestamp': (570.0, 575.98), 'text': ' Fordi det ikke kan komme en kontekst-witch inne i den operasjonen.'}]}