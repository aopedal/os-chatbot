{'text': ' Ok. Det var en liten gjennomgang av Linux-historie. Nå skal vi gå inn på et helt nytt tema, nemlig multitasking. Aller først skal vi for tredje gang se på CPU-løkken. Det er dette vi må ha med videre. Og om og om igjen kjører instruksjoner. Det vi skal se litt nærmere på nå, er interrupt request. For en gang iblant så kan det komme et fysisk interrupt-orkest. F.eks. ved at jeg taster på tastaturet sånn. Maskinen må da reagere på den inntastingen veldig hurtig. Og det som da skjer, er at... Den avbrytes i sin evige løkke, og så håndterer den det signalet. Ofte brukes det pund noen mikrosekunder på å fullføre det den er i gang med. Og så hopper den til en interrupt rutine, som da sørger for at den piltasten som jeg trykket på, at den har en effekt. Den må avbrytes for å håndtere signalet. Da må man lagre adressen til neste institusjon, og så hoppe til en interrupt-rutine. Det blir litt som å gjøre et kall på en rutine, men her er det en fysisk interrupt som sendes inn, og så gjøres det kall på rutinen. Hvert interrupt eller IRQ har sin egen rutine som man da hopper til. Noe fra tastaturet, en annen hvis det kommer fra nettverket, en tredje hvis det kommer fra mikrofonen, osv. Vi skal se på multitasking. For å forstå multitasking er det viktig å vite hvordan minne eller ramm er koblet sammen med prosesser. Vi skal fokusere på ramm direkte, og da skal vi se mer på dette. Men det vi trenger å vite nå, er at det finnes flere deler i ramm som er tildelt en prosess. Dette som vi viser bildet her nå, det er én bit av ramm som er tilordnet én prosess. Operativsystemet er også en egen prosess. Den viktigste biten er kanskje koden eller teksten, som vi ser her nede. Unnskyld. Koden, det er da maskininstruksjonene som prosessen skal kjøre. Som ligger etter hverandre. Institusjon for institusjon. Det typiske som skjer når en prosess kjører, er at man starter på første institusjon til prosessen. Så er det gjerne en loop her, så den hopper opp og ned. Men så har vi sett at vi hele tiden har variabler i programmet, som brukes og skrives til ram. Og da i heapen, som går fra koden her og oppover, er det satt av masse plass til heapen, sånn at den kan utvide seg. For her kan man dynamisk legge inn nye variabler. De legges da på heapen. Stacken, det er et område hvor lokale variabler legges. F.eks. hvis du gjør et funksjonskall, så legger du på stacken returverdien fra det funksjonskallet, så man vet hvor man skal tilbake. Da er det enkelt å bare gå inn der. Så plukker du opp... I tillegg er det vanlig å ha en MM-mapp, som er en avbildning av filer og deviser inn i ramm. Men dette er igjen for at ting skal gå fortere. Så er det en kopi av noe av det som ligger på disk, sånn at man skal ha raskere aksess. Og Jeep, det er det vi snakker om. Her ligger alle variabler. Og her ligger instruksjonene. Tidligere så var det dette som var måten datamaskiner kjørte på. Man hadde bare... Man kjørte bare én oppgave av gangen. Så enten var det brukerprogram som kjørte, eller OS. Og da ser vi for... Selv om det var singeltasking, betyr det at det da er bare én prosess som kan kjøre av gangen. Det typiske som skjedde når man kjørte singeltasking OS, var at operativsystemet startet opp først. Og så hadde man da ett brukerprogram. Og når dette skulle kjøre, så satte OS i gang brukerprogrammet og kjøre. Og så hadde da Device-minne, Skjerm-minne osv. brukerdata eller Heap. Alle disse bitene hadde det. Men det var da bare én prosess som kunne kjøre av gangen. En sånn batch computing... Du hadde kanskje en rein operasjon som kunne ta en halvtime. Og da satte operativstemmet i gang denne operasjonen. Og så kjørte den til den var ferdig, og så kunne neste program starte. Men alle moderne systemer har mulighet... Det er et system som kan få et antall programmer til å kjøre samtidig. Så her har vi et operativsystem som har to prosesser som kjører samtidig. Måten operativsystemet får til det på, det er at den deler opp tiden. Altså gir den litt tid til hver prosess, sånn at det ser ut som de kjører samtidig. Egentlig kjører de hand i gang, men for prosessene ser det ut som de kjører samtidig, og det er rett og slett multitasking. Men vi ser at hver prosess vil ha sitt eget område med heap og stack og program eller tekst eller kode, og også IO-områder. Altså for å snakke med disk, ta imot fra tastatur osv. Og multitasking, det er da det systemet som operativsystemet bruker for å kjøre prosesser samtidig. Hovedideen her er at CPU-tiden blir delt opp. Typisk størrelse på en liten bit av tiden man kan kjøre, er et hundredels sekund. Da har man en såkalt round robin-kø, og så har man en hardware-timer. Skal se på dette i detalj. Hvert hundredels sekund så sender et interrupt-signal til SIPPU. Så starter man opp den første... Den legges da i institusjonsregisteret. Og så lar OUS hver prosess etter tur brukes i PUN. Så CPU-en går da på rundgang mellom alle prosesser som ønsker å kjøpe.', 'chunks': [{'timestamp': (0.0, 7.8), 'text': ' Ok. Det var en liten gjennomgang av Linux-historie.'}, {'timestamp': (7.88, 17.64), 'text': ' Nå skal vi gå inn på et helt nytt tema, nemlig multitasking.'}, {'timestamp': (19.64, 24.76), 'text': ' Aller først skal vi for tredje gang se på CPU-løkken.'}, {'timestamp': (25.14, 27.48), 'text': ' Det er dette vi må ha med videre.'}, {'timestamp': (30.0, 34.08), 'text': ' Og om og om igjen kjører instruksjoner.'}, {'timestamp': (34.08, 40.04), 'text': ' Det vi skal se litt nærmere på nå, er interrupt request.'}, {'timestamp': (40.12, 45.28), 'text': ' For en gang iblant så kan det komme et fysisk interrupt-orkest.'}, {'timestamp': (45.36, 49.84), 'text': ' F.eks. ved at jeg taster på tastaturet sånn.'}, {'timestamp': (50.04, 54.92), 'text': ' Maskinen må da reagere på den inntastingen veldig hurtig.'}, {'timestamp': (54.92, 59.48), 'text': ' Og det som da skjer, er at...'}, {'timestamp': (60.0, 68.74), 'text': ' Den avbrytes i sin evige løkke, og så håndterer den det signalet.'}, {'timestamp': (68.74, 75.28), 'text': ' Ofte brukes det pund noen mikrosekunder på å fullføre det den er i gang med.'}, {'timestamp': (75.28, 80.2), 'text': ' Og så hopper den til en interrupt rutine, som da sørger for'}, {'timestamp': (80.2, 87.88), 'text': ' at den piltasten som jeg trykket på, at den har en effekt.'}, {'timestamp': (90.0, 92.44), 'text': ' Den må avbrytes for å håndtere signalet.'}, {'timestamp': (92.52, 96.4), 'text': ' Da må man lagre adressen til neste institusjon,'}, {'timestamp': (96.4, 100.16), 'text': ' og så hoppe til en interrupt-rutine.'}, {'timestamp': (100.24, 104.24), 'text': ' Det blir litt som å gjøre et kall på en rutine,'}, {'timestamp': (104.24, 108.52), 'text': ' men her er det en fysisk interrupt som sendes inn,'}, {'timestamp': (108.6, 111.84), 'text': ' og så gjøres det kall på rutinen.'}, {'timestamp': (111.9, 118.8), 'text': ' Hvert interrupt eller IRQ har sin egen rutine som man da hopper til.'}, {'timestamp': (120.0, 124.8), 'text': ' Noe fra tastaturet, en annen hvis det kommer fra nettverket,'}, {'timestamp': (124.8, 129.4), 'text': ' en tredje hvis det kommer fra mikrofonen, osv.'}, {'timestamp': (132.84, 135.8), 'text': ' Vi skal se på multitasking.'}, {'timestamp': (137.8, 144.92), 'text': ' For å forstå multitasking er det viktig å vite hvordan minne eller ramm'}, {'timestamp': (144.94, 148.64), 'text': ' er koblet sammen med prosesser.'}, {'timestamp': (150.0, 156.6), 'text': ' Vi skal fokusere på ramm direkte, og da skal vi se mer på dette.'}, {'timestamp': (156.68, 166.64), 'text': ' Men det vi trenger å vite nå, er at det finnes flere deler i ramm som er tildelt en prosess.'}, {'timestamp': (166.72, 174.68), 'text': ' Dette som vi viser bildet her nå, det er én bit av ramm som er tilordnet én prosess.'}, {'timestamp': (174.68, 178.8), 'text': ' Operativsystemet er også en egen prosess.'}, {'timestamp': (180.0, 190.2), 'text': ' Den viktigste biten er kanskje koden eller teksten, som vi ser her nede.'}, {'timestamp': (191.44, 200.84), 'text': ' Unnskyld. Koden, det er da maskininstruksjonene som prosessen skal kjøre.'}, {'timestamp': (200.84, 204.76), 'text': ' Som ligger etter hverandre. Institusjon for institusjon.'}, {'timestamp': (204.78, 209.86), 'text': ' Det typiske som skjer når en prosess kjører, er at man starter på første institusjon til prosessen.'}, {'timestamp': (210.0, 215.48), 'text': ' Så er det gjerne en loop her, så den hopper opp og ned.'}, {'timestamp': (215.48, 222.04), 'text': ' Men så har vi sett at vi hele tiden har variabler i programmet,'}, {'timestamp': (222.12, 225.64), 'text': ' som brukes og skrives til ram.'}, {'timestamp': (225.64, 232.4), 'text': ' Og da i heapen, som går fra koden her og oppover,'}, {'timestamp': (233.08, 237.08), 'text': ' er det satt av masse plass til heapen, sånn at den kan utvide seg.'}, {'timestamp': (237.16, 239.96), 'text': ' For her kan man dynamisk legge inn nye variabler.'}, {'timestamp': (240.0, 247.04), 'text': ' De legges da på heapen.'}, {'timestamp': (247.04, 253.36), 'text': ' Stacken, det er et område hvor lokale variabler legges.'}, {'timestamp': (253.44, 259.48), 'text': ' F.eks. hvis du gjør et funksjonskall, så legger du på stacken'}, {'timestamp': (260.52, 265.32), 'text': ' returverdien fra det funksjonskallet, så man vet hvor man skal tilbake.'}, {'timestamp': (265.4, 269.98), 'text': ' Da er det enkelt å bare gå inn der. Så plukker du opp...'}, {'timestamp': (270.0, 280.0), 'text': ' I tillegg er det vanlig å ha en MM-mapp, som er en avbildning av filer og deviser inn i ramm.'}, {'timestamp': (285.18, 288.64), 'text': ' Men dette er igjen for at ting skal gå fortere.'}, {'timestamp': (288.64, 296.3), 'text': ' Så er det en kopi av noe av det som ligger på disk, sånn at man skal ha raskere aksess.'}, {'timestamp': (300.0, 303.96), 'text': ' Og Jeep, det er det vi snakker om.'}, {'timestamp': (303.96, 310.6), 'text': ' Her ligger alle variabler. Og her ligger instruksjonene.'}, {'timestamp': (318.04, 326.56), 'text': ' Tidligere så var det dette som var måten datamaskiner kjørte på.'}, {'timestamp': (326.56, 329.72), 'text': ' Man hadde bare...'}, {'timestamp': (330.0, 333.12), 'text': ' Man kjørte bare én oppgave av gangen.'}, {'timestamp': (333.12, 341.0), 'text': ' Så enten var det brukerprogram som kjørte, eller OS.'}, {'timestamp': (341.0, 348.4), 'text': ' Og da ser vi for...'}, {'timestamp': (350.6, 353.44), 'text': ' Selv om det var singeltasking,'}, {'timestamp': (353.44, 358.96), 'text': ' betyr det at det da er bare én prosess som kan kjøre av gangen.'}, {'timestamp': (360.0, 364.28), 'text': ' Det typiske som skjedde når man kjørte singeltasking OS,'}, {'timestamp': (364.28, 368.24), 'text': ' var at operativsystemet startet opp først.'}, {'timestamp': (368.24, 371.4), 'text': ' Og så hadde man da ett brukerprogram.'}, {'timestamp': (371.4, 382.64), 'text': ' Og når dette skulle kjøre, så satte OS i gang brukerprogrammet og kjøre.'}, {'timestamp': (382.72, 389.92), 'text': ' Og så hadde da Device-minne, Skjerm-minne osv. brukerdata eller Heap.'}, {'timestamp': (390.0, 392.4), 'text': ' Alle disse bitene hadde det.'}, {'timestamp': (392.4, 397.8), 'text': ' Men det var da bare én prosess som kunne kjøre av gangen.'}, {'timestamp': (397.88, 401.2), 'text': ' En sånn batch computing...'}, {'timestamp': (401.28, 405.76), 'text': ' Du hadde kanskje en rein operasjon som kunne ta en halvtime.'}, {'timestamp': (405.84, 409.68), 'text': ' Og da satte operativstemmet i gang denne operasjonen.'}, {'timestamp': (409.76, 415.16), 'text': ' Og så kjørte den til den var ferdig, og så kunne neste program starte.'}, {'timestamp': (415.16, 418.84), 'text': ' Men alle moderne systemer har mulighet...'}, {'timestamp': (420.0, 428.94), 'text': ' Det er et system som kan få et antall programmer til å kjøre samtidig.'}, {'timestamp': (428.94, 436.56), 'text': ' Så her har vi et operativsystem som har to prosesser som kjører samtidig.'}, {'timestamp': (436.56, 441.04), 'text': ' Måten operativsystemet får til det på,'}, {'timestamp': (441.06, 445.32), 'text': ' det er at den deler opp tiden.'}, {'timestamp': (446.08, 449.84), 'text': ' Altså gir den litt tid til hver prosess, sånn at det ser ut som de kjører samtidig.'}, {'timestamp': (450.0, 454.36), 'text': ' Egentlig kjører de hand i gang, men for prosessene ser det ut som'}, {'timestamp': (454.44, 458.44), 'text': ' de kjører samtidig, og det er rett og slett multitasking.'}, {'timestamp': (458.44, 465.16), 'text': ' Men vi ser at hver prosess vil ha sitt eget område med heap og stack'}, {'timestamp': (465.24, 472.04), 'text': ' og program eller tekst eller kode, og også IO-områder.'}, {'timestamp': (472.94, 476.48), 'text': ' Altså for å snakke med disk, ta imot fra tastatur osv.'}, {'timestamp': (480.0, 489.88), 'text': ' Og multitasking, det er da det systemet som operativsystemet bruker'}, {'timestamp': (489.96, 497.96), 'text': ' for å kjøre prosesser samtidig.'}, {'timestamp': (497.96, 507.96), 'text': ' Hovedideen her er at CPU-tiden blir delt opp.'}, {'timestamp': (510.0, 520.52), 'text': ' Typisk størrelse på en liten bit av tiden man kan kjøre, er et hundredels sekund.'}, {'timestamp': (520.52, 525.8), 'text': ' Da har man en såkalt round robin-kø, og så har man en hardware-timer.'}, {'timestamp': (525.8, 531.0), 'text': ' Skal se på dette i detalj. Hvert hundredels sekund så sender et interrupt-signal til SIPPU.'}, {'timestamp': (531.08, 539.0), 'text': ' Så starter man opp den første...'}, {'timestamp': (540.0, 546.28), 'text': ' Den legges da i institusjonsregisteret.'}, {'timestamp': (546.28, 551.88), 'text': ' Og så lar OUS hver prosess etter tur brukes i PUN.'}, {'timestamp': (551.96, 557.8), 'text': ' Så CPU-en går da på rundgang mellom alle prosesser som ønsker å kjøpe.'}]}