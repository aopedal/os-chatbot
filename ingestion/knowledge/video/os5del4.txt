{'text': ' Det var den funksjonen... Sumfunksjonen. Denne. Og... Det vi så på sist, var at vi ba GCC om å lage assemblekode for den. Så så vi hvordan den så ut. Vi kan repetere det. Jeg ba... GCC om da å lage assemblerkode. Og den skulle da bli sum funksjon dos bes. Og den så ut som noe sånt som dette her. Så fant vi ut... Hvis vi går inn og ser i detalj, så ligner den veldig på den maskinkoden vi hadde i simuleringen. Bortsett fra denne skriver nå ut til minnene. Vi ser deg hele tiden. Men i prinsippet ligner koden veldig. Lager løkker på samme måte. Men det vi skulle se på nå, var hva skjer med denne funksjonen hvis jeg ber om lag så effektiv kode som bare mulig? Jo, da kan vi prøve å se hva som skjer, da. Da får jeg en ny assembly-kode. Og denne er da lagd av GCC for å være mest mulig effektiv. Og da ser vi ganske overraskende at her var det ikke veldig mye kode. Noen som klarer å se hva denne koden her gjør. Den skal jo regne ut en hel sum, men det er veldig få instruksjoner her. Og det som da viser seg, er at kompilatoren er faktisk da så smart... Det er klart at den ser vel uansett hva som skjer med input og output i denne metoden. Uansett når denne kjøres, så vil du regne ut en sum 1 pluss 2 pluss 3 som blir 6. Så den gjør da faktisk den optimale optimaliseringen. Den regner ut hele løkka, og så kommer den fram til at svaret blir seks. Så svarer 6 ut i AX, og så returnerer det. Så det er morsomt nok. Så er det den optimale... Den optimale versjonen av dette... Av denne løkka her. Det er jo bare å returnere tallet 6. Det virker jo litt overraskende, men det er helt logisk. GCC går nå inn for å lage... Den hurtigst mulige versjonen av denne koden. Og det er da faktisk bare å returnere tallet seks. Med en gang du får et input her, eller det kan skje andre ting, så er det klart, da kan man ikke optimalisere på den måten. Så hvis vi la til et input, så ville du sett at det fortsatt var en løkke, men at programmet da stort sett bare brukte registeret.', 'chunks': [{'timestamp': (0.0, 5.0), 'text': ' Det var den funksjonen... Sumfunksjonen.'}, {'timestamp': (8.2, 11.6), 'text': ' Denne. Og...'}, {'timestamp': (12.52, 19.88), 'text': ' Det vi så på sist, var at vi ba GCC om å lage assemblekode for den.'}, {'timestamp': (19.88, 24.84), 'text': ' Så så vi hvordan den så ut. Vi kan repetere det.'}, {'timestamp': (25.52, 28.92), 'text': ' Jeg ba...'}, {'timestamp': (30.0, 34.12), 'text': ' GCC om da å lage assemblerkode.'}, {'timestamp': (34.24, 38.68), 'text': ' Og den skulle da bli sum funksjon dos bes.'}, {'timestamp': (38.78, 43.28), 'text': ' Og den så ut som noe sånt som dette her.'}, {'timestamp': (43.28, 47.28), 'text': ' Så fant vi ut... Hvis vi går inn og ser i detalj,'}, {'timestamp': (47.4, 54.4), 'text': ' så ligner den veldig på den maskinkoden vi hadde i simuleringen.'}, {'timestamp': (54.48, 58.96), 'text': ' Bortsett fra denne skriver nå ut til minnene. Vi ser deg hele tiden.'}, {'timestamp': (60.0, 64.56), 'text': ' Men i prinsippet ligner koden veldig.'}, {'timestamp': (64.56, 66.36), 'text': ' Lager løkker på samme måte.'}, {'timestamp': (66.36, 71.64), 'text': ' Men det vi skulle se på nå, var hva skjer med denne funksjonen'}, {'timestamp': (71.64, 76.36), 'text': ' hvis jeg ber om lag så effektiv kode som bare mulig?'}, {'timestamp': (76.38, 80.0), 'text': ' Jo, da kan vi prøve å se hva som skjer, da.'}, {'timestamp': (80.2, 85.24), 'text': ' Da får jeg en ny assembly-kode.'}, {'timestamp': (85.24, 89.4), 'text': ' Og denne er da lagd av GCC for å være mest mulig effektiv.'}, {'timestamp': (90.0, 95.54), 'text': ' Og da ser vi ganske overraskende at'}, {'timestamp': (95.56, 98.72), 'text': ' her var det ikke veldig mye kode.'}, {'timestamp': (98.72, 104.56), 'text': ' Noen som klarer å se hva denne koden her gjør.'}, {'timestamp': (107.56, 114.76), 'text': ' Den skal jo regne ut en hel sum, men det er veldig få instruksjoner her.'}, {'timestamp': (114.8, 118.24), 'text': ' Og det som da viser seg, er at kompilatoren er faktisk da så smart...'}, {'timestamp': (120.0, 129.84), 'text': ' Det er klart at den ser vel uansett hva som skjer med input og output i denne metoden.'}, {'timestamp': (129.84, 137.4), 'text': ' Uansett når denne kjøres, så vil du regne ut en sum 1 pluss 2 pluss 3 som blir 6.'}, {'timestamp': (137.4, 142.92), 'text': ' Så den gjør da faktisk den optimale optimaliseringen.'}, {'timestamp': (142.92, 148.96), 'text': ' Den regner ut hele løkka, og så kommer den fram til at svaret blir seks.'}, {'timestamp': (150.0, 153.56), 'text': ' Så svarer 6 ut i AX, og så returnerer det.'}, {'timestamp': (153.56, 160.0), 'text': ' Så det er morsomt nok. Så er det den optimale...'}, {'timestamp': (162.56, 167.68), 'text': ' Den optimale versjonen av dette...'}, {'timestamp': (167.68, 173.36), 'text': ' Av denne løkka her. Det er jo bare å returnere tallet 6.'}, {'timestamp': (173.36, 178.96), 'text': ' Det virker jo litt overraskende, men det er helt logisk. GCC går nå inn for å lage...'}, {'timestamp': (180.0, 184.0), 'text': ' Den hurtigst mulige versjonen av denne koden.'}, {'timestamp': (184.0, 188.84), 'text': ' Og det er da faktisk bare å returnere tallet seks.'}, {'timestamp': (188.94, 195.18), 'text': ' Med en gang du får et input her, eller det kan skje andre ting,'}, {'timestamp': (195.28, 198.92), 'text': ' så er det klart, da kan man ikke optimalisere på den måten.'}, {'timestamp': (198.92, 203.72), 'text': ' Så hvis vi la til et input, så ville du sett at det fortsatt var en løkke,'}, {'timestamp': (203.72, 209.0), 'text': ' men at programmet da stort sett bare brukte registeret.'}]}